<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Wheel Forge (Unified V1)</title>
<style>
  :root{
    --bg:#0b0f17;
    --panel:rgba(18,26,40,.80);
    --panel2:rgba(15,22,35,.75);
    --text:#e8eefc;
    --muted:rgba(232,238,252,.65);
    --line:rgba(255,255,255,.10);
    --accent:#7aa8ff;
    --good:#2ee59d;
    --bad:#ff4d6d;
    --warn:#ffcc66;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
    color:var(--text);
    background:radial-gradient(900px 600px at 25% 10%, rgba(122,168,255,.22), transparent 60%),
               radial-gradient(900px 600px at 75% 40%, rgba(46,229,157,.12), transparent 60%),
               linear-gradient(to bottom, #070a10, #0b0f17 45%, #070a10);
    overflow-x:hidden;
  }
  .wrap{max-width:1120px;margin:0 auto;padding:16px 14px 120px}
  header{
    display:flex;gap:12px;align-items:center;justify-content:space-between;
    padding:12px;border:1px solid var(--line);border-radius:16px;
    background:var(--panel);backdrop-filter:blur(10px);
  }
  .title{line-height:1.1}
  .title b{font-size:18px;letter-spacing:.2px}
  .title span{font-size:12px;color:var(--muted)}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .pill{
    font-size:12px;border:1px solid var(--line);
    padding:6px 10px;border-radius:999px;background:var(--panel2);color:var(--muted);
    white-space:nowrap;
  }
  .pill strong{color:var(--text)}
  .btn{
    border:1px solid var(--line);background:var(--panel2);color:var(--text);
    padding:10px 12px;border-radius:12px;cursor:pointer;user-select:none;
    display:inline-flex;align-items:center;justify-content:center;gap:8px;
    font-weight:900;transition:transform .08s ease,opacity .15s ease;
  }
  .btn:active{transform:scale(.985)}
  .btn.primary{border-color:rgba(122,168,255,.35);background:linear-gradient(135deg, rgba(122,168,255,.25), rgba(122,168,255,.06))}
  .btn.good{border-color:rgba(46,229,157,.35);background:linear-gradient(135deg, rgba(46,229,157,.18), rgba(46,229,157,.06))}
  .btn.bad{border-color:rgba(255,77,109,.35);background:linear-gradient(135deg, rgba(255,77,109,.20), rgba(255,77,109,.06))}
  .btn.ghost{background:transparent}
  .btn:disabled{opacity:.55;cursor:not-allowed}
  .grid{display:grid;grid-template-columns:1.1fr .9fr;gap:12px;margin-top:12px}
  @media (max-width:920px){.grid{grid-template-columns:1fr}}
  .card{
    border:1px solid var(--line);border-radius:16px;background:var(--panel);
    padding:12px;
  }
  .card h3{margin:0 0 10px;font-size:13px;letter-spacing:.3px;color:rgba(232,238,252,.82)}
  .tabs{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px}
  .tab{
    padding:9px 12px;border-radius:999px;border:1px solid var(--line);
    background:rgba(15,22,35,.65);cursor:pointer;font-weight:1000;font-size:12px;
    color:rgba(232,238,252,.72);user-select:none;
  }
  .tab.active{color:var(--text);border-color:rgba(122,168,255,.35);background:linear-gradient(135deg, rgba(122,168,255,.18), rgba(15,22,35,.65))}
  .tab.locked{opacity:.45}
  .twoCol{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  @media (max-width:740px){.twoCol{grid-template-columns:1fr}}
  .statLine{
    display:flex;align-items:center;justify-content:space-between;
    padding:8px 10px;border:1px solid var(--line);border-radius:12px;background:rgba(15,22,35,.55);
    font-size:12px;
  }
  .statKey{color:rgba(232,238,252,.70);font-weight:900}
  .statVal{color:var(--text);font-weight:900;text-align:right;max-width:62%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
  .log{
    font-size:12px;color:rgba(232,238,252,.78);
    border:1px solid var(--line);border-radius:12px;background:rgba(15,22,35,.55);
    padding:10px;max-height:260px;overflow:auto;
  }
  .muted{color:var(--muted)}
  .wheelBox{display:grid;grid-template-columns:420px 1fr;gap:12px;align-items:start}
  @media (max-width:920px){.wheelBox{grid-template-columns:1fr}}
  canvas{width:100%;max-width:420px;aspect-ratio:1/1;border-radius:18px;border:1px solid var(--line);background:rgba(10,14,22,.65)}
  .hint{font-size:12px;color:var(--muted)}
  .badgeRow{display:flex;gap:8px;flex-wrap:wrap}
  .badge{
    display:inline-flex;gap:8px;align-items:center;
    padding:6px 10px;border-radius:999px;border:1px solid var(--line);
    background:rgba(15,22,35,.55);font-size:12px;font-weight:900;color:rgba(232,238,252,.78);
  }
  .barWrap{height:12px;border:1px solid var(--line);border-radius:999px;background:rgba(15,22,35,.55);overflow:hidden}
  .bar{height:100%;width:50%}
  .bar.good{background:linear-gradient(90deg, rgba(46,229,157,.95), rgba(46,229,157,.35))}
  .bar.bad{background:linear-gradient(90deg, rgba(255,77,109,.95), rgba(255,77,109,.35))}
  .toast{
    position:fixed;left:50%;bottom:16px;transform:translateX(-50%);
    background:rgba(15,22,35,.92);border:1px solid var(--line);
    padding:10px 14px;border-radius:14px;font-weight:900;font-size:12px;
    opacity:0;pointer-events:none;transition:opacity .15s ease, transform .15s ease;
    z-index:99;
  }
  .toast.show{opacity:1;transform:translateX(-50%) translateY(-3px)}
  .modalShade{
    position:fixed;inset:0;background:rgba(0,0,0,.55);
    display:none;align-items:center;justify-content:center;z-index:100;
  }
  .modal{
    width:min(560px, calc(100vw - 28px));
    border:1px solid var(--line);border-radius:18px;background:rgba(18,26,40,.92);
    padding:14px;
  }
  .modal h2{margin:0 0 8px;font-size:14px}
  .modal p{margin:0 0 12px;font-size:12px;color:var(--muted);line-height:1.35}
  input[type="text"]{
    width:100%;padding:12px 12px;border-radius:12px;border:1px solid var(--line);
    background:rgba(15,22,35,.7);color:var(--text);font-weight:900;
    outline:none;
  }
  .portrait{
    width:100%;aspect-ratio:1/1;border-radius:18px;border:1px solid var(--line);
    background:rgba(15,22,35,.55);overflow:hidden;position:relative;
  }
  .portrait img{width:100%;height:100%;object-fit:cover;display:block}
  .mini{
    font-size:11px;color:rgba(232,238,252,.7);
  }
</style>
</head>

<body>
<div class="wrap">
  <header>
    <div class="title">
      <b>Wheel Forge</b>
      <span>Unified build â€¢ additive stats â€¢ permadeath â€¢ PvE (PvP later)</span>
    </div>
    <div class="row">
      <div class="pill" id="namedTag"><strong>Tap Name</strong></div>
      <div class="pill" id="phaseTag"><strong>Phase:</strong> â€”</div>
      <div class="pill" id="charTag"><strong>Char:</strong> 1/1</div>
      <button class="btn" id="soundBtn" title="Sound">ðŸ”Š</button>
      <button class="btn ghost" id="resetBtn" title="Dev reset (hidden)">Reset</button>
    </div>
  </header>

  <div class="tabs">
    <div class="tab active" data-tab="build">Build</div>
    <div class="tab locked" data-tab="stats">Stats</div>
    <div class="tab locked" data-tab="pve">PvE</div>
    <div class="tab" data-tab="roster">Roster</div>
    <div class="tab" data-tab="progress">Progress</div>
  </div>

  <div class="grid">
    <div class="card" id="tab-build">
      <h3>Wheel</h3>
      <div class="wheelBox">
        <div>
          <canvas id="wheel" width="600" height="600"></canvas>
          <div class="row" style="margin-top:10px">
            <button class="btn primary" id="spinBtn">Spin</button>
            <button class="btn" id="newBuildBtn">New Character</button>
            <button class="btn bad" id="sacrificeBtn">Sacrifice</button>
          </div>
          <div class="row" style="margin-top:8px">
            <div class="pill" id="wheelTitle"><strong>â€”</strong></div>
            <div class="pill" id="wheelHint"><strong>â€”</strong></div>
          </div>
          <div class="mini" style="margin-top:8px">
            Build is <b>locked</b> once complete. Character dies permanently on PvE loss unless protected.
          </div>
        </div>

        <div>
          <div class="portrait">
            <img id="portraitImg" alt="portrait"/>
          </div>
          <div class="badgeRow" style="margin-top:10px" id="buildBadges"></div>
          <div style="margin-top:10px" class="twoCol">
            <div>
              <h3 style="margin-top:0">Build Summary</h3>
              <div id="buildStats"></div>
            </div>
            <div>
              <h3 style="margin-top:0">Build Log</h3>
              <div class="log" id="buildLog"></div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="card" id="tab-stats" style="display:none">
      <h3>Stats</h3>
      <div class="twoCol">
        <div>
          <h3 style="margin:0 0 10px">Raw (Spun)</h3>
          <div id="statsList"></div>
        </div>
        <div>
          <h3 style="margin:0 0 10px">Final (Additive)</h3>
          <div id="finalStatsList"></div>
        </div>
      </div>
      <div style="margin-top:10px" class="mini">
        Final stats stack from: <b>wheel base</b> + <b>owned traits</b> (powers/weapons/trainers) + <b>mastery</b> + <b>progress bonuses</b> + <b>fusions</b> + <b>curses</b>.
      </div>
    </div>

    <div class="card" id="tab-pve" style="display:none">
      <h3>PvE</h3>
      <div class="row" style="margin-bottom:10px">
        <button class="btn good" id="pveStartBtn">Start PvE</button>
        <button class="btn" id="pveFleeBtn">Attempt Flee</button>
        <button class="btn" id="eventBtn">Trigger Event</button>
        <button class="btn" id="worldBossBtn">World Boss</button>
        <button class="btn" id="apexBtn">Apex</button>
      </div>

      <div class="twoCol">
        <div>
          <h3 style="margin:0 0 10px">HP</h3>
          <div class="statLine"><div class="statKey">Player</div><div class="statVal" id="pvePlayerHP">â€”</div></div>
          <div class="barWrap" style="margin-top:8px"><div class="bar good" id="pvePBar"></div></div>

          <div style="height:10px"></div>

          <div class="statLine"><div class="statKey">Enemy</div><div class="statVal" id="pveEnemyHP">â€”</div></div>
          <div class="barWrap" style="margin-top:8px"><div class="bar bad" id="pveEBar"></div></div>

          <div style="margin-top:10px" class="statLine">
            <div class="statKey">Encounter</div>
            <div class="statVal" id="pveEncounter">â€”</div>
          </div>
        </div>

        <div>
          <h3 style="margin:0 0 10px">PvE Log</h3>
          <div class="log" id="pveLog"></div>
        </div>
      </div>
      <div style="margin-top:10px" class="mini">
        Flee rule: if your <b>Speed</b> is close, you can flee. The bigger the gap, the worse your chances.
      </div>
    </div>

    <div class="card" id="tab-roster" style="display:none">
      <h3>Roster</h3>
      <div class="row" style="margin-bottom:10px">
        <button class="btn" id="prevCharBtn">â—€</button>
        <button class="btn" id="nextCharBtn">â–¶</button>
        <button class="btn bad" id="deleteDeadBtn">Delete Dead</button>
      </div>
      <div id="rosterList"></div>
    </div>

    <div class="card" id="tab-progress" style="display:none">
      <h3>Progress</h3>
      <div id="progressList"></div>
      <div style="margin-top:10px" class="mini">
        Sacrifice converts a character into permanent bonuses (souls). World bosses and apex fights are harder and reward more.
      </div>
    </div>
  </div>
</div>

<div class="toast" id="toast">â€”</div>

<div class="modalShade" id="nameModal">
  <div class="modal">
    <h2>Name your character</h2>
    <p>Max 12 chars. No renaming later. Letters/numbers/spaces only.</p>
    <input id="nameInput" type="text" maxlength="12" placeholder="Enter name..." />
    <div class="row" style="margin-top:10px;justify-content:flex-end">
      <button class="btn" id="nameCancelBtn">Cancel</button>
      <button class="btn primary" id="nameOkBtn">Set Name</button>
    </div>
  </div>
</div>

<script>
/* =========================================================
   UNIFIED ENGINE â€” EVERYTHING IN ONE SYSTEM (NO DUPES)
   - Roster / permadeath
   - Wheel sequence + special wheels
   - Additive stats + ??? label
   - 150+ fusions (procedurally generated + deterministic)
   - PvE: normal / event / world boss / apex
   - Curses, events, sacrifice, progress bonuses
========================================================= */

/* ---------- Helpers ---------- */
const $ = (id)=>document.getElementById(id);
function escapeHtml(s){
  return String(s ?? "").replace(/[&<>"']/g, m=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[m]));
}
let _toastTimer=null;
function toast(msg){
  const t = $("toast"); if(!t) return;
  t.textContent = msg;
  t.classList.add("show");
  clearTimeout(_toastTimer);
  _toastTimer=setTimeout(()=>t.classList.remove("show"), 1400);
}
function nowTime(){
  return new Date().toLocaleTimeString([], {hour:"2-digit", minute:"2-digit"});
}
function logBuild(msg){
  const el = $("buildLog"); if(!el) return;
  el.innerHTML = `<div><span class="muted">[${nowTime()}]</span> ${escapeHtml(msg)}</div>` + el.innerHTML;
}
function logPVE(msg){
  const el = $("pveLog"); if(!el) return;
  el.innerHTML = `<div><span class="muted">[${nowTime()}]</span> ${escapeHtml(msg)}</div>` + el.innerHTML;
}
function clamp01(x){ return Math.max(0, Math.min(1, x)); }
function randInt(a,b){ return a + Math.floor(Math.random()*(b-a+1)); }
function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function uniqPush(arr, v){ if(!arr.includes(v)) arr.push(v); }

/* ---------- Save/Load ---------- */
let state = window.state || {};
const STORAGE_KEY = "wheel_forge_unified_v1";
function saveNow(){ try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }catch(e){} }
function loadNow(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(!raw) return;
    const parsed = JSON.parse(raw);
    if(parsed && typeof parsed === "object") state = Object.assign({}, state, parsed);
  }catch(e){}
}
loadNow();
state.settings ||= {};
if(typeof state.settings.sound !== "boolean") state.settings.sound = true;
state.progress ||= {
  coins:0, xp:0,
  souls:0,
  soulBonus:{ strength:0, durability:0, speed:0, iq:0, fight:0 },
  adaptationStacks:0,
  curseCount:0,
  bossesDefeated:0,
  apexDefeated:0,
  eventsCleared:0
};
state.roster ||= [];
state.activeIndex ??= 0;

/* ---------- Sound (WebAudio, no files) ---------- */
const Sound = (function(){
  let ctx=null;
  function getCtx(){
    if(!ctx){
      const A = window.AudioContext || window.webkitAudioContext;
      if(!A) return null;
      ctx = new A();
    }
    return ctx;
  }
  function beep(freq=440, dur=0.06, type="sine", gain=0.05){
    try{
      if(state.settings.sound === false) return;
      const ac = getCtx(); if(!ac) return;
      ac.resume?.().catch(()=>{});
      const o = ac.createOscillator();
      const g = ac.createGain();
      o.type = type;
      o.frequency.value = freq;
      g.gain.value = gain;
      o.connect(g); g.connect(ac.destination);
      o.start(); o.stop(ac.currentTime + dur);
    }catch(e){}
  }
  function chord(seq){
    seq.forEach((x,i)=>setTimeout(()=>beep(x.f,x.d,x.t,x.g), i*50));
  }
  return {
    click(){ beep(520,0.04,"square",0.04); },
    spin(){ chord([{f:220,d:.06,t:"sine",g:.05},{f:330,d:.06,t:"sine",g:.05},{f:440,d:.06,t:"sine",g:.05}]); },
    win(){ chord([{f:523,d:.08,t:"triangle",g:.06},{f:659,d:.10,t:"triangle",g:.06},{f:784,d:.12,t:"triangle",g:.06}]); },
    warn(){ chord([{f:392,d:.06,t:"square",g:.05},{f:311,d:.08,t:"square",g:.05}]); },
    block(){ beep(150,0.10,"square",0.06); },
    toggle(){
      state.settings.sound = !(state.settings.sound === true);
      saveNow();
      return state.settings.sound;
    }
  };
})();

/* ---------- Button wiring: sound ---------- */
(function(){
  const b = $("soundBtn");
  function paint(){ b.textContent = (state.settings.sound !== false) ? "ðŸ”Š" : "ðŸ”‡"; }
  paint();
  b.addEventListener("click", ()=>{
    Sound.click();
    const on = Sound.toggle();
    paint();
    toast(on ? "Sound ON" : "Sound OFF");
  });
})();

/* =========================================================
   DATA â€” Wheels (from your lists) + expansions
========================================================= */

// Races (exact set you gave)
const RACES = [
  "Gnome","Goblin","Zombie","Skeleton","Human","Orc","Cyborg","Giant","Demi human","Golem",
  "Dragon","Vampire","Hivemind","Shinigami","Soul eater","Demon","Alien","God","Hybrid"
];

// Race special wheels
const GOD_TIERS = ["Halfling","Demigod","Lesser diety","Deity","Greater diety","Roman","Norse","Greek"];
const DEMON_RANKS = ["Jelly","Knight","Earl","Marquis","Prince","Duke","King"];
const ALIEN_TYPE = ["Kaiju","Non-Kaiju"];
const KAIJU_LIST = ["King Kong","Rodan","Ghidorah","Destoroyah","Gezora","Cloverfield","Mothra","Kumanga","Kaiju No 8","Godzilla"];
const KAIJU_NO8_LEVELS = ["1","2","4","6","8","9","10","11","12","13","14","15"];

// Stat words (wheel options)
const STRENGTH_WORDS = ["Weak","Average","Strong","City","Mountain","Country","Planet","Star","Galaxy","Universal","???"];
const DURABILITY_WORDS = ["Fragile","Average","Tough","Steel","City","Mountain","Country","Planet","Star","Universal","???"];
const SPEED_WORDS = ["Slow","Average","Fast","Mach","Lightning","Light","FTL","Galaxy","Universal","???"];
const IQ_WORDS = ["Low","Average","Smart","Genius","Supergenius","Cosmic","Universal","???"];
const FIGHT_WORDS = ["Clumsy","Average","Trained","Elite","Master","Legendary","Mythic","Universal","???"];

// Powers / weapons / trainer / mastery
const POWERS = [
  "No Power",
  "Adaptation","Regeneration","Immortal",
  "Gravity Manipulation","Time Manipulation","Telekinesis","Teleportation",
  "Fire","Ice Manipulation","Lightning","Weapon Creation",
  "Heavenly Restriction","Rinnegan",
  "Kaioken","Eight Gates","Titan Transformation",
  "Super saiyen"
];
const SUPER_SAIYEN_FORMS = ["Super saiyen","Super saiyen 4","Super saiyen god","Super saiyen blue","Ultra instinct"];

const WEAPONS = [
  "No Weapon","Sword","Scythe","Axe","Hammer","Spear","Brass Knuckles","Blades of Chaos","Samehada",
  "Uzumaki Chains","Infinity Gauntlet","Green Lantern Ring"
];

const TRAINERS = ["No Trainer","Master Roshi","Jiraiya","Hisoka","Korro","Yuujirou"];

const POWER_MASTERY = ["None","Dormant","Awakening","Controlled","Mastered","Planetary","Cosmic","Universal","Omnipotent"];
// You earlier wanted 5 levels for weapon mastery â€” keeping that for the wheel:
const WEAPON_MASTERY = ["Novice","Skilled","Expert","Master","Grandmaster"];

// Height wheels (Golem + Dragon on Giant wheel; Hybrid uses largest race wheel)
const HEIGHT_WHEELS = {
  small: ["2'0","2'6","3'0","3'6","4'0","4'6"],
  human: ["4'8","5'0","5'4","5'8","6'0","6'4","6'8"],
  tall: ["6'0","6'6","7'0","7'6","8'0","8'6","9'0"],
  giant: ["10'0","12'0","15'0","20'0","30'0","40'0","50'0","60'0"]
};
const SIZE_RANK = {
  "Gnome":1,"Goblin":1,
  "Zombie":2,"Skeleton":2,"Human":2,"Orc":2,"Cyborg":2,"Demi human":2,"Vampire":2,"Shinigami":2,"Soul eater":2,"Demon":2,"Alien":2,"God":2,"Hivemind":2,
  "Giant":4,"Golem":4,"Dragon":4,
  "Hybrid":3
};
function heightWheelForRace(race){
  if(["Gnome","Goblin"].includes(race)) return HEIGHT_WHEELS.small;
  if(["Giant","Golem","Dragon"].includes(race)) return HEIGHT_WHEELS.giant;
  if(["Orc"].includes(race)) return HEIGHT_WHEELS.tall;
  return HEIGHT_WHEELS.human;
}

/* =========================================================
   STATS â€” word->number mapping (additive, supports ???)
========================================================= */
const STAT_NUMBER_MAP = {
  strength: {"Weak":1,"Average":2,"Strong":3,"City":5,"Mountain":7,"Country":9,"Planet":12,"Star":15,"Galaxy":18,"Universal":22,"???":30},
  durability: {"Fragile":1,"Average":2,"Tough":3,"Steel":5,"City":7,"Mountain":9,"Country":11,"Planet":14,"Star":17,"Universal":22,"???":30},
  speed: {"Slow":1,"Average":2,"Fast":3,"Mach":5,"Lightning":7,"Light":10,"FTL":14,"Galaxy":18,"Universal":22,"???":30},
  iq: {"Low":1,"Average":2,"Smart":3,"Genius":5,"Supergenius":7,"Cosmic":12,"Universal":18,"???":25},
  fight: {"Clumsy":1,"Average":2,"Trained":3,"Elite":5,"Master":7,"Legendary":10,"Mythic":14,"Universal":20,"???":30}
};
function statWordToNumber(type, word){ return STAT_NUMBER_MAP[type]?.[word] ?? 0; }
function labelForStat(type, value){
  const map = STAT_NUMBER_MAP[type] || {};
  let best="???";
  for(const [label,num] of Object.entries(map)){
    if(value >= num) best = label;
  }
  return best;
}

/* =========================================================
   MODIFIERS â€” additive (powers / weapons / trainers / mastery)
========================================================= */
function powerMods(p){
  switch(p){
    case "Adaptation": return { durability:+2, fight:+1, stability:-1, tag:"adapt" };
    case "Regeneration": return { durability:+3, stability:-2, regen:true };
    case "Immortal": return { durability:+4, stability:-3, immortal:true };
    case "Gravity Manipulation": return { strength:+2, fight:+1 };
    case "Time Manipulation": return { speed:+3, iq:+1, stability:-2 };
    case "Telekinesis": return { iq:+2, fight:+1 };
    case "Teleportation": return { speed:+2 };
    case "Fire": return { strength:+1 };
    case "Ice Manipulation": return { durability:+1 };
    case "Lightning": return { speed:+2 };
    case "Weapon Creation": return { fight:+2 };
    case "Heavenly Restriction": return { strength:+3, speed:+2, durability:+2, fight:+2, iq:-1, stability:-1 };
    case "Rinnegan": return { iq:+2, fight:+2, stability:-1 };
    case "Kaioken": return { strength:+2, speed:+2, fight:+1, stability:-1 };
    case "Eight Gates": return { strength:+3, speed:+3, fight:+2, stability:-2 };
    case "Titan Transformation": return { strength:+3, durability:+3, fight:+1, stability:-2 };
    case "Super saiyen": return { strength:+2, speed:+1, durability:+1, fight:+1, stability:-2 };
    default: return {};
  }
}
function ssjFormMods(form){
  switch(form){
    case "Super saiyen": return { strength:+1, speed:+1, fight:+1 };
    case "Super saiyen 4": return { strength:+2, speed:+1, durability:+1, fight:+1 };
    case "Super saiyen god": return { speed:+2, iq:+1, fight:+1 };
    case "Super saiyen blue": return { strength:+2, speed:+2, durability:+1, fight:+1, iq:+1 };
    case "Ultra instinct": return { strength:+2, speed:+3, durability:+1, fight:+3, iq:+1 };
    default: return {};
  }
}
function weaponMods(w){
  switch(w){
    case "Sword": return { fight:+2 };
    case "Scythe": return { fight:+2, strength:+1 };
    case "Axe": return { strength:+2 };
    case "Hammer": return { strength:+2, durability:+1 };
    case "Spear": return { fight:+1, speed:+1 };
    case "Brass Knuckles": return { fight:+1, strength:+1 };
    case "Blades of Chaos": return { fight:+2, speed:+1 };
    case "Samehada": return { durability:+1, fight:+2 };
    case "Uzumaki Chains": return { durability:+2, fight:+1 };
    case "Infinity Gauntlet": return { strength:+4, durability:+4, iq:+2, fight:+2, stability:-4 };
    case "Green Lantern Ring": return { iq:+3, durability:+2 };
    default: return {};
  }
}
function trainerMods(t){
  switch(t){
    case "Master Roshi": return { fight:+2, iq:+1 };
    case "Jiraiya": return { fight:+2, iq:+1 };
    case "Hisoka": return { fight:+2, iq:+1 };
    case "Korro": return { durability:+1, fight:+1 };
    case "Yuujirou": return { strength:+3, fight:+2, stability:-1 };
    default: return {};
  }
}
function masteryMods(pm){
  switch(pm){
    case "Mastered": return { fight:+1, durability:+1 };
    case "Planetary": return { strength:+1, speed:+1 };
    case "Cosmic": return { strength:+2, speed:+2, iq:+1 };
    case "Universal": return { strength:+3, speed:+3, durability:+3, fight:+2, iq:+2, stability:-1 };
    case "Omnipotent": return { strength:+5, speed:+5, durability:+5, fight:+4, iq:+4, stability:-2 };
    default: return {};
  }
}
function weaponMasteryMods(wm){
  switch(wm){
    case "Skilled": return { fight:+1 };
    case "Expert": return { fight:+2, speed:+1 };
    case "Master": return { fight:+3, speed:+1, iq:+1 };
    case "Grandmaster": return { fight:+4, speed:+2, iq:+1 };
    default: return {};
  }
}

/* =========================================================
   STABILITY + CURSES
========================================================= */
const MAX_STABILITY = 5;
const MIN_STABILITY = -10;

function computeStability(c){
  let s = MAX_STABILITY;

  // powers/weapons/trainers/mastery reduce stability if specified
  (c.powers||[]).forEach(p=>{
    const pm = powerMods(p);
    if(typeof pm.stability === "number") s += pm.stability;
  });
  (c.weapons||[]).forEach(w=>{
    const wm = weaponMods(w);
    if(typeof wm.stability === "number") s += wm.stability;
  });
  if(c.trainer){
    const tm = trainerMods(c.trainer);
    if(typeof tm.stability === "number") s += tm.stability;
  }
  if(c.powerMastery){
    const mm = masteryMods(c.powerMastery);
    if(typeof mm.stability === "number") s += mm.stability;
  }

  // curses reduce stability
  (c.curses||[]).forEach(cur=>{
    if(cur?.stability) s += cur.stability; // stability values are negative in curses
  });

  return Math.max(MIN_STABILITY, s);
}
function isUnstable(c){ return computeStability(c) < 0; }

/* =========================================================
   FUSIONS â€” 150+ (procedural, deterministic, additive)
   - You said "150+ fusions": this generates hundreds without needing external files.
   - Fusion traits are additive mods + tags, never swaps.
========================================================= */
const FUSION_PREFIX = [
  "Abyssal","Astral","Omega","Viral","Prime","Mythic","Void","Solar","Lunar","Infernal",
  "Eternal","Arcane","Titan","Draconic","Cyber","Necro","Divine","Cursed","Storm","Quantum"
];
const FUSION_SUFFIX = [
  "Overlord","Warden","Reaper","Sentinel","Juggernaut","Sage","Vanguard","Ravager","Monarch","Oracle"
];

// Deterministic mod seeds per fusion â€œtierâ€
const FUSION_TIER_MODS = [
  {strength:1,durability:1,speed:0,iq:0,fight:1},
  {strength:2,durability:1,speed:1,iq:0,fight:1},
  {strength:2,durability:2,speed:1,iq:1,fight:2},
  {strength:3,durability:2,speed:2,iq:1,fight:2},
  {strength:4,durability:3,speed:2,iq:2,fight:3},
];

function buildFusionList(){
  // Make at least 200 unique fusions by combining prefixes + races + suffixes
  const list = [];
  for(const pre of FUSION_PREFIX){
    for(const race of RACES){
      if(race === "Hybrid") continue;
      for(const suf of FUSION_SUFFIX){
        const name = `${pre} ${race} ${suf}`;
        // stable hash -> tier
        let h=0;
        for(let i=0;i<name.length;i++){ h = (h*31 + name.charCodeAt(i)) >>> 0; }
        const tier = (h % FUSION_TIER_MODS.length);
        const mods = FUSION_TIER_MODS[tier];
        list.push({ name, tier: tier+1, mods });
        if(list.length >= 220) return list; // keep it efficient
      }
    }
  }
  return list;
}
const FUSIONS = buildFusionList();

/* Fusion rules:
   - Each character can hold multiple fusions.
   - Fusion is additive.
*/
function fusionMods(f){
  if(!f) return {};
  const m = f.mods || {};
  return { ...m, stability: (f.tier>=4 ? -1 : 0) };
}

/* =========================================================
   CHARACTER MODEL
========================================================= */
function newCharacter(){
  return {
    id: (crypto?.randomUUID?.() || ("c_"+Math.random().toString(16).slice(2)+Date.now().toString(16))),
    alive:true,
    buildComplete:false,
    name:"",
    nameLocked:false,

    // wheel results
    race:null,
    raceDetail:null,   // God tier / Demon rank / Alien type
    raceDetail2:null,  // Kaiju name
    raceDetail3:null,  // Kaiju No 8 level
    hybridRaces:[],    // [A,B]
    height:null,

    strengthW:null,
    durabilityW:null,
    speedW:null,
    iqW:null,
    fightW:null,

    powers:[],
    powerDetail:null,  // ssj form
    weapons:[],
    trainer:"No Trainer",
    powerMastery:"None",
    weaponMastery:"Novice",

    // fusions / curses
    fusions:[],
    curses:[],

    // death/strikes
    pveStrikes:0, // PvE: 1 strike = death
    deaths:0,

    // wheel flow
    phase:1
  };
}
if(!state.roster.length){
  state.roster.push(newCharacter());
  state.activeIndex = 0;
  saveNow();
}
function getActiveChar(){
  if(state.activeIndex < 0) state.activeIndex = 0;
  if(state.activeIndex >= state.roster.length) state.activeIndex = state.roster.length-1;
  return state.roster[state.activeIndex];
}

/* =========================================================
   NAME SYSTEM (modal, max 12, no rename)
========================================================= */
const NAME_MAX = 12;
function normalizeName(s){
  return String(s ?? "").trim().replace(/\s+/g," ");
}
function isNameAllowed(name){
  const n = normalizeName(name);
  if(!n) return {ok:false, reason:"Name is empty."};
  if(n.length > NAME_MAX) return {ok:false, reason:`Max ${NAME_MAX} characters.`};
  if(!/^[a-zA-Z0-9 ]+$/.test(n)) return {ok:false, reason:"Only letters, numbers, spaces."};
  if(/(.)\1\1\1/.test(n.toLowerCase())) return {ok:false, reason:"Looks spammy."};
  // Keep it safe: block common profanity without showing lists to UI
  const lower = n.toLowerCase();
  const banned = ["fuck","shit","bitch","asshole","dick","pussy","cunt","nigger","faggot"];
  if(banned.some(w => lower.includes(w))) return {ok:false, reason:"Inappropriate name."};
  return {ok:true, reason:""};
}
function openNameModal(){
  const c = getActiveChar();
  if(!c) return;
  if(c.nameLocked && c.name){
    toast("No renaming allowed.");
    Sound.warn();
    return;
  }
  $("nameInput").value = "";
  $("nameModal").style.display = "flex";
  setTimeout(()=>$("nameInput").focus(), 50);
}
function closeNameModal(){ $("nameModal").style.display = "none"; }
$("namedTag").style.cursor = "pointer";
$("namedTag").addEventListener("click", ()=>{ Sound.click(); openNameModal(); });
$("nameCancelBtn").addEventListener("click", ()=>{ Sound.click(); closeNameModal(); });
$("nameOkBtn").addEventListener("click", ()=>{
  Sound.click();
  const c = getActiveChar();
  const raw = $("nameInput").value;
  const check = isNameAllowed(raw);
  if(!check.ok){
    Sound.warn();
    toast(check.reason);
    return;
  }
  c.name = normalizeName(raw).slice(0,NAME_MAX);
  c.nameLocked = true;
  saveNow();
  closeNameModal();
  toast(`Name set: ${c.name}`);
  refreshUI();
});

/* =========================================================
   WHEEL ENGINE (pointer @ top, no conflicts)
   - Phases: race -> raceSpecial -> height -> stats -> power -> powerSpecial -> weapon -> trainer -> mastery -> weaponMastery -> fusion -> curse -> complete
   - Skips conditionals automatically
   - Hybrid: collects 2 extra race spins
========================================================= */
const wheelCanvas = $("wheel");
const wheelCtx = wheelCanvas.getContext("2d");
const TAU = Math.PI*2;
const POINTER_ANGLE = -Math.PI/2;

let WHEEL = {
  title:"Race",
  hint:"Spin to begin",
  items:[...RACES],
  angle:0,
  spinning:false
};

function setWheel(items, title, hint){
  WHEEL.items = (Array.isArray(items) && items.length) ? items.slice() : ["(empty)"];
  WHEEL.title = title || "Wheel";
  WHEEL.hint = hint || "Spin";
  $("wheelTitle").innerHTML = `<strong>${escapeHtml(WHEEL.title)}</strong>`;
  $("wheelHint").innerHTML = `<strong>${escapeHtml(WHEEL.hint)}</strong>`;
  drawWheel();
}

function drawWheel(){
  const ctx = wheelCtx;
  const w = wheelCanvas.width, h = wheelCanvas.height;
  const cx=w/2, cy=h/2;
  const r=Math.min(cx,cy)-10;
  ctx.clearRect(0,0,w,h);

  // ring
  ctx.beginPath();
  ctx.arc(cx,cy,r+5,0,TAU);
  ctx.strokeStyle="rgba(255,255,255,.14)";
  ctx.lineWidth=10;
  ctx.stroke();

  const n = Math.max(1, WHEEL.items.length);
  const slice = TAU/n;

  for(let i=0;i<n;i++){
    const a0 = WHEEL.angle + i*slice;
    const a1 = WHEEL.angle + (i+1)*slice;

    ctx.beginPath();
    ctx.moveTo(cx,cy);
    ctx.arc(cx,cy,r,a0,a1);
    ctx.closePath();
    ctx.fillStyle = i%2===0 ? "rgba(122,168,255,.14)" : "rgba(255,255,255,.06)";
    ctx.fill();

    const mid = (a0+a1)/2;
    ctx.save();
    ctx.translate(cx,cy);
    ctx.rotate(mid);
    ctx.textAlign="right";
    ctx.fillStyle="rgba(232,238,252,.92)";
    ctx.font="900 14px system-ui";
    ctx.fillText(String(WHEEL.items[i]), r-14, 6);
    ctx.restore();
  }

  // pointer at top
  ctx.beginPath();
  ctx.moveTo(cx, 10);
  ctx.lineTo(cx-12, 34);
  ctx.lineTo(cx+12, 34);
  ctx.closePath();
  ctx.fillStyle="rgba(255,204,102,.95)";
  ctx.fill();
}

function pickResultAtPointer(){
  const n = Math.max(1, WHEEL.items.length);
  const slice = TAU/n;
  let a = (POINTER_ANGLE - WHEEL.angle) % TAU;
  if(a < 0) a += TAU;
  const idx = Math.floor(a / slice);
  return WHEEL.items[Math.max(0, Math.min(n-1, idx))];
}

function spinWheel(onDone){
  const c = getActiveChar();
  if(!c) return;

  if(c.alive === false){
    Sound.block();
    toast("Character is dead.");
    return;
  }
  if(c.buildComplete){
    Sound.block();
    toast("Build locked. No re-spins.");
    return;
  }
  if(WHEEL.spinning) return;

  WHEEL.spinning = true;
  Sound.spin();

  let v = 0.38 + Math.random()*0.32;
  const friction = 0.985 - Math.random()*0.006;
  const minTicks = 65 + Math.floor(Math.random()*35);
  let t = 0;

  function step(){
    t++;
    WHEEL.angle += v;
    v *= friction;
    drawWheel();

    if(t > minTicks && v < 0.01){
      WHEEL.spinning = false;
      const result = pickResultAtPointer();
      onDone?.(result);
      return;
    }
    requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
}

/* =========================================================
   PHASE FLOW
========================================================= */
const PHASES = [
  "race",          // 1
  "raceSpecial",   // 2 (God/Demon/Alien/Hybrid collection)
  "height",        // 3
  "strength",      // 4
  "durability",    // 5
  "speed",         // 6
  "iq",            // 7
  "fight",         // 8
  "power",         // 9
  "powerSpecial",  // 10 (SSJ form)
  "weapon",        // 11
  "trainer",       // 12
  "powerMastery",  // 13
  "weaponMastery", // 14
  "fusion",        // 15 (optional but included)
  "curse",         // 16 (optional but included)
  "complete"       // 17
];

function phaseName(n){
  const p = PHASES[n-1] || "race";
  return p;
}
function setPhase(c, n){
  c.phase = n;
  $("phaseTag").innerHTML = `<strong>Phase:</strong> ${escapeHtml(PHASES[n-1] || "â€”")}`;
}

function wheelForPhase(c, phase){
  // Hybrid collection: when race is Hybrid and hybridRaces not complete, keep race wheel here.
  if(phase === "race"){
    return { title:"Race", hint:"Spin for your race", items:[...RACES] };
  }

  if(phase === "raceSpecial"){
    // Hybrid needs 2 extra races (not Hybrid)
    if(c.race === "Hybrid" && (c.hybridRaces||[]).length < 2){
      return { title:"Hybrid Race", hint:`Spin hybrid race ${(c.hybridRaces||[]).length+1}/2`, items:RACES.filter(r=>r!=="Hybrid") };
    }
    if(c.race === "God"){
      return { title:"God Tiers", hint:"Spin for god tier", items:[...GOD_TIERS] };
    }
    if(c.race === "Demon"){
      return { title:"Demon Ranks", hint:"Spin for demon rank", items:[...DEMON_RANKS] };
    }
    if(c.race === "Alien"){
      // If not chosen yet, choose Kaiju vs Non-Kaiju
      if(!c.raceDetail){
        return { title:"Alien Type", hint:"Kaiju or Non-Kaiju?", items:[...ALIEN_TYPE] };
      }
      // If Kaiju chosen but kaiju not chosen
      if(c.raceDetail === "Kaiju" && !c.raceDetail2){
        return { title:"Kaiju", hint:"Spin Kaiju", items:[...KAIJU_LIST] };
      }
      // If Kaiju No 8 chosen but level not chosen
      if(c.raceDetail === "Kaiju" && c.raceDetail2 === "Kaiju No 8" && !c.raceDetail3){
        return { title:"Kaiju No 8", hint:"Spin level", items:[...KAIJU_NO8_LEVELS] };
      }
    }
    return null;
  }

  if(phase === "height"){
    let baseRace = c.race;
    if(c.race === "Hybrid"){
      const a = c.hybridRaces?.[0];
      const b = c.hybridRaces?.[1];
      const ra = SIZE_RANK[a] || 2;
      const rb = SIZE_RANK[b] || 2;
      baseRace = (ra >= rb) ? a : b;
    }
    return { title:"Height", hint:`Spin height (${baseRace||"â€”"})`, items:heightWheelForRace(baseRace||"Human") };
  }

  if(phase === "strength") return { title:"Strength", hint:"Spin strength", items:[...STRENGTH_WORDS] };
  if(phase === "durability") return { title:"Durability", hint:"Spin durability", items:[...DURABILITY_WORDS] };
  if(phase === "speed") return { title:"Speed", hint:"Spin speed", items:[...SPEED_WORDS] };
  if(phase === "iq") return { title:"IQ", hint:"Spin IQ", items:[...IQ_WORDS] };
  if(phase === "fight") return { title:"Fight", hint:"Spin fight", items:[...FIGHT_WORDS] };

  if(phase === "power") return { title:"Power", hint:"Spin power (additive owned)", items:[...POWERS] };

  if(phase === "powerSpecial"){
    if((c.powers||[]).includes("Super saiyen")){
      return { title:"Super Saiyen Form", hint:"Spin SSJ form", items:[...SUPER_SAIYEN_FORMS] };
    }
    return null;
  }

  if(phase === "weapon") return { title:"Weapon", hint:"Spin weapon (additive owned)", items:[...WEAPONS] };
  if(phase === "trainer") return { title:"Trainer", hint:"Spin trainer", items:[...TRAINERS] };
  if(phase === "powerMastery") return { title:"Power Mastery", hint:"Spin power mastery", items:[...POWER_MASTERY] };
  if(phase === "weaponMastery") return { title:"Weapon Mastery", hint:"Spin weapon mastery", items:[...WEAPON_MASTERY] };

  if(phase === "fusion"){
    // Always allow a fusion spin (optional but included); keep it interesting
    return { title:"Fusion", hint:"Spin a fusion (additive)", items:FUSIONS.map(f=>`${f.name} (T${f.tier})`) };
  }

  if(phase === "curse"){
    // curse wheel: sometimes "No Curse" too
    const CURSE_WHEEL = [
      "No Curse",
      "Weakening Curse","Sluggish Curse","Fracture Curse","Fog Curse","Misfortune Curse",
      "Cursed Mark","Soul Leak","Chaotic Aura"
    ];
    return { title:"Curse", hint:"Spin a curse (can hurt)", items:CURSE_WHEEL };
  }

  return null;
}

function skipToNextWheel(c){
  // Walk forward until we find an applicable wheel (or complete)
  let n = c.phase || 1;
  while(n <= PHASES.length){
    const ph = PHASES[n-1];
    if(ph === "complete"){
      c.buildComplete = true;
      Sound.win();
      toast("Build complete!");
      logBuild("âœ… Build complete.");
      saveNow();
      refreshUI();
      return;
    }
    const wf = wheelForPhase(c, ph);
    if(wf){
      setPhase(c, n);
      setWheel(wf.items, wf.title, wf.hint);
      return;
    }
    n++;
    c.phase = n;
  }
}

function applyWheelResult(c, phase, result){
  const ph = phaseName(phase);

  if(ph === "race"){
    c.race = result;
    logBuild(`Race â†’ ${result}`);
    // reset raceSpecial fields for consistency
    c.raceDetail = null;
    c.raceDetail2 = null;
    c.raceDetail3 = null;
    c.hybridRaces = [];
    return;
  }

  if(ph === "raceSpecial"){
    if(c.race === "Hybrid" && (c.hybridRaces||[]).length < 2){
      // no duplicates
      if((c.hybridRaces||[]).includes(result)){
        Sound.warn();
        toast("No duplicates. Spin again.");
        return {stay:true};
      }
      c.hybridRaces.push(result);
      logBuild(`Hybrid race ${c.hybridRaces.length}/2 â†’ ${result}`);
      return;
    }

    if(c.race === "God"){
      c.raceDetail = result;
      logBuild(`God tier â†’ ${result}`);
      return;
    }
    if(c.race === "Demon"){
      c.raceDetail = result;
      logBuild(`Demon rank â†’ ${result}`);
      return;
    }
    if(c.race === "Alien"){
      if(!c.raceDetail){
        c.raceDetail = result; // Kaiju / Non-Kaiju
        logBuild(`Alien type â†’ ${result}`);
        return;
      }
      if(c.raceDetail === "Kaiju" && !c.raceDetail2){
        c.raceDetail2 = result; // kaiju name
        logBuild(`Kaiju â†’ ${result}`);
        return;
      }
      if(c.raceDetail === "Kaiju" && c.raceDetail2 === "Kaiju No 8" && !c.raceDetail3){
        c.raceDetail3 = result;
        logBuild(`Kaiju No 8 level â†’ ${result}`);
        return;
      }
    }
    return;
  }

  if(ph === "height"){ c.height = result; logBuild(`Height â†’ ${result}`); return; }
  if(ph === "strength"){ c.strengthW = result; logBuild(`Strength â†’ ${result}`); return; }
  if(ph === "durability"){ c.durabilityW = result; logBuild(`Durability â†’ ${result}`); return; }
  if(ph === "speed"){ c.speedW = result; logBuild(`Speed â†’ ${result}`); return; }
  if(ph === "iq"){ c.iqW = result; logBuild(`IQ â†’ ${result}`); return; }
  if(ph === "fight"){ c.fightW = result; logBuild(`Fight â†’ ${result}`); return; }

  if(ph === "power"){
    if(result !== "No Power") uniqPush(c.powers, result);
    logBuild(`Power â†’ ${result}`);
    return;
  }
  if(ph === "powerSpecial"){
    c.powerDetail = result;
    logBuild(`SSJ form â†’ ${result}`);
    return;
  }
  if(ph === "weapon"){
    if(result !== "No Weapon") uniqPush(c.weapons, result);
    logBuild(`Weapon â†’ ${result}`);
    return;
  }
  if(ph === "trainer"){
    c.trainer = result;
    logBuild(`Trainer â†’ ${result}`);
    return;
  }
  if(ph === "powerMastery"){
    c.powerMastery = result;
    logBuild(`Power mastery â†’ ${result}`);
    return;
  }
  if(ph === "weaponMastery"){
    c.weaponMastery = result;
    logBuild(`Weapon mastery â†’ ${result}`);
    return;
  }
  if(ph === "fusion"){
    // parse chosen fusion
    const name = String(result).replace(/\s*\(T\d+\)\s*$/,"");
    const fusion = FUSIONS.find(f=>f.name===name);
    if(fusion){
      // limit duplicates
      if(!(c.fusions||[]).some(x=>x.name===fusion.name)){
        c.fusions.push({ name:fusion.name, tier:fusion.tier, mods:fusion.mods });
        logBuild(`Fusion gained â†’ ${fusion.name} (T${fusion.tier})`);
      }else{
        logBuild(`Fusion repeat â†’ ${fusion.name} (ignored)`);
      }
    }else{
      logBuild(`Fusion â†’ ${result}`);
    }
    return;
  }
  if(ph === "curse"){
    if(result === "No Curse"){
      logBuild("Curse â†’ None");
      return;
    }
    const curse = makeCurse(result);
    c.curses ||= [];
    c.curses.push(curse);
    state.progress.curseCount += 1;
    logBuild(`Curse â†’ ${curse.name}`);
    toast(`Cursed: ${curse.name}`);
    Sound.warn();
    return;
  }
}

/* =========================================================
   CURSES
========================================================= */
function makeCurse(type){
  // all curses are additive debuffs + stability penalty
  switch(type){
    case "Weakening Curse": return { name:type, mods:{ strength:-2 }, stability:-1 };
    case "Sluggish Curse": return { name:type, mods:{ speed:-2 }, stability:-1 };
    case "Fracture Curse": return { name:type, mods:{ durability:-2 }, stability:-1 };
    case "Fog Curse": return { name:type, mods:{ iq:-2 }, stability:-1 };
    case "Misfortune Curse": return { name:type, mods:{ fight:-2 }, stability:-1 };
    case "Cursed Mark": return { name:type, mods:{ strength:-1, fight:-1 }, stability:-2 };
    case "Soul Leak": return { name:type, mods:{ durability:-1, speed:-1 }, stability:-2 };
    case "Chaotic Aura": return { name:type, mods:{ strength:-1, durability:-1, speed:-1, iq:-1, fight:-1 }, stability:-3 };
    default: return { name:type, mods:{ fight:-1 }, stability:-1 };
  }
}

/* =========================================================
   FINAL STATS â€” additive, includes progress, fusions, curses, stability flags
========================================================= */
function computeFinalStatsForChar(c){
  const base = {
    strength: statWordToNumber("strength", c.strengthW || "Average"),
    durability: statWordToNumber("durability", c.durabilityW || "Average"),
    speed: statWordToNumber("speed", c.speedW || "Average"),
    iq: statWordToNumber("iq", c.iqW || "Average"),
    fight: statWordToNumber("fight", c.fightW || "Average")
  };

  const add = { strength:0, durability:0, speed:0, iq:0, fight:0 };
  let immortal=false, regen=false;

  (c.powers||[]).forEach(p=>{
    const pm = powerMods(p);
    for(const k in pm){
      if(typeof pm[k] === "number" && k in add) add[k] += pm[k];
    }
    if(pm.immortal) immortal=true;
    if(pm.regen) regen=true;
  });

  if((c.powers||[]).includes("Super saiyen") && c.powerDetail){
    const fm = ssjFormMods(c.powerDetail);
    for(const k in fm){ if(k in add) add[k] += fm[k]; }
  }

  (c.weapons||[]).forEach(w=>{
    const wm = weaponMods(w);
    for(const k in wm){ if(typeof wm[k] === "number" && k in add) add[k] += wm[k]; }
  });

  const tm = trainerMods(c.trainer || "No Trainer");
  for(const k in tm){ if(typeof tm[k] === "number" && k in add) add[k] += tm[k]; }

  const mm = masteryMods(c.powerMastery || "None");
  for(const k in mm){ if(typeof mm[k] === "number" && k in add) add[k] += mm[k]; }

  const wmm = weaponMasteryMods(c.weaponMastery || "Novice");
  for(const k in wmm){ if(typeof wmm[k] === "number" && k in add) add[k] += wmm[k]; }

  // permanent progress bonuses (souls/adaptation)
  const pb = state.progress?.soulBonus || {};
  for(const k in add){ add[k] += (pb[k] || 0); }
  if(typeof state.progress?.adaptationStacks === "number" && (c.powers||[]).includes("Adaptation")){
    add.durability += state.progress.adaptationStacks;
  }

  // fusions
  (c.fusions||[]).forEach(f=>{
    const fm = fusionMods(f);
    for(const k in add){ add[k] += (fm[k] || 0); }
  });

  // curses
  (c.curses||[]).forEach(cur=>{
    const m = cur?.mods || {};
    for(const k in add){ add[k] += (m[k] || 0); }
  });

  const total = {
    strength: base.strength + add.strength,
    durability: base.durability + add.durability,
    speed: base.speed + add.speed,
    iq: base.iq + add.iq,
    fight: base.fight + add.fight
  };

  const stability = computeStability(c);

  return {
    base, add, total,
    labels:{
      strength: labelForStat("strength", total.strength),
      durability: labelForStat("durability", total.durability),
      speed: labelForStat("speed", total.speed),
      iq: labelForStat("iq", total.iq),
      fight: labelForStat("fight", total.fight)
    },
    stability,
    immortal, regen
  };
}

/* =========================================================
   PORTRAIT PLACEHOLDER (SVG, no external images)
========================================================= */
function svgDataURI(svg){ return "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svg); }
function displayRacePretty(c){
  if(!c) return "â€”";
  if(c.race !== "Hybrid") return c.race || "â€”";
  const a = c.hybridRaces?.[0] || "â€”";
  const b = c.hybridRaces?.[1] || "â€”";
  return `Hybrid (${a} + ${b})`;
}
function setPortrait(c){
  const img = $("portraitImg"); if(!img) return;
  const name = (c?.name || "Unknown").slice(0,12);
  const race = displayRacePretty(c);
  const alive = (c?.alive !== false);
  const fin = c ? computeFinalStatsForChar(c) : null;

  const tint = alive ? "#1b2a45" : "#401010";
  const tint2 = alive ? "#0b0f17" : "#120606";
  const badge = !alive ? "DEAD" : (c?.buildComplete ? "COMPLETE" : "BUILDING");
  const stab = fin ? fin.stability : 0;
  const stabText = fin ? `Stability: ${stab}` : "";

  const svg = `
  <svg xmlns="http://www.w3.org/2000/svg" width="600" height="600">
    <defs>
      <linearGradient id="g" x1="0" y1="0" x2="1" y2="1">
        <stop offset="0" stop-color="${tint}"/>
        <stop offset="1" stop-color="${tint2}"/>
      </linearGradient>
    </defs>
    <rect width="600" height="600" fill="url(#g)"/>
    <circle cx="300" cy="250" r="120" fill="rgba(122,168,255,.18)" stroke="rgba(255,255,255,.12)" stroke-width="6"/>
    <text x="300" y="268" text-anchor="middle" font-size="46" fill="rgba(232,238,252,.92)" font-family="system-ui" font-weight="900">${escapeHtml(name)}</text>
    <text x="300" y="328" text-anchor="middle" font-size="26" fill="rgba(232,238,252,.65)" font-family="system-ui" font-weight="800">${escapeHtml(race)}</text>

    <text x="300" y="420" text-anchor="middle" font-size="18" fill="rgba(232,238,252,.50)" font-family="system-ui" font-weight="800">${escapeHtml(badge)}</text>
    <text x="300" y="452" text-anchor="middle" font-size="14" fill="rgba(232,238,252,.45)" font-family="system-ui" font-weight="700">${escapeHtml(stabText)}</text>

    <rect x="24" y="24" width="160" height="36" rx="18" fill="rgba(0,0,0,.25)" stroke="rgba(255,255,255,.10)"/>
    <text x="104" y="49" text-anchor="middle" font-size="16" fill="rgba(232,238,252,.85)" font-family="system-ui" font-weight="900">${escapeHtml(c?.raceDetail ? c.raceDetail : "â€”")}</text>

    <rect x="416" y="24" width="160" height="36" rx="18" fill="rgba(0,0,0,.25)" stroke="rgba(255,255,255,.10)"/>
    <text x="496" y="49" text-anchor="middle" font-size="16" fill="rgba(232,238,252,.85)" font-family="system-ui" font-weight="900">${escapeHtml(c?.height || "â€”")}</text>

    <text x="300" y="560" text-anchor="middle" font-size="14" fill="rgba(232,238,252,.38)" font-family="system-ui" font-weight="700">Portrait placeholder (images can be added later)</text>
  </svg>`;
  img.src = svgDataURI(svg);
}

/* =========================================================
   UI â€” Tabs + gating
========================================================= */
function setTab(key){
  document.querySelectorAll(".tab").forEach(t=>{
    t.classList.toggle("active", t.dataset.tab===key);
  });
  ["build","stats","pve","roster","progress"].forEach(k=>{
    const el = $("tab-"+k);
    if(el) el.style.display = (k===key) ? "" : "none";
  });
}
document.querySelectorAll(".tab").forEach(btn=>{
  btn.addEventListener("click", (e)=>{
    const key = btn.dataset.tab;
    const locked = btn.classList.contains("locked");
    if(locked){
      Sound.warn();
      toast("Locked until Build Complete.");
      e.preventDefault();
      return;
    }
    Sound.click();
    setTab(key);
  });
});

function gateTabs(){
  const c = getActiveChar();
  const ok = !!(c && c.buildComplete && c.alive !== false);
  const lock = (tabKey, enabled)=>{
    const el = document.querySelector(`.tab[data-tab="${tabKey}"]`);
    if(!el) return;
    el.classList.toggle("locked", !enabled);
  };
  lock("stats", ok);
  lock("pve", ok);
}

/* =========================================================
   RENDER â€” Build panel + Stats tab + Roster + Progress
========================================================= */
function renderBuildPanel(){
  const c = getActiveChar(); if(!c) return;

  $("namedTag").innerHTML = `<strong>${escapeHtml(c.nameLocked && c.name ? c.name : "Tap Name")}</strong>`;
  $("charTag").innerHTML = `<strong>Char:</strong> ${state.activeIndex+1}/${state.roster.length}`;

  // badges
  const b = $("buildBadges");
  b.innerHTML = "";
  const mk = (icon, text)=>`<div class="badge"><span>${icon}</span><span>${escapeHtml(text)}</span></div>`;
  b.innerHTML += mk(c.buildComplete ? "âœ…" : "ðŸ§ª", c.buildComplete ? "Build Complete" : "Building");
  b.innerHTML += mk(c.alive===false ? "â˜ ï¸" : "ðŸ§", `Alive: ${c.alive===false ? "No" : "Yes"}`);
  b.innerHTML += mk("ðŸ§¬", `Fusions: ${(c.fusions||[]).length}`);
  b.innerHTML += mk("ðŸŒ€", `Curses: ${(c.curses||[]).length}`);

  // summary
  const host = $("buildStats");
  host.innerHTML = "";
  const rows = [];
  rows.push(["Race", displayRacePretty(c)]);
  if(c.race==="God") rows.push(["God Tier", c.raceDetail || "â€”"]);
  if(c.race==="Demon") rows.push(["Demon Rank", c.raceDetail || "â€”"]);
  if(c.race==="Alien"){
    rows.push(["Alien Type", c.raceDetail || "â€”"]);
    if(c.raceDetail === "Kaiju") rows.push(["Kaiju", c.raceDetail2 || "â€”"]);
    if(c.raceDetail2 === "Kaiju No 8") rows.push(["No 8 Level", c.raceDetail3 || "â€”"]);
  }
  rows.push(["Height", c.height || "â€”"]);
  rows.push(["Strength", c.strengthW || "â€”"]);
  rows.push(["Durability", c.durabilityW || "â€”"]);
  rows.push(["Speed", c.speedW || "â€”"]);
  rows.push(["IQ", c.iqW || "â€”"]);
  rows.push(["Fight", c.fightW || "â€”"]);
  rows.push(["Power(s)", (c.powers||[]).length ? c.powers.join(", ") : "â€”"]);
  if(c.powerDetail) rows.push(["Power Detail", c.powerDetail]);
  rows.push(["Weapon(s)", (c.weapons||[]).length ? c.weapons.join(", ") : "â€”"]);
  rows.push(["Trainer", c.trainer || "â€”"]);
  rows.push(["Power Mastery", c.powerMastery || "â€”"]);
  rows.push(["Weapon Mastery", c.weaponMastery || "â€”"]);
  rows.push(["Fusions", (c.fusions||[]).length ? `${c.fusions.length} owned` : "â€”"]);
  rows.push(["Curses", (c.curses||[]).length ? `${c.curses.length} active` : "â€”"]);

  rows.forEach(([k,v])=>{
    const d=document.createElement("div");
    d.className="statLine";
    d.innerHTML=`<div class="statKey">${escapeHtml(k)}</div><div class="statVal">${escapeHtml(v)}</div>`;
    host.appendChild(d);
  });

  // set portrait
  setPortrait(c);
}

function renderStatsTab(){
  const c = getActiveChar(); if(!c) return;

  const rawHost = $("statsList");
  const finHost = $("finalStatsList");
  rawHost.innerHTML = "";
  finHost.innerHTML = "";

  const raw = [];
  raw.push(["Name", c.name || "â€”"]);
  raw.push(["Race", displayRacePretty(c)]);
  if(c.race==="God") raw.push(["God Tier", c.raceDetail || "â€”"]);
  if(c.race==="Demon") raw.push(["Demon Rank", c.raceDetail || "â€”"]);
  if(c.race==="Alien"){
    raw.push(["Alien Type", c.raceDetail || "â€”"]);
    if(c.raceDetail === "Kaiju") raw.push(["Kaiju", c.raceDetail2 || "â€”"]);
    if(c.raceDetail2 === "Kaiju No 8") raw.push(["No 8 Level", c.raceDetail3 || "â€”"]);
  }
  raw.push(["Height", c.height || "â€”"]);
  raw.push(["Strength (wheel)", c.strengthW || "â€”"]);
  raw.push(["Durability (wheel)", c.durabilityW || "â€”"]);
  raw.push(["Speed (wheel)", c.speedW || "â€”"]);
  raw.push(["IQ (wheel)", c.iqW || "â€”"]);
  raw.push(["Fight (wheel)", c.fightW || "â€”"]);
  raw.push(["Powers Owned", (c.powers||[]).length ? c.powers.join(", ") : "â€”"]);
  raw.push(["Weapons Owned", (c.weapons||[]).length ? c.weapons.join(", ") : "â€”"]);
  raw.push(["Trainer", c.trainer || "â€”"]);
  raw.push(["Power Mastery", c.powerMastery || "â€”"]);
  raw.push(["Weapon Mastery", c.weaponMastery || "â€”"]);
  raw.push(["Fusions Owned", String((c.fusions||[]).length)]);
  raw.push(["Curses Active", String((c.curses||[]).length)]);
  raw.forEach(([k,v])=>{
    const d=document.createElement("div");
    d.className="statLine";
    d.innerHTML=`<div class="statKey">${escapeHtml(k)}</div><div class="statVal">${escapeHtml(v)}</div>`;
    rawHost.appendChild(d);
  });

  const fin = computeFinalStatsForChar(c);
  const finalRows = [
    ["Strength", `${fin.labels.strength} (${fin.total.strength})`],
    ["Durability", `${fin.labels.durability} (${fin.total.durability})`],
    ["Speed", `${fin.labels.speed} (${fin.total.speed})`],
    ["IQ", `${fin.labels.iq} (${fin.total.iq})`],
    ["Fight", `${fin.labels.fight} (${fin.total.fight})`],
    ["Stability", String(fin.stability)],
    ["Immortal", fin.immortal ? "Yes" : "No"],
    ["Regeneration", fin.regen ? "Yes" : "No"],
    ["Unstable", isUnstable(c) ? "âš  Yes" : "No"]
  ];
  finalRows.forEach(([k,v])=>{
    const d=document.createElement("div");
    d.className="statLine";
    d.innerHTML=`<div class="statKey">${escapeHtml(k)}</div><div class="statVal">${escapeHtml(v)}</div>`;
    finHost.appendChild(d);
  });
}

function renderRoster(){
  const host = $("rosterList");
  host.innerHTML = "";
  state.roster.forEach((c,i)=>{
    const fin = c.buildComplete ? computeFinalStatsForChar(c) : null;
    const line = document.createElement("div");
    line.className="statLine";
    const tag = (c.alive===false) ? "â˜ ï¸" : (c.buildComplete ? "âœ…" : "ðŸ§ª");
    const name = c.nameLocked && c.name ? c.name : `Unnamed #${i+1}`;
    const sub = c.buildComplete ? `${fin.labels.strength}/${fin.labels.speed}/${fin.labels.fight}` : "building...";
    line.innerHTML = `
      <div class="statKey">${tag} ${escapeHtml(name)}</div>
      <div class="statVal">${escapeHtml(sub)}</div>`;
    line.style.cursor="pointer";
    line.addEventListener("click", ()=>{
      Sound.click();
      state.activeIndex = i;
      saveNow();
      refreshUI();
      toast(`Switched to ${name}`);
    });
    host.appendChild(line);
  });
}

function renderProgress(){
  const p = state.progress || {};
  const host = $("progressList");
  host.innerHTML = "";

  const rows = [];
  rows.push(["Coins", String(p.coins||0)]);
  rows.push(["XP", String(p.xp||0)]);
  rows.push(["Souls", String(p.souls||0)]);
  rows.push(["Events Cleared", String(p.eventsCleared||0)]);
  rows.push(["World Bosses Defeated", String(p.bossesDefeated||0)]);
  rows.push(["Apex Defeated", String(p.apexDefeated||0)]);
  rows.push(["Curses Taken", String(p.curseCount||0)]);
  rows.push(["Permanent Bonus", `STR+${p.soulBonus?.strength||0} DUR+${p.soulBonus?.durability||0} SPD+${p.soulBonus?.speed||0} IQ+${p.soulBonus?.iq||0} FGT+${p.soulBonus?.fight||0}`]);
  rows.push(["Adaptation Stacks", String(p.adaptationStacks||0)]);

  rows.forEach(([k,v])=>{
    const d=document.createElement("div");
    d.className="statLine";
    d.innerHTML=`<div class="statKey">${escapeHtml(k)}</div><div class="statVal">${escapeHtml(v)}</div>`;
    host.appendChild(d);
  });
}

/* =========================================================
   PvE ENGINE â€” normal/events/world boss/apex + flee chance by speed
   - PvE: 1 strike = death (unless regen/immortal protects)
========================================================= */
let activeBattle = null;

function computeHP(fin){
  return Math.floor(60 + fin.total.durability * 9 + fin.total.fight * 4 + fin.total.iq * 1.5);
}
function computeDamage(att, def){
  const atk = att.total.strength * 3 + att.total.fight * 4 + att.total.speed * 1.2;
  const mit = def.total.durability * 3 + def.total.fight * 1.5;
  const raw = Math.max(8, atk - mit*0.65);
  const variance = 0.85 + Math.random()*0.25;
  return Math.max(6, Math.floor(raw * variance));
}
function hasDeathProtection(c){
  const fin = computeFinalStatsForChar(c);
  return fin.immortal || fin.regen;
}
function fleeChance(playerSpeed, enemySpeed){
  // close speeds => decent chance, big gap => low chance
  const d = playerSpeed - enemySpeed;
  // sigmoid-ish
  const x = d / 6;
  const chance = 1 / (1 + Math.exp(-x));
  // clamp to 5%..90%
  return Math.max(0.05, Math.min(0.90, chance));
}

function genEnemyFromPlayer(fin, kind){
  // kind: "normal" | "event" | "boss" | "apex"
  let mult = 1.0;
  let bonus = 0;
  let name = "Enemy";
  if(kind==="event"){ mult=1.05; bonus=2; name="Event Enemy"; }
  if(kind==="boss"){ mult=1.18; bonus=5; name="World Boss"; }
  if(kind==="apex"){ mult=1.30; bonus=8; name="Apex"; }

  // enemy rolls around player
  const e = {
    total:{
      strength: Math.max(1, Math.floor(fin.total.strength*mult) + randInt(0,bonus)),
      durability: Math.max(1, Math.floor(fin.total.durability*mult) + randInt(0,bonus)),
      speed: Math.max(1, Math.floor(fin.total.speed*mult) + randInt(0,bonus)),
      iq: Math.max(1, Math.floor(fin.total.iq*mult) + randInt(0,bonus)),
      fight: Math.max(1, Math.floor(fin.total.fight*mult) + randInt(0,bonus))
    },
    labels:{
      strength: labelForStat("strength", Math.floor(fin.total.strength*mult)),
      durability: labelForStat("durability", Math.floor(fin.total.durability*mult)),
      speed: labelForStat("speed", Math.floor(fin.total.speed*mult)),
      iq: labelForStat("iq", Math.floor(fin.total.iq*mult)),
      fight: labelForStat("fight", Math.floor(fin.total.fight*mult))
    },
    name
  };
  return e;
}

function setBars(pHP,pMax,eHP,eMax){
  $("pvePlayerHP").textContent = `${pHP}/${pMax}`;
  $("pveEnemyHP").textContent = `${eHP}/${eMax}`;
  $("pvePBar").style.width = `${clamp01(pHP/pMax)*100}%`;
  $("pveEBar").style.width = `${clamp01(eHP/eMax)*100}%`;
}

async function startBattle(kind){
  const c = getActiveChar();
  if(!c || !c.buildComplete || c.alive===false){
    Sound.warn();
    toast("PvE locked.");
    return;
  }

  const fin = computeFinalStatsForChar(c);
  const enemy = genEnemyFromPlayer(fin, kind);

  let pHP = computeHP(fin);
  let eHP = Math.floor(computeHP({ total: enemy.total }) * (kind==="boss" ? 1.25 : kind==="apex" ? 1.45 : 1.0));
  let pMax = pHP, eMax = eHP;

  activeBattle = { kind, enemy, pHP, eHP, pMax, eMax, playerFin: fin };
  $("pveEncounter").textContent = `${enemy.name} â€¢ ${enemy.labels.strength}/${enemy.labels.speed}/${enemy.labels.fight}`;
  $("pveLog").innerHTML = "";
  logPVE(`Battle started vs ${enemy.name}.`);
  Sound.spin();

  setBars(pHP,pMax,eHP,eMax);

  // turn loop
  for(let turn=1; turn<=80; turn++){
    if(!activeBattle) return; // fled or ended

    await new Promise(r=>setTimeout(r, 80));

    const p = activeBattle.playerFin;
    const e = activeBattle.enemy;

    // who goes first based on speed (plus small RNG)
    const pFirst = (p.total.speed + Math.random()*3) >= (e.total.speed + Math.random()*3);

    const hit = (att, def, who)=>{
      const dmg = computeDamage(att, def);
      if(who==="enemy"){
        activeBattle.eHP -= dmg;
        logPVE(`You hit for ${dmg}.`);
      }else{
        activeBattle.pHP -= dmg;
        logPVE(`${e.name} hit for ${dmg}.`);
      }
      setBars(activeBattle.pHP, activeBattle.pMax, activeBattle.eHP, activeBattle.eMax);
    };

    if(pFirst){
      hit(p, {total:e.total}, "enemy");
      if(activeBattle.eHP > 0) hit({total:e.total}, p, "player");
    }else{
      hit({total:e.total}, p, "player");
      if(activeBattle.pHP > 0) hit(p, {total:e.total}, "enemy");
    }

    if(activeBattle.eHP <= 0 || activeBattle.pHP <= 0) break;
  }

  // end
  if(!activeBattle) return;

  if(activeBattle.pHP > 0 && activeBattle.eHP <= 0){
    Sound.win();
    logPVE("Victory!");
    rewardFor(kind);
    activeBattle = null;
    refreshUI();
    return;
  }

  // player lost
  if(hasDeathProtection(c)){
    Sound.warn();
    toast("You survived due to regeneration/immortality.");
    logPVE("Saved by regeneration/immortality.");
    activeBattle = null;
    refreshUI();
    return;
  }

  // PvE strike rule: 1 strike = death
  c.pveStrikes = (c.pveStrikes||0) + 1;
  if(c.pveStrikes >= 1){
    c.alive = false;
    c.deaths = (c.deaths||0) + 1;
    Sound.block();
    toast(`${c.name || "Character"} has died.`);
    logPVE("â˜ ï¸ Permadeath.");
  }
  activeBattle = null;
  saveNow();
  refreshUI();
}

function rewardFor(kind){
  const p = state.progress;
  let coins=12, xp=8;
  if(kind==="event"){ coins=18; xp=12; p.eventsCleared++; }
  if(kind==="boss"){ coins=40; xp=28; p.bossesDefeated++; }
  if(kind==="apex"){ coins=70; xp=52; p.apexDefeated++; }
  p.coins += coins;
  p.xp += xp;

  // Adaptation stacks: on any win, if you own Adaptation, gain stack sometimes
  const c = getActiveChar();
  if((c.powers||[]).includes("Adaptation")){
    if(Math.random() < 0.55){
      p.adaptationStacks += 1;
      logPVE("Adaptation stack gained (+1 durability future).");
    }
  }

  toast(`Rewards: +${coins} coins, +${xp} xp`);
  logPVE(`Rewards: +${coins} coins, +${xp} xp`);
  saveNow();
}

$("pveStartBtn").addEventListener("click", ()=>{ Sound.click(); startBattle("normal"); });
$("eventBtn").addEventListener("click", ()=>{ Sound.click(); startBattle("event"); });
$("worldBossBtn").addEventListener("click", ()=>{ Sound.click(); startBattle("boss"); });
$("apexBtn").addEventListener("click", ()=>{ Sound.click(); startBattle("apex"); });

$("pveFleeBtn").addEventListener("click", ()=>{
  Sound.click();
  if(!activeBattle){
    toast("No battle to flee.");
    return;
  }
  const pSpeed = activeBattle.playerFin.total.speed;
  const eSpeed = activeBattle.enemy.total.speed;
  const ch = fleeChance(pSpeed, eSpeed);
  const roll = Math.random();
  logPVE(`Flee attempt: ${(ch*100).toFixed(0)}% (roll ${(roll*100).toFixed(0)}%)`);
  if(roll < ch){
    Sound.win();
    toast("You fled!");
    logPVE("âœ… You fled.");
    activeBattle = null;
    refreshUI();
  }else{
    Sound.warn();
    toast("Flee failed!");
    logPVE("âŒ Flee failed.");
  }
});

/* =========================================================
   EVENTS â€” can grant fusion, curse, coins, or a power/weapon drop
========================================================= */
function triggerEvent(){
  const c = getActiveChar();
  if(!c || c.alive===false){ Sound.warn(); toast("No active living character."); return; }
  const roll = Math.random();

  if(roll < 0.22){
    // fusion drop
    const f = pick(FUSIONS);
    if(!(c.fusions||[]).some(x=>x.name===f.name)){
      c.fusions.push({name:f.name, tier:f.tier, mods:f.mods});
      logBuild(`ðŸŽ Event: Fusion gained â†’ ${f.name} (T${f.tier})`);
      toast("Event: Fusion gained!");
      Sound.win();
    }else{
      logBuild("ðŸŽ Event: Fusion repeat (ignored).");
      Sound.warn();
    }
  }else if(roll < 0.44){
    // curse
    const curseName = pick(["Weakening Curse","Sluggish Curse","Fracture Curse","Fog Curse","Misfortune Curse","Cursed Mark","Soul Leak","Chaotic Aura"]);
    const curse = makeCurse(curseName);
    c.curses ||= [];
    c.curses.push(curse);
    state.progress.curseCount++;
    logBuild(`ðŸ§¿ Event: Curse â†’ ${curse.name}`);
    toast("Event: You were cursed.");
    Sound.warn();
  }else if(roll < 0.70){
    // coins/xp
    const coins = randInt(10,35);
    const xp = randInt(6,22);
    state.progress.coins += coins;
    state.progress.xp += xp;
    logBuild(`ðŸ’° Event reward â†’ +${coins} coins, +${xp} xp`);
    toast("Event: Rewards gained!");
    Sound.win();
  }else if(roll < 0.86){
    // power drop (additive)
    const p = pick(POWERS.filter(x=>x!=="No Power"));
    uniqPush(c.powers, p);
    logBuild(`âœ¨ Event: Power gained â†’ ${p}`);
    toast("Event: Power gained!");
    Sound.win();
  }else{
    // weapon drop
    const w = pick(WEAPONS.filter(x=>x!=="No Weapon"));
    uniqPush(c.weapons, w);
    logBuild(`ðŸ—¡ï¸ Event: Weapon gained â†’ ${w}`);
    toast("Event: Weapon gained!");
    Sound.win();
  }

  state.progress.eventsCleared++;
  saveNow();
  refreshUI();
}
$("eventBtn").addEventListener("contextmenu", (e)=>{ e.preventDefault(); });
$("eventBtn").addEventListener("dblclick", ()=>{ Sound.click(); triggerEvent(); });
$("eventBtn").addEventListener("click", (e)=>{
  // single click already starts event battle; long-press/double-click triggers "event loot"
  // keep as-is: button = event battle (above).
});

/* Add a separate trigger button behavior (single click) */
$("eventBtn").addEventListener("auxclick", ()=>{});
/* Provide "Trigger Event" via long press for mobile */
(function(){
  const btn = $("eventBtn");
  let t=null;
  btn.addEventListener("touchstart", ()=>{
    t=setTimeout(()=>{ Sound.click(); triggerEvent(); }, 550);
  }, {passive:true});
  btn.addEventListener("touchend", ()=>{ clearTimeout(t); }, {passive:true});
})();

/* =========================================================
   SACRIFICE â€” convert a character into permanent bonuses
   - Only allowed if character exists (alive or dead), but cannot sacrifice the last character.
========================================================= */
function sacrificeActive(){
  if(state.roster.length <= 1){
    Sound.warn();
    toast("You need at least 2 characters.");
    return;
  }
  const c = getActiveChar();
  if(!c){ return; }

  // value based on build completion + stats
  let souls = 5;
  if(c.buildComplete){
    const fin = computeFinalStatsForChar(c);
    const power = fin.total.strength + fin.total.durability + fin.total.speed + fin.total.iq + fin.total.fight;
    souls += Math.floor(power/20);
  }
  // bonus: fusions
  souls += (c.fusions||[]).length * 2;

  state.progress.souls += souls;

  // permanent stat bonus (small but real)
  const bonus = state.progress.soulBonus;
  bonus.strength += Math.floor(souls/8);
  bonus.durability += Math.floor(souls/8);
  bonus.speed += Math.floor(souls/10);
  bonus.iq += Math.floor(souls/12);
  bonus.fight += Math.floor(souls/9);

  logBuild(`ðŸ©¸ Sacrifice: gained ${souls} souls â†’ permanent bonuses increased.`);
  toast(`Sacrificed for ${souls} souls.`);
  Sound.block();

  // remove the character
  state.roster.splice(state.activeIndex, 1);
  state.activeIndex = Math.max(0, Math.min(state.activeIndex, state.roster.length-1));

  saveNow();
  refreshUI();
}
$("sacrificeBtn").addEventListener("click", ()=>{ Sound.click(); sacrificeActive(); });

/* =========================================================
   ROSTER CONTROLS
========================================================= */
$("newBuildBtn").addEventListener("click", ()=>{
  Sound.click();
  const c = newCharacter();
  state.roster.push(c);
  state.activeIndex = state.roster.length-1;
  // reset build log for new char
  $("buildLog").innerHTML = "";
  logBuild("New character created.");
  saveNow();
  refreshUI();
  openNameModal();
});
$("prevCharBtn").addEventListener("click", ()=>{
  Sound.click();
  state.activeIndex = (state.activeIndex - 1 + state.roster.length) % state.roster.length;
  saveNow(); refreshUI();
});
$("nextCharBtn").addEventListener("click", ()=>{
  Sound.click();
  state.activeIndex = (state.activeIndex + 1) % state.roster.length;
  saveNow(); refreshUI();
});
$("deleteDeadBtn").addEventListener("click", ()=>{
  Sound.click();
  const before = state.roster.length;
  state.roster = state.roster.filter(c=>c.alive !== false);
  if(!state.roster.length) state.roster.push(newCharacter());
  state.activeIndex = Math.max(0, Math.min(state.activeIndex, state.roster.length-1));
  saveNow(); refreshUI();
  toast(`Deleted ${before - state.roster.length} dead.`);
});

/* =========================================================
   WHEEL APPLY + AUTO ADVANCE + FINALIZE
========================================================= */
function tryFinalizeBuild(c){
  const required = [
    c.race, c.height,
    c.strengthW, c.durabilityW,
    c.speedW, c.iqW, c.fightW,
    c.trainer, c.powerMastery, c.weaponMastery
  ];
  if(required.every(v=>!!v)){
    c.buildComplete = true;
    Sound.win();
    toast("Build Complete. PvE Unlocked.");
    logBuild("âœ… Build complete â†’ PvE unlocked.");
    saveNow();
    refreshUI();
    return true;
  }
  return false;
}

function updateWheelFromPhase(){
  const c = getActiveChar();
  if(!c) return;

  // lock wheel if complete/dead
  if(c.buildComplete || c.alive===false){
    setWheel(["LOCKED"], c.alive===false ? "DEAD" : "Build Complete", "No more spinning");
    return;
  }

  // If phase out of bounds, reset
  if(!Number.isFinite(c.phase) || c.phase < 1 || c.phase > PHASES.length) c.phase = 1;

  // Special: raceSpecial can contain multiple sub-spins (alien and hybrid), so don't force phase++ until done.
  const ph = PHASES[c.phase-1];
  const wf = wheelForPhase(c, ph);

  // If wheel not needed, skip ahead
  if(!wf){
    c.phase += 1;
    return updateWheelFromPhase();
  }

  setPhase(c, c.phase);
  setWheel(wf.items, wf.title, wf.hint);
}

function advancePhaseAfterSpin(c){
  // If raceSpecial still has pending steps, keep phase
  const ph = PHASES[c.phase-1];

  if(ph === "raceSpecial"){
    // Hybrid pending
    if(c.race === "Hybrid" && (c.hybridRaces||[]).length < 2) return;
    // Alien pending (type then kaiju then no8)
    if(c.race === "Alien"){
      if(!c.raceDetail) return;
      if(c.raceDetail === "Kaiju" && !c.raceDetail2) return;
      if(c.raceDetail === "Kaiju" && c.raceDetail2 === "Kaiju No 8" && !c.raceDetail3) return;
    }
  }

  c.phase += 1;

  // If we passed last wheel, finalize
  if(c.phase >= PHASES.length){
    c.phase = PHASES.length;
    tryFinalizeBuild(c);
  }
}

$("spinBtn").addEventListener("click", ()=>{
  Sound.click();
  const c = getActiveChar();
  if(!c) return;

  updateWheelFromPhase();

  spinWheel((result)=>{
    const phase = c.phase;
    const out = applyWheelResult(c, phase, result);

    if(out?.stay){
      saveNow(); refreshUI();
      updateWheelFromPhase();
      return;
    }

    saveNow();

    // If we just wrote something, advance
    advancePhaseAfterSpin(c);

    // If we reached end, finalize if possible
    if(PHASES[c.phase-1] === "complete"){
      tryFinalizeBuild(c);
    }

    refreshUI();
    updateWheelFromPhase();
  });
});

/* =========================================================
   DEV RESET (hidden)
========================================================= */
(function(){
  const btn = $("resetBtn");
  btn.style.display = state.settings.devMode ? "" : "none";
  btn.addEventListener("click", ()=>{
    Sound.block();
    localStorage.removeItem(STORAGE_KEY);
    state = {
      settings:{ sound:true, devMode:false },
      progress:{
        coins:0,xp:0,souls:0,
        soulBonus:{strength:0,durability:0,speed:0,iq:0,fight:0},
        adaptationStacks:0, curseCount:0, bossesDefeated:0, apexDefeated:0, eventsCleared:0
      },
      roster:[newCharacter()],
      activeIndex:0
    };
    saveNow();
    location.reload();
  });
})();

/* =========================================================
   REFRESH UI (single source of truth)
========================================================= */
function refreshUI(){
  const c = getActiveChar();

  // gate tabs
  gateTabs();

  // lock pve buttons if not allowed
  const pveOk = !!(c && c.buildComplete && c.alive !== false);
  $("pveStartBtn").disabled = !pveOk;
  $("pveFleeBtn").disabled = !pveOk;
  $("worldBossBtn").disabled = !pveOk;
  $("apexBtn").disabled = !pveOk;

  renderBuildPanel();
  renderStatsTab();
  renderRoster();
  renderProgress();

  // phase + wheel
  if(c){
    $("phaseTag").innerHTML = `<strong>Phase:</strong> ${escapeHtml(PHASES[(c.phase||1)-1] || "â€”")}`;
    $("charTag").innerHTML = `<strong>Char:</strong> ${state.activeIndex+1}/${state.roster.length}`;
  }

  // update wheel view
  updateWheelFromPhase();

  saveNow();
}

/* =========================================================
   TAB DEFAULT + Boot
========================================================= */
function boot(){
  // default tab = build
  setTab("build");

  // ensure active char has phase
  const c = getActiveChar();
  if(c && (!Number.isFinite(c.phase) || c.phase < 1)) c.phase = 1;

  // if character already complete, keep it locked
  if(c && c.buildComplete){
    setWheel(["LOCKED"], "Build Complete", "No more spinning");
  }else{
    updateWheelFromPhase();
  }

  // if no name yet, encourage tapping
  if(c && (!c.nameLocked || !c.name)){
    $("namedTag").innerHTML = `<strong>Tap Name</strong>`;
  }

  drawWheel();
  refreshUI();
}
boot();
</script>
</body>
</html>
