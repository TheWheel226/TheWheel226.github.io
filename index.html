<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>WheelForge</title>
  <style>
    :root{
      --bg0:#0b0f16;
      --panel:rgba(255,255,255,.06);
      --panel2:rgba(255,255,255,.09);
      --stroke:rgba(255,255,255,.14);
      --txt:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.65);
      --good:rgba(180,255,220,.95);
      --bad:rgba(255,140,160,.95);
      --warn:rgba(255,210,120,.95);
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      color:var(--txt);
      background: var(--bg0);
      overflow-x:hidden;
    }

    /* dynamic background */
    .bg{
      position:fixed; inset:0;
      background:
        radial-gradient(1200px 700px at 50% -15%, rgba(120,160,255,.18), transparent 55%),
        radial-gradient(900px 600px at 110% 30%, rgba(255,120,180,.10), transparent 55%),
        radial-gradient(900px 600px at -10% 70%, rgba(140,255,210,.09), transparent 55%),
        linear-gradient(180deg, rgba(255,255,255,.03), transparent 35%, rgba(0,0,0,.35));
      filter:saturate(1.08) contrast(1.06);
      z-index:-3;
    }
    .bgImage{
      position:fixed; inset:0;
      background-position:center;
      background-size:cover;
      opacity:.28;
      filter: blur(1px) saturate(1.1) contrast(1.08);
      z-index:-4;
      transform: scale(1.02);
    }

    header{
      position:sticky; top:0;
      padding:10px 12px;
      background: rgba(0,0,0,.45);
      backdrop-filter: blur(10px);
      border-bottom:1px solid rgba(255,255,255,.08);
      z-index:20;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .brand{
      display:flex; align-items:center; gap:10px;
      font-weight:1000;
      letter-spacing:.4px;
    }
    .pill{
      padding:6px 10px;
      border-radius:999px;
      background:rgba(255,255,255,.07);
      border:1px solid rgba(255,255,255,.10);
      font-size:12px;
      color:var(--muted);
      white-space:nowrap;
    }
    .topBtns{display:flex; gap:8px; align-items:center;}
    .btn{
      padding:9px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
      color:var(--txt);
      font-weight:900;
      cursor:pointer;
      user-select:none;
    }
    .btn:active{transform:scale(.985)}
    .btn.primary{
      background:linear-gradient(135deg, rgba(120,200,255,.18), rgba(180,255,220,.14));
      border-color: rgba(180,255,220,.26);
    }
    .btn.danger{
      background:linear-gradient(135deg, rgba(255,120,140,.18), rgba(80,10,18,.16));
      border-color: rgba(255,120,140,.28);
    }
    .btn.small{padding:7px 10px; border-radius:10px; font-size:12px}
    .btn.secondary{opacity:.9}

    .tabs{
      display:flex;
      gap:8px;
      padding:10px 12px 0;
      flex-wrap:wrap;
    }
    .tab{
      padding:8px 12px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.05);
      font-weight:1000;
      font-size:12px;
      cursor:pointer;
      opacity:.85;
    }
    .tab.active{
      opacity:1;
      border-color: rgba(180,255,220,.28);
      background:rgba(180,255,220,.10);
    }

    .wrap{
      padding:12px;
      max-width:1100px;
      margin:0 auto;
    }

    .grid{
      display:grid;
      grid-template-columns: 330px 1fr;
      gap:12px;
    }
    @media (max-width: 920px){
      .grid{grid-template-columns:1fr}
    }

    .panel{
      background: var(--panel);
      border:1px solid var(--stroke);
      border-radius:18px;
      padding:12px;
      box-shadow: 0 0 24px rgba(0,0,0,.24);
    }
    .big{
      font-weight:1100;
      font-size:16px;
    }
    .muted{color:var(--muted)}
    .row{display:flex; align-items:center; justify-content:space-between; gap:10px}
    .col{display:flex; flex-direction:column; gap:8px}
    .sp{height:10px}
    .hr{height:1px; background:rgba(255,255,255,.10); margin:10px 0}

    /* Left stats list while building */
    .buildStats{
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .statLine{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:10px 12px;
      border-radius:14px;
      background: rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.09);
    }
    .statKey{font-weight:1000; font-size:12px; color:var(--muted)}
    .statVal{font-weight:1000; font-size:12px}
    .tag{
      font-weight:1000;
      font-size:11px;
      opacity:.9;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.18);
    }

    /* portrait */
    .charFrame{
      position:relative;
      width: 100%;
      max-width: 420px;
      aspect-ratio: 3/4;
      margin: 0 auto;
      border-radius: 18px;
      overflow:hidden;
      border:1px solid rgba(255,255,255,.14);
      background:
        radial-gradient(700px 500px at 50% 0%, rgba(255,255,255,.08), transparent 55%),
        rgba(0,0,0,.25);
    }
    .charLayer{
      position:absolute; inset:0;
      width:100%; height:100%;
      object-fit:contain;
      pointer-events:none;
    }
    .charFx{
      opacity:0;
      transition:opacity .2s ease;
      filter: drop-shadow(0 0 14px rgba(255,255,255,.10));
    }
    .charFx.on{opacity:1}

    @keyframes idleSway{
      0%{transform:translateY(0px) scale(1)}
      50%{transform:translateY(2px) scale(1.005)}
      100%{transform:translateY(0px) scale(1)}
    }
    @keyframes idleHeavy{
      0%{transform:translateY(0px) scale(1)}
      50%{transform:translateY(3px) scale(1.01)}
      100%{transform:translateY(0px) scale(1)}
    }
    .charFrame.idle-sway{animation: idleSway 2.4s ease-in-out infinite;}
    .charFrame.idle-heavy{animation: idleHeavy 2.0s ease-in-out infinite;}

    /* Big rigs zoom out a touch */
    .charFrame.bigRig .charLayer{
      transform: scale(0.90);
      transform-origin: 50% 55%;
    }

    /* wheel */
    .wheelWrap{
      display:flex;
      flex-direction:column;
      gap:10px;
      align-items:center;
    }
    canvas{max-width: 420px; width: 100%; height:auto;}
    .wheelTitle{
      font-weight:1100;
      text-align:center;
      font-size:14px;
      opacity:.95;
    }
    .wheelHint{
      text-align:center;
      color:var(--muted);
      font-size:12px;
      margin-top:-4px;
    }
    .pointer{
      width:0;height:0;
      border-left:12px solid transparent;
      border-right:12px solid transparent;
      border-bottom:18px solid rgba(255,255,255,.85);
      filter: drop-shadow(0 0 8px rgba(0,0,0,.6));
      margin-bottom:-6px;
    }

    /* trait slots */
    .slotGrid{
      display:grid;
      grid-template-columns: repeat(5, 1fr);
      gap:10px;
      margin-top:10px;
    }
    .slotCard{
      border-radius:14px;
      padding:10px;
      background: rgba(0,0,0,0.22);
      border: 1px solid rgba(255,255,255,0.14);
      cursor:pointer;
      user-select:none;
      transition: transform .12s ease;
      position:relative;
    }
    .slotCard:active{ transform: scale(0.98); }
    .slotTop{display:flex; align-items:center; justify-content:space-between; gap:8px;}
    .slotName{font-weight:1000; font-size:12px;}
    .slotIcon{font-size:14px; opacity:.9;}
    .slotDesc{margin-top:6px; font-size:11px; opacity:.8; line-height:1.2;}
    .slotLocked{opacity:.72; filter:saturate(.85);}
    .slotLocked .slotIcon{opacity:.75;}
    @keyframes unlockGlow{
      0%{box-shadow:0 0 0 rgba(255,255,255,0); transform:scale(1)}
      35%{box-shadow:0 0 22px rgba(255,255,255,0.22); transform:scale(1.02)}
      100%{box-shadow:0 0 0 rgba(255,255,255,0); transform:scale(1)}
    }
    .unlockFlash{animation: unlockGlow .65s ease;}
    @keyframes portraitPulse{
      0%{box-shadow:0 0 0 rgba(255,255,255,0);}
      40%{box-shadow:0 0 24px rgba(255,255,255,0.18);}
      100%{box-shadow:0 0 0 rgba(255,255,255,0);}
    }
    .portraitUnlockPulse{animation: portraitPulse .7s ease;}

    .slotProgressWrap{
      margin-top:6px;
      height:6px;
      border-radius:6px;
      background: rgba(255,255,255,0.08);
      overflow:hidden;
    }
    .slotProgressBar{
      height:100%;
      width:0%;
      background: linear-gradient(90deg, rgba(120,200,255,0.9), rgba(180,255,220,0.9));
      transition: width .35s ease;
    }
    .slotProgressText{margin-top:4px; font-size:10px; opacity:.75;}

    @keyframes barPulse{
      0%{filter:brightness(1)}
      50%{filter:brightness(1.35)}
      100%{filter:brightness(1)}
    }
    .barPulse{animation: barPulse .35s ease;}
    .closestSlot{
      border-color: rgba(180,255,220,0.35) !important;
      box-shadow: 0 0 18px rgba(180,255,220,0.10);
    }
    @keyframes plusPop{
      0%{ transform: translateY(0px); opacity: 0; }
      15%{ opacity: 1; }
      100%{ transform: translateY(-12px); opacity: 0; }
    }
    .plusOne{
      position:absolute;
      right:10px;
      top:40px;
      font-weight:1000;
      font-size:12px;
      opacity:0;
      pointer-events:none;
      animation: plusPop .6s ease;
    }

    /* toast */
    .toast{
      position:fixed;
      left:50%;
      bottom:18px;
      transform:translateX(-50%);
      background:rgba(0,0,0,.75);
      border:1px solid rgba(255,255,255,.16);
      border-radius:14px;
      padding:10px 12px;
      font-weight:900;
      font-size:12px;
      z-index:9999;
      max-width: 92vw;
      text-align:center;
      opacity:0;
      pointer-events:none;
      transition: opacity .18s ease, transform .18s ease;
    }
    .toast.show{opacity:1; transform:translateX(-50%) translateY(-2px);}

    /* confetti */
    .confetti{
      position: fixed;
      left: 50%;
      top: 22%;
      transform: translateX(-50%);
      pointer-events: none;
      z-index: 9999;
    }
    .confettiPiece{
      position:absolute;
      width:8px;height:12px;
      border-radius:3px;
      opacity:0.95;
      animation: confettiFly 700ms ease-out forwards;
    }
    @keyframes confettiFly{
      0%{ transform: translate(0,0) rotate(0deg); opacity: 1; }
      100%{ transform: translate(var(--dx), var(--dy)) rotate(var(--rot)); opacity: 0; }
    }

    /* loot modal */
    .lootModal{
      position:fixed; inset:0;
      background: rgba(0,0,0,0.72);
      display:flex;
      align-items:center;
      justify-content:center;
      z-index: 9999;
      padding: 16px;
    }
    .lootCard{
      width:min(520px, 96vw);
      border-radius: 18px;
      background: linear-gradient(135deg, rgba(20,20,26,0.96), rgba(10,10,12,0.96));
      border: 1px solid rgba(255,255,255,0.14);
      box-shadow: 0 0 34px rgba(0,0,0,0.55);
      padding: 14px 14px 16px;
    }
    .lootTop{display:flex; align-items:center; justify-content:space-between; gap:12px;}
    .lootTitle{font-weight:1100; font-size:18px;}
    .lootSub{margin-top:6px; opacity:0.85; font-size:12px;}
    .lootSection{margin-top:12px; padding-top:10px; border-top:1px solid rgba(255,255,255,0.10);}
    .lootHeader{font-weight:1000; font-size:12px; opacity:0.9;}
    .lootList{margin-top:8px; display:flex; flex-direction:column; gap:8px;}
    .lootRow{
      border-radius: 14px;
      padding: 10px 12px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.10);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
    }
    .lootLeft{display:flex; flex-direction:column; gap:2px;}
    .lootLabel{font-weight:1000; font-size:12px;}
    .lootNote{opacity:0.8; font-size:11px;}
    .lootValue{font-weight:1100; font-size:12px; opacity:0.95;}
    .hidden{display:none;}

    /* steal popup */
    .stealPopup{
      position:fixed;
      top:18%;
      left:50%;
      transform:translateX(-50%);
      background:linear-gradient(135deg,#2b0b0b,#160606);
      border:1px solid rgba(255,80,80,.4);
      border-radius:16px;
      padding:14px 18px;
      font-weight:1000;
      box-shadow:0 0 26px rgba(255,80,80,.35);
      z-index:9999;
      animation: stealPop .9s ease forwards;
    }
    @keyframes stealPop{
      0%{ transform:translate(-50%, -10px) scale(.9); opacity:0; }
      25%{ opacity:1; }
      100%{ transform:translate(-50%, 0) scale(1); opacity:1; }
    }

    /* steal anim chip */
    .stealAnim{position:fixed; inset:0; pointer-events:none; z-index:9999;}
    .stealChip{
      position:absolute;
      padding:10px 12px;
      border-radius:14px;
      font-weight:1000;
      font-size:12px;
      background:linear-gradient(135deg, rgba(255,80,80,.22), rgba(0,0,0,.55));
      border:1px solid rgba(255,80,80,.35);
      box-shadow:0 0 18px rgba(255,80,80,.25);
      opacity:0;
      transform:translate(-50%,-50%) scale(.95);
    }
    @keyframes chipFly{
      0%{opacity:0; transform:translate(-50%,-50%) scale(.9);}
      15%{opacity:1;}
      100%{opacity:0; transform:translate(calc(var(--dx) - 50%), calc(var(--dy) - 50%)) scale(1.05);}
    }
    .flyNow{animation: chipFly 650ms ease-out forwards;}

    /* naming modal */
    .modal{
      position:fixed; inset:0;
      background: rgba(0,0,0,.72);
      display:flex;
      align-items:center;
      justify-content:center;
      z-index:9999;
      padding:16px;
    }
    .modalCard{
      width:min(520px, 96vw);
      border-radius: 18px;
      background: linear-gradient(135deg, rgba(20,20,26,0.96), rgba(10,10,12,0.96));
      border: 1px solid rgba(255,255,255,0.14);
      box-shadow: 0 0 34px rgba(0,0,0,0.55);
      padding: 14px 14px 16px;
    }
    input{
      width:100%;
      padding:12px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
      color:var(--txt);
      font-weight:900;
      outline:none;
    }
    .smallNote{font-size:11px; opacity:.75; margin-top:8px; line-height:1.25;}

    /* battle layout */
    .battleGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    @media (max-width: 920px){
      .battleGrid{grid-template-columns:1fr}
    }
    .roleTag{margin-top:6px; font-weight:1000; font-size:12px; opacity:.9;}
    .bar{
      height:10px; border-radius:999px; overflow:hidden;
      background: rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.10);
    }
    .bar > div{
      height:100%;
      width:50%;
      background: linear-gradient(90deg, rgba(120,200,255,.85), rgba(180,255,220,.85));
      transition: width .2s ease;
    }
    .log{
      max-height:220px;
      overflow:auto;
      padding:10px;
      border-radius:14px;
      background: rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.10);
      font-size:12px;
      line-height:1.25;
    }
  </style>
</head>
<body>
  <div class="bgImage" id="bgImage"></div>
  <div class="bg"></div>

  <header>
    <div class="brand">
      <div style="width:34px;height:34px;border-radius:12px;background:rgba(180,255,220,.14);border:1px solid rgba(180,255,220,.28);display:grid;place-items:center;font-weight:1100;">W</div>
      <div>
        WheelForge
        <div class="muted" style="font-size:11px;margin-top:1px;">Build a character by spinning</div>
      </div>
    </div>
    <div class="topBtns">
      <span class="pill" id="dailyPill">Daily Build: OFF (testing)</span>
      <button class="btn small" id="volBtn">üîä</button>
      <button class="btn small danger" id="resetBtn">Reset</button>
    </div>
  </header>

  <div class="tabs">
    <div class="tab active" data-tab="build">Build</div>
    <div class="tab" data-tab="stats">Stats</div>
    <div class="tab" data-tab="pve">PvE</div>
    <div class="tab" data-tab="pvp">PvP</div>
  </div>

  <div class="wrap">
    <!-- BUILD -->
    <section id="tab-build">
      <div class="grid">
        <div class="panel">
          <div class="row">
            <div class="big">Build Progress</div>
            <span class="tag" id="phaseTag">Phase: Race</span>
          </div>
          <div class="sp"></div>

          <div class="buildStats" id="buildStats"></div>

          <div class="hr"></div>

          <div class="row">
            <div class="muted" style="font-size:12px;" id="buildHint">Spin the Race wheel to begin.</div>
            <button class="btn small secondary" id="skipBtn">Skip</button>
          </div>

          <div class="hr"></div>

          <div class="big">Trait Slots</div>
          <div class="muted" style="font-size:12px;margin-top:6px;">Win PvP to unlock more trait slots.</div>
          <div id="traitSlots" class="slotGrid"></div>

          <div class="hr"></div>

          <div class="row">
            <button class="btn primary" id="finalizeBtn">Finalize & Name</button>
            <button class="btn secondary" id="newBuildBtn">New Build</button>
          </div>

          <div class="smallNote">
            Note: this is a <b>static</b> site (GitHub Pages). ‚ÄúAdmin-only edits‚Äù and ‚Äúreal PvP vs real people‚Äù
            need a backend (like Supabase) later. For now, everything saves locally on your device.
          </div>
        </div>

        <div class="panel">
          <div class="wheelWrap">
            <div class="wheelTitle" id="wheelTitle">Race</div>
            <div class="wheelHint" id="wheelHint">Spin the wheel</div>
            <div class="pointer"></div>
            <canvas id="wheel" width="520" height="520"></canvas>
            <div class="row" style="width:100%;justify-content:center;gap:10px;flex-wrap:wrap;">
              <button class="btn primary" id="spinBtn">Spin</button>
              <button class="btn secondary" id="testFastBtn">Test Fast</button>
            </div>

            <div class="hr" style="width:100%;"></div>

            <div class="row" style="align-items:flex-start;gap:12px;flex-wrap:wrap;">
              <div style="flex:1; min-width:260px;">
                <div class="big">Portrait</div>
                <div class="muted" style="font-size:12px;margin-top:4px;">Layers stack here.</div>
                <div class="sp"></div>
                <div class="charFrame" id="charFrame">
                  <img id="layer_base" class="charLayer" alt="base"/>
                  <img id="layer_legs" class="charLayer" alt="legs"/>
                  <img id="layer_body" class="charLayer" alt="body"/>
                  <img id="layer_arms" class="charLayer" alt="arms"/>
                  <img id="layer_back" class="charLayer" alt="back"/>
                  <img id="layer_head" class="charLayer" alt="head"/>
                  <img id="layer_armor" class="charLayer" alt="armor"/>
                  <img id="layer_weapon" class="charLayer" alt="weapon"/>
                  <img id="layer_fx" class="charLayer charFx" alt="fx"/>
                </div>
              </div>

              <div style="flex:1; min-width:260px;">
                <div class="big">Build Notes</div>
                <div class="muted" style="font-size:12px;margin-top:4px;">Recent results & fusions.</div>
                <div class="sp"></div>
                <div class="log" id="buildLog"></div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- STATS -->
    <section id="tab-stats" class="hidden">
      <div class="panel">
        <div class="row">
          <div class="big">Your Character</div>
          <span class="tag" id="namedTag">Not finalized</span>
        </div>
        <div class="sp"></div>
        <div class="row" style="gap:14px; flex-wrap:wrap;">
          <div style="flex:0 0 260px;">
            <div class="charFrame" id="statsCharFrame" style="max-width:320px;">
              <img id="s_layer_base" class="charLayer" alt="base"/>
              <img id="s_layer_legs" class="charLayer" alt="legs"/>
              <img id="s_layer_body" class="charLayer" alt="body"/>
              <img id="s_layer_arms" class="charLayer" alt="arms"/>
              <img id="s_layer_back" class="charLayer" alt="back"/>
              <img id="s_layer_head" class="charLayer" alt="head"/>
              <img id="s_layer_armor" class="charLayer" alt="armor"/>
              <img id="s_layer_weapon" class="charLayer" alt="weapon"/>
              <img id="s_layer_fx" class="charLayer charFx" alt="fx"/>
            </div>
          </div>

          <div style="flex:1; min-width:280px;">
            <div class="panel" style="padding:12px;">
              <div class="big">Core</div>
              <div class="sp"></div>
              <div class="buildStats" id="statsList"></div>
            </div>

            <div class="sp"></div>

            <div class="panel" style="padding:12px;">
              <div class="big">Final Stats</div>
              <div class="muted" style="font-size:12px;margin-top:4px;">Includes race modifiers.</div>
              <div class="sp"></div>
              <div class="buildStats" id="finalStatsList"></div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- PVE -->
    <section id="tab-pve" class="hidden">
      <div class="panel">
        <div class="row">
          <div class="big">PvE (Event Fights)</div>
          <button class="btn primary" id="pveStartBtn">Start Event</button>
        </div>
        <div class="muted" style="font-size:12px;margin-top:6px;">
          PvE is a quick battle against a generated enemy/event.
        </div>
        <div class="hr"></div>
        <div class="battleGrid">
          <div class="panel">
            <div class="big">You</div>
            <div class="sp"></div>
            <div class="charFrame" id="pve_p_charFrame" style="max-width:300px;">
              <img id="pve_p_base" class="charLayer"/>
              <img id="pve_p_legs" class="charLayer"/>
              <img id="pve_p_body" class="charLayer"/>
              <img id="pve_p_arms" class="charLayer"/>
              <img id="pve_p_back" class="charLayer"/>
              <img id="pve_p_head" class="charLayer"/>
              <img id="pve_p_fx" class="charLayer charFx"/>
            </div>
            <div class="roleTag" id="pve_p_roleTag"></div>
            <div class="sp"></div>
            <div class="bar"><div id="pve_p_hp"></div></div>
          </div>

          <div class="panel">
            <div class="big">Enemy</div>
            <div class="sp"></div>
            <div class="charFrame" id="pve_e_charFrame" style="max-width:300px;">
              <img id="pve_e_base" class="charLayer"/>
              <img id="pve_e_legs" class="charLayer"/>
              <img id="pve_e_body" class="charLayer"/>
              <img id="pve_e_arms" class="charLayer"/>
              <img id="pve_e_back" class="charLayer"/>
              <img id="pve_e_head" class="charLayer"/>
              <img id="pve_e_fx" class="charLayer charFx"/>
            </div>
            <div class="roleTag" id="pve_e_roleTag"></div>
            <div class="sp"></div>
            <div class="bar"><div id="pve_e_hp"></div></div>
          </div>
        </div>
        <div class="hr"></div>
        <div class="log" id="pveLog"></div>
      </div>
    </section>

    <!-- PVP -->
    <section id="tab-pvp" class="hidden">
      <div class="panel">
        <div class="row">
          <div class="big">PvP (Local Sim)</div>
          <button class="btn primary" id="pvpStartBtn">Find Opponent</button>
        </div>
        <div class="muted" style="font-size:12px;margin-top:6px;">
          Real PvP (vs real people) needs Supabase later. This sim generates an opponent build.
        </div>
        <div class="hr"></div>
        <div class="battleGrid">
          <div class="panel">
            <div class="big">You</div>
            <div class="sp"></div>
            <div class="charFrame" id="p_charFrame" style="max-width:300px;">
              <img id="p_base" class="charLayer"/>
              <img id="p_legs" class="charLayer"/>
              <img id="p_body" class="charLayer"/>
              <img id="p_arms" class="charLayer"/>
              <img id="p_back" class="charLayer"/>
              <img id="p_head" class="charLayer"/>
              <img id="p_fx" class="charLayer charFx"/>
            </div>
            <div class="roleTag" id="p_roleTag"></div>
            <div class="sp"></div>
            <div class="bar"><div id="p_hp"></div></div>
          </div>

          <div class="panel">
            <div class="big">Opponent</div>
            <div class="sp"></div>
            <div class="charFrame" id="e_charFrame" style="max-width:300px;">
              <img id="e_base" class="charLayer"/>
              <img id="e_legs" class="charLayer"/>
              <img id="e_body" class="charLayer"/>
              <img id="e_arms" class="charLayer"/>
              <img id="e_back" class="charLayer"/>
              <img id="e_head" class="charLayer"/>
              <img id="e_fx" class="charLayer charFx"/>
            </div>
            <div class="roleTag" id="e_roleTag"></div>
            <div class="sp"></div>
            <div class="bar"><div id="e_hp"></div></div>
          </div>
        </div>
        <div class="hr"></div>
        <div class="log" id="pvpLog"></div>
      </div>
    </section>
  </div>

  <!-- naming modal -->
  <div id="nameModal" class="modal hidden">
    <div class="modalCard">
      <div class="row">
        <div class="big">Name your character</div>
        <button class="btn secondary small" onclick="closeNameModal()">Close</button>
      </div>
      <div class="sp"></div>
      <div class="muted" style="font-size:12px;">
        If you got a unique last name trait later, you‚Äôll only be able to change the first name.
      </div>
      <div class="sp"></div>
      <input id="nameInput" maxlength="18" placeholder="Character name (no bad words)" />
      <div class="smallNote">
        Keep it short. Letters/numbers only. (You can add banned words later in code.)
      </div>
      <div class="sp"></div>
      <div class="row">
        <button class="btn primary" onclick="saveName()">Save Name</button>
        <button class="btn danger" onclick="closeNameModal()">Cancel</button>
      </div>
    </div>
  </div>

  <!-- loot modal -->
  <div id="lootModal" class="lootModal hidden">
    <div class="lootCard">
      <div class="lootTop">
        <div id="lootTitle" class="lootTitle">Victory</div>
        <button class="btn secondary" onclick="closeLoot()">Close</button>
      </div>
      <div id="lootSub" class="lootSub"></div>

      <div class="lootSection">
        <div class="lootHeader">Rewards</div>
        <div id="lootRewards" class="lootList"></div>
      </div>

      <div class="lootSection">
        <div class="lootHeader">Trait Event</div>
        <div id="lootTrait" class="lootList"></div>
      </div>

      <div class="lootSection">
        <div class="lootHeader">Progress</div>
        <div id="lootProgress" class="lootList"></div>
      </div>
    </div>
  </div>

  <!-- steal popup -->
  <div id="stealPopup" class="stealPopup hidden"></div>

  <!-- steal anim -->
  <div id="stealAnim" class="stealAnim hidden">
    <div id="stealChip" class="stealChip"></div>
  </div>

  <!-- toast -->
  <div id="toast" class="toast"></div>

<script>
/* =========================================================
   CONFIG (TESTING vs DAILY LOCK)
========================================================= */
const TEST_MODE = true; // set to false when you want 1 full build per day
const STORAGE_KEY = "wheel_forge_save_v1";

/* =========================================================
   RACE LIST (LOCKED)
========================================================= */
const RACE_OPTIONS = [
  "Gnome","Goblin","Zombie","Skeleton","Human","Orc","Cyborg","Giant",
  "Demi-human","Golem","Dragon","Vampire","Hivemind","Shinigami",
  "Soul Eater","Demon","Alien","God","Hybrid"
];

const RACE_RIG = {
  "Gnome":"humanoid","Goblin":"humanoid","Zombie":"humanoid","Skeleton":"humanoid",
  "Human":"humanoid","Orc":"humanoid","Vampire":"humanoid","Demon":"humanoid",
  "Alien":"humanoid","God":"humanoid","Hybrid":"humanoid","Shinigami":"humanoid",
  "Soul Eater":"special_humanoid","Demi-human":"humanoid",

  "Cyborg":"cyborg_modular","Hivemind":"hivemind_special","Dragon":"dragon_animal",
  "Golem":"golem_big","Giant":"giant_big"
};

const RACE_BASE_IMAGE = {
  // Put your real files here in your repo:
  // assets/bases/golem/base.png
  // assets/bases/giant/base.png
  "Golem":"assets/bases/golem/base.png",
  "Giant":"assets/bases/giant/base.png"
};

// Simple background mapping (add images later if you want)
// Example filenames: assets/backgrounds/vampire.jpg, assets/backgrounds/golem.jpg, etc.
function setRaceBackground(race){
  const bg = document.getElementById("bgImage");
  if(!bg) return;
  const key = (race || "").toLowerCase().replaceAll(" ","_");
  const url = `assets/backgrounds/${key}.jpg`;
  // If the file doesn't exist, browser shows none (safe).
  bg.style.backgroundImage = `url("${url}")`;
}

/* =========================================================
   WHEELS (you can replace these arrays later)
========================================================= */
const POWER_OPTIONS = [
  "No Power","Adaptation","Gravity Manipulation","Time Manipulation","Regeneration",
  "Weapon Creation","Lightning","Ice Manipulation","Telekinesis","Teleportation",
  "Fire","Heavenly Restriction","Curse Mark","Flight","Immortal"
];

const WEAPON_OPTIONS = [
  "No Weapon","Sword","Scythe","Pistol","Bow","Axe","Hammer","Stick",
  "Brass Knuckles","Spear","Water Gun","Magic Staff","Guitar","Nunchucks"
];

// Demi-human wheel (if race === Demi-human)
const DEMI_TYPES = ["Dragonoid","Elves","Werebeast","Troll","Hobgoblin","Lizardmen","Fishman","Dwarf"];
const WEREBEAST_TYPES = ["Wolf","Rabbit","Killer Whale","Giraffe","Elephant","Bear","Turtle","Alligator","Minotaur"];

// Stats wheels (simple placeholders)
const STRENGTH_OPTIONS = ["1","2","3","4","5","6","7","8","9","10"];
const DURABILITY_OPTIONS = ["1","2","3","4","5","6","7","8","9","10"];
const LUCK_OPTIONS = ["1","2","3","4","5","6","7","8","9","10"];

/* =========================================================
   WEREBEAST SLOTS + FX (locked)
========================================================= */
const WEREBEAST_SLOTS = {
  Rabbit: ["head","legs"],
  Wolf: ["head","arms","legs"],
  Minotaur: ["head","body"],
  Elephant: ["head","body"],
  Turtle: ["back","body"],
  Alligator: ["head","arms","legs"],
  "Killer Whale": ["head","back","body"],
  Giraffe: ["head","body"],
  Bear: ["head","body","arms","legs"] // optional if you use it
};

const BEAST_ROLE = {
  Rabbit: "Speed",
  Wolf: "Hunter",
  Minotaur: "Wall",
  Elephant: "Juggernaut",
  Turtle: "Fortress",
  Alligator: "Ambush",
  "Killer Whale": "Apex",
  Giraffe: "Uncanny Tower",
  Bear: "Bruiser"
};

// FX images are optional; if they don't exist, nothing breaks.
const BEAST_FX = {
  Rabbit: "assets/overlays/fx/speed.png",
  Wolf: "assets/overlays/fx/predator.png",
  Minotaur: "assets/overlays/fx/stonepulse.png",
  Elephant: "assets/overlays/fx/quake.png",
  Turtle: "assets/overlays/fx/guard.png",
  Alligator: "assets/overlays/fx/swampmist.png",
  "Killer Whale": "assets/overlays/fx/deepsea.png",
  Giraffe: "assets/overlays/fx/uncanny.png",
  Bear: "assets/overlays/fx/rage.png"
};

/* =========================================================
   DEMI-HUMANS (non-werebeast) integration
========================================================= */
const DEMI_SLOTS = {
  "Elves": ["head"],
  "Dragonoid": ["head"],
  "Troll": ["body"],
  "Hobgoblin": ["head"],
  "Lizardmen": ["head","legs"],
  "Fishman": ["head","arms"],
  "Dwarf": ["body"]
};

/* =========================================================
   BIG RIG OVERLAYS (Golem + Giant)
========================================================= */
const BIG_RIG_SLOTS = ["head","body","arms","legs","back"];
const BIG_RIG_OVERLAY_PATH = {
  "Golem": "assets/overlays/golem",
  "Giant": "assets/overlays/giant"
};

/* =========================================================
   TRAIT SLOT PROGRESSION
========================================================= */
const TRAIT_SLOTS = ["head","arms","back","legs","body"];
const SLOT_UNLOCK_WINS = { head:0, arms:3, back:6, legs:10, body:15 };
const SLOT_LABEL = { head:"Head", arms:"Arms", back:"Back", legs:"Legs", body:"Body" };

/* =========================================================
   PvP trait stealing
========================================================= */
const TRAIT_STEAL_CHANCE = 0.35;

/* =========================================================
   State
========================================================= */
const defaultState = () => ({
  settings:{
    volume: 0.65,
    muted: false,
  },
  daily:{
    // daily build lock (UTC date string)
    lastBuildDay: "",
    finalizedToday: false,
  },
  progress:{
    pvpWins: 0,
    unlockedSlots: { head:true, arms:false, back:false, legs:false, body:false },
    traitLockCharges: 0,
    revengeReady: false,
    lastStolenAt: 0
  },
  currency:{ coins: 0, xp: 0 },
  lastMatch:{ traitEvent: null },
  build:{
    phaseIndex: 0,     // which wheel step we are on
    phaseKey: "race",  // current phase id
    spinning: false
  },
  character:{
    finalized:false,
    name:"",
    race:null,
    demi:null,
    werebeastType:null,
    power:null,
    weapon:null,
    strength:null,
    durability:null,
    luck:null,
    // stackable traits:
    demiTraits: [] // [{kind,type}]
  }
});

let state = loadState();

/* =========================================================
   Build phases (sequential wheels)
========================================================= */
function phasesForCharacter(){
  // Base phases always:
  const phases = [
    { key:"race", label:"Race", options: RACE_OPTIONS, assign:(v)=>state.character.race=v },
  ];

  // If race is Demi-human, we do demi wheel after race
  if(state.character.race === "Demi-human"){
    phases.push({ key:"demi", label:"Demi Type", options: DEMI_TYPES, assign:(v)=>onDemiSpinResult(v) });
    // Werebeast is conditional after demi:
    if(state.character.demi === "Werebeast"){
      phases.push({ key:"werebeast", label:"Werebeast Type", options: WEREBEAST_TYPES, assign:(v)=>onWerebeastSpinResult(v) });
    }
  }

  // Core wheels
  phases.push(
    { key:"power", label:"Power", options: POWER_OPTIONS, assign:(v)=>state.character.power=v },
    { key:"weapon", label:"Weapon", options: WEAPON_OPTIONS, assign:(v)=>state.character.weapon=v },
    { key:"strength", label:"Strength", options: STRENGTH_OPTIONS, assign:(v)=>state.character.strength=v },
    { key:"durability", label:"Durability", options: DURABILITY_OPTIONS, assign:(v)=>state.character.durability=v },
    { key:"luck", label:"Luck", options: LUCK_OPTIONS, assign:(v)=>state.character.luck=v },
  );

  return phases;
}

/* =========================================================
   UI helpers
========================================================= */
function $(id){ return document.getElementById(id); }
function escapeHtml(s){
  return String(s ?? "").replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
}
function toast(msg){
  const t = $("toast");
  if(!t) return;
  t.textContent = msg;
  t.classList.add("show");
  setTimeout(()=>t.classList.remove("show"), 1400);
}
function logBuild(msg){
  const el = $("buildLog");
  if(!el) return;
  const time = new Date().toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
  el.innerHTML = `<div><span class="muted">[${time}]</span> ${escapeHtml(msg)}</div>` + el.innerHTML;
}

/* =========================================================
   Daily lock
========================================================= */
function todayKeyUTC(){
  const d = new Date();
  const y = d.getUTCFullYear();
  const m = String(d.getUTCMonth()+1).padStart(2,'0');
  const day = String(d.getUTCDate()).padStart(2,'0');
  return `${y}-${m}-${day}`;
}
function dailyLockEnabled(){ return !TEST_MODE; }

function updateDailyLock(){
  const pill = $("dailyPill");
  if(!pill) return;
  if(TEST_MODE){
    pill.textContent = "Daily Build: OFF (testing)";
    return;
  }
  const tk = todayKeyUTC();
  if(state.daily.lastBuildDay !== tk){
    state.daily.lastBuildDay = tk;
    state.daily.finalizedToday = false;
    saveState();
  }
  pill.textContent = state.daily.finalizedToday ? "Daily Build: USED (locked)" : "Daily Build: READY";
}

/* =========================================================
   Wheel drawing + physics
========================================================= */
const wheelCanvas = $("wheel");
const ctx = wheelCanvas.getContext("2d");

let wheelOptions = [];
let wheelRotation = 0;
let spinVel = 0;
let targetStopRot = null;
let lastTickIndex = -1;

function colorForIndex(i){
  const hue = (i * 360 / Math.max(1,wheelOptions.length));
  return `hsl(${hue} 80% 55%)`;
}

function drawWheel(){
  const W = wheelCanvas.width, H = wheelCanvas.height;
  const cx = W/2, cy = H/2;
  const r = Math.min(cx,cy)-10;

  ctx.clearRect(0,0,W,H);

  // disk
  const n = Math.max(1, wheelOptions.length);
  const ang = (Math.PI*2)/n;

  for(let i=0;i<n;i++){
    const a0 = wheelRotation + i*ang;
    const a1 = a0 + ang;

    ctx.beginPath();
    ctx.moveTo(cx,cy);
    ctx.arc(cx,cy,r, a0, a1);
    ctx.closePath();
    ctx.fillStyle = colorForIndex(i);
    ctx.fill();

    ctx.strokeStyle = "rgba(0,0,0,.25)";
    ctx.lineWidth = 2;
    ctx.stroke();

    // label
    ctx.save();
    ctx.translate(cx,cy);
    ctx.rotate(a0 + ang/2);
    ctx.textAlign = "right";
    ctx.fillStyle = "rgba(0,0,0,.75)";
    ctx.font = "bold 18px system-ui";
    const label = String(wheelOptions[i]);
    ctx.fillText(label, r-12, 6);
    ctx.restore();
  }

  // center button
  ctx.beginPath();
  ctx.arc(cx,cy,58,0,Math.PI*2);
  ctx.fillStyle = "rgba(0,0,0,.55)";
  ctx.fill();
  ctx.strokeStyle = "rgba(255,255,255,.16)";
  ctx.lineWidth = 2;
  ctx.stroke();

  ctx.fillStyle = "rgba(255,255,255,.92)";
  ctx.font = "1100 22px system-ui";
  ctx.textAlign="center";
  ctx.fillText("SPIN", cx, cy+8);
}

function currentSliceIndex(){
  // pointer is at top ( -90deg ), so compute which slice is there.
  const n = Math.max(1, wheelOptions.length);
  const ang = (Math.PI*2)/n;
  // Normalize rotation so 0 means slice 0 starts at 0 rad.
  // Pointer angle = -PI/2
  let a = (-Math.PI/2 - wheelRotation);
  a = (a % (Math.PI*2) + Math.PI*2) % (Math.PI*2);
  const idx = Math.floor(a / ang) % n;
  return idx;
}

/* =========================================================
   Sound (no files needed)
========================================================= */
let audioCtx = null;
function ensureAudio(){
  if(audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
}
function playClick(freq=1100, dur=0.025, vol=0.15){
  if(state.settings.muted) return;
  ensureAudio();
  const t0 = audioCtx.currentTime;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = "square";
  o.frequency.setValueAtTime(freq, t0);
  g.gain.setValueAtTime(0, t0);
  g.gain.linearRampToValueAtTime(vol * state.settings.volume, t0+0.004);
  g.gain.linearRampToValueAtTime(0, t0+dur);
  o.connect(g).connect(audioCtx.destination);
  o.start(t0);
  o.stop(t0+dur+0.01);
}
function playSpinWhoosh(){
  // short whoosh beep
  playClick(420, 0.05, 0.12);
}
function playUnlockSound(){
  playClick(880, 0.06, 0.16);
  setTimeout(()=>playClick(1320, 0.05, 0.14), 60);
}
function playStealSound(){
  playClick(220, 0.06, 0.18);
  setTimeout(()=>playClick(140, 0.08, 0.14), 40);
}
function playBlockSound(){
  playClick(520, 0.05, 0.14);
  setTimeout(()=>playClick(520, 0.05, 0.10), 70);
}

/* =========================================================
   Spinning logic (smooth stop + tick sounds)
========================================================= */
function startSpin(fast=false){
  if(state.build.spinning) return;

  if(dailyLockEnabled() && state.daily.finalizedToday){
    toast("Daily build already used.");
    return;
  }
  if(state.character.finalized){
    toast("Build is finalized. Start a new build to spin again.");
    return;
  }

  state.build.spinning = true;
  saveState();

  const baseVel = fast ? 0.45 : 0.32;
  spinVel = baseVel + Math.random()*0.18;

  // Decide a stop target rotations ahead:
  const n = Math.max(1, wheelOptions.length);
  const ang = (Math.PI*2)/n;
  const stopIdx = Math.floor(Math.random()*n);

  // Compute rotation so that stopIdx lands under pointer:
  // We want currentSliceIndex() == stopIdx at end, with spinVel -> 0.
  // We'll pick a target rotation offset relative to current wheelRotation:
  const fullTurns = 8 + Math.floor(Math.random()*4);
  const targetAngleForIdx = (-Math.PI/2) - (stopIdx*ang + ang/2); // center under pointer
  // wheelRotation should equal -targetAngleForIdx (but add turns)
  const desiredRotation = -targetAngleForIdx + fullTurns*(Math.PI*2);
  // set target stop absolute (increasing)
  const cur = wheelRotation;
  targetStopRot = cur + ((desiredRotation - (cur % (Math.PI*2)) + (Math.PI*2)) % (Math.PI*2)) + fullTurns*(Math.PI*2);

  lastTickIndex = currentSliceIndex();
  playSpinWhoosh();
}

function stepWheel(){
  // smooth decel to targetStopRot:
  if(state.build.spinning){
    const remaining = Math.max(0, targetStopRot - wheelRotation);

    // speed proportional to remaining (smooth), but never speed up at end
    const desiredVel = Math.min(0.55, Math.max(0.02, remaining * 0.0042));
    // ease spinVel down toward desiredVel
    spinVel = spinVel*0.86 + desiredVel*0.14;

    wheelRotation += spinVel;

    // tick per slice
    const idx = currentSliceIndex();
    if(idx !== lastTickIndex){
      lastTickIndex = idx;
      // pitch changes with speed
      const pitch = 800 + Math.min(700, spinVel*2600);
      playClick(pitch, 0.016, 0.10);
    }

    if(remaining < 0.012 && spinVel < 0.03){
      // stop
      wheelRotation = targetStopRot;
      state.build.spinning = false;
      saveState();

      const finalIdx = currentSliceIndex();
      const result = wheelOptions[finalIdx];
      onSpinResult(String(result));
    }
  }

  drawWheel();
  requestAnimationFrame(stepWheel);
}

/* =========================================================
   Trait systems (stacking + slots)
========================================================= */
function isSlotUnlocked(slot){
  return !!state.progress?.unlockedSlots?.[slot];
}
function requiredWinsForSlot(slot){
  return SLOT_UNLOCK_WINS[slot] ?? 999;
}
function slotProgress(slot){
  const wins = state.progress.pvpWins || 0;
  const req = requiredWinsForSlot(slot);
  if(req <= 0) return 1;
  return Math.min(1, wins / req);
}
function findClosestLockedSlot(){
  const wins = state.progress.pvpWins || 0;
  let bestSlot = null;
  let bestRemaining = Infinity;
  for(const slot of TRAIT_SLOTS){
    if(isSlotUnlocked(slot)) continue;
    const req = requiredWinsForSlot(slot);
    const remaining = Math.max(0, req - wins);
    if(remaining < bestRemaining){
      bestRemaining = remaining;
      bestSlot = slot;
    }
  }
  return bestSlot;
}

function slotsForTrait(trait){
  if(!trait) return [];
  if(trait.kind === "werebeast"){
    return WEREBEAST_SLOTS[trait.type] || [];
  }
  if(trait.kind === "demi"){
    return DEMI_SLOTS[trait.type] || [];
  }
  return [];
}

function canApplyTrait(trait){
  const slots = slotsForTrait(trait);
  for(const s of slots){
    if(!isSlotUnlocked(s)){
      return { ok:false, blockedSlot:s };
    }
  }
  return { ok:true, blockedSlot:null };
}

function addDemiTrait(trait){
  state.character.demiTraits ||= [];

  const check = canApplyTrait(trait);
  if(!check.ok){
    toast(`Trait needs ${SLOT_LABEL[check.blockedSlot]} slot unlocked.`);
    return false;
  }
  state.character.demiTraits.push(trait);
  saveState();
  refreshUI();
  return true;
}

function getCurrentTraitForSlot(slot){
  const traits = Array.isArray(state.character.demiTraits) ? state.character.demiTraits : [];
  for(let i = traits.length - 1; i >= 0; i--){
    const t = traits[i];
    if(slotsForTrait(t).includes(slot)){
      return `${t.type}`;
    }
  }
  return null;
}

/* =========================================================
   Demi-human wheel logic
========================================================= */
function onDemiSpinResult(result){
  state.character.demi = result;
  state.character.werebeastType = null;

  // enforce: only one demi trait per normal spin (stacking later via unlocks)
  const alreadyHasDemi = (state.character.demiTraits || []).some(t => t.kind === "demi");
  if(!alreadyHasDemi && result !== "Werebeast"){
    addDemiTrait({ kind:"demi", type: result });
  }
  // If werebeast, we wait for werebeast type wheel to add trait
  logBuild(`Demi type: ${result}`);
  refreshUI();
}

function onWerebeastSpinResult(result){
  state.character.werebeastType = result;
  // add werebeast trait (stack-ready but slot-locked)
  addDemiTrait({ kind:"werebeast", type: result });
  logBuild(`Werebeast type: ${result}`);
  refreshUI();
}

/* =========================================================
   Overlays & portrait pipeline
========================================================= */
function clearSlots(prefix=""){
  ["head","arms","legs","back","body","armor","weapon"].forEach(slot=>{
    const el = document.getElementById(`${prefix}layer_${slot}`);
    if(el) el.src = "";
  });
}

function clearBigRigSlots(prefix=""){
  BIG_RIG_SLOTS.forEach(slot=>{
    const el = document.getElementById(`${prefix}layer_${slot}`);
    if(el) el.src = "";
  });
}

function getHumanoidBaseForRace(race){
  // optional: map to your assets later:
  // return `assets/bases/humanoid/${raceKey}/base.png`;
  return "assets/bases/humanoid/base.png";
}
function getSpecialHumanoidBase(race){
  return "assets/bases/special/base.png";
}

function applyRaceBase(char, prefix=""){
  const base = document.getElementById(`${prefix}layer_base`);
  if(!base) return;

  const race = char.race;
  const rig = RACE_RIG[race] || "humanoid";

  if(rig === "golem_big" || rig === "giant_big"){
    base.src = RACE_BASE_IMAGE[race] || "";
    return;
  }
  if(rig === "dragon_animal"){
    base.src = "assets/bases/dragon/base.png";
    return;
  }
  if(rig === "special_humanoid"){
    base.src = getSpecialHumanoidBase(race);
    return;
  }
  base.src = getHumanoidBaseForRace(race);
}

function applyRigFraming(char, frameId="charFrame"){
  const frame = document.getElementById(frameId);
  if(!frame) return;
  frame.classList.remove("bigRig","idle-sway","idle-heavy");

  const rig = RACE_RIG[char.race] || "humanoid";
  if(rig === "golem_big" || rig === "giant_big"){
    frame.classList.add("bigRig");
  }

  // idle weight from werebeast role OR big rig
  const beast = char.werebeastType;
  const heavy = (rig === "golem_big" || rig === "giant_big") ||
    ["Elephant","Minotaur","Turtle","Killer Whale","Bear"].includes(beast);
  frame.classList.add(heavy ? "idle-heavy" : "idle-sway");
}

function applyBigRigOverlays(char, prefix=""){
  const rig = RACE_RIG[char.race];
  if(rig !== "golem_big" && rig !== "giant_big") return;

  const basePath = BIG_RIG_OVERLAY_PATH[char.race];
  if(!basePath) return;

  BIG_RIG_SLOTS.forEach(slot=>{
    const el = document.getElementById(`${prefix}layer_${slot}`);
    if(!el) return;
    el.src = `${basePath}/${slot}/default.png`; // safe if missing
  });
}

function applyDemiTraits(char, prefix=""){
  // clear demi slots first (for humanoids)
  ["head","arms","legs","back","body"].forEach(slot=>{
    const el = document.getElementById(`${prefix}layer_${slot}`);
    if(el) el.src = "";
  });

  const rig = RACE_RIG[char.race] || "humanoid";
  if(rig === "golem_big" || rig === "giant_big"){
    // big rigs use their own overlays
    applyBigRigOverlays(char, prefix);
    return;
  }

  const traits = Array.isArray(char.demiTraits) ? char.demiTraits : [];
  if(traits.length === 0) return;

  const slotSrc = {}; // newest wins

  for(const t of traits){
    if(t.kind === "werebeast"){
      const beast = t.type;
      const key = beast.toLowerCase().replaceAll(" ", "_");
      const slots = WEREBEAST_SLOTS[beast] || [];
      for(const slot of slots){
        slotSrc[slot] = `assets/overlays/werebeast/${key}/${slot}.png`;
      }
    }
    if(t.kind === "demi"){
      const key = t.type.toLowerCase().replaceAll(" ", "_");
      const slots = DEMI_SLOTS[t.type] || [];
      for(const slot of slots){
        slotSrc[slot] = `assets/overlays/demi/${key}/${slot}.png`;
      }
    }
  }

  for(const slot of Object.keys(slotSrc)){
    const el = document.getElementById(`${prefix}layer_${slot}`);
    if(el) el.src = slotSrc[slot];
  }
}

function applyIdleFx(char, prefix=""){
  const fx = document.getElementById(`${prefix}layer_fx`);
  if(!fx) return;

  fx.classList.remove("on");
  fx.src = "";

  const beast = char?.werebeastType;
  if(!beast) return;

  const src = BEAST_FX[beast];
  if(src){
    fx.src = src;
    fx.classList.add("on");
  }
}

/* =========================================================
   Race stat mods (starter identity)
========================================================= */
const RACE_STAT_MODS = {
  "Golem": { strength: +12, durability: +20, luck: -2 },
  "Giant": { strength: +18, durability: +10, luck:  0 }
};

function baseStatsFromChoices(char){
  const str = parseInt(char.strength || "0", 10) || 0;
  const dur = parseInt(char.durability || "0", 10) || 0;
  const luck = parseInt(char.luck || "0", 10) || 0;

  // simple derived stats
  const speed = Math.max(1, 12 - Math.floor((dur+str)/4));
  return { strength:str, durability:dur, luck:luck, speed:speed };
}

function applyRaceStatMods(char, stats){
  const mods = RACE_STAT_MODS[char.race];
  if(!mods) return stats;
  const out = {...stats};
  for(const k of Object.keys(mods)){
    out[k] = (out[k] || 0) + mods[k];
  }
  return out;
}

function finalStats(char){
  let s = baseStatsFromChoices(char);
  s = applyRaceStatMods(char, s);

  // Werebeast flavor (small)
  if(char.werebeastType === "Rabbit") s.speed += 2;
  if(char.werebeastType === "Wolf") s.strength += 2;
  if(char.werebeastType === "Turtle") s.durability += 3;
  if(char.werebeastType === "Elephant") s.durability += 4, s.speed -= 1;

  // clamp minimums
  s.speed = Math.max(1, s.speed);
  return s;
}

/* =========================================================
   Trait slots UI rendering + unlock juice
========================================================= */
function renderTraitSlots(){
  const host = $("traitSlots");
  if(!host) return;

  host.innerHTML = "";
  const closest = findClosestLockedSlot();
  const wins = state.progress.pvpWins || 0;

  for(const slot of TRAIT_SLOTS){
    const unlocked = isSlotUnlocked(slot);
    const req = requiredWinsForSlot(slot);
    const current = getCurrentTraitForSlot(slot);

    const card = document.createElement("div");
    card.className = "slotCard" + (unlocked ? "" : " slotLocked") + (!unlocked && slot===closest ? " closestSlot" : "");

    const pct = Math.round(slotProgress(slot) * 100);

    card.innerHTML = `
      <div class="slotTop">
        <div class="slotName">${SLOT_LABEL[slot]}</div>
        <div class="slotIcon">${unlocked ? "‚úÖ" : "üîí"}</div>
      </div>
      <div class="slotDesc">
        ${unlocked
          ? (current ? `Equipped: <b>${escapeHtml(current)}</b>` : "Empty (ready for a trait)")
          : `Unlock at <b>${req}</b> PvP wins`
        }
      </div>
      ${unlocked ? "" : `
        <div class="slotProgressWrap">
          <div class="slotProgressBar" style="width:${pct}%"></div>
        </div>
        <div class="slotProgressText">${Math.min(wins, req)} / ${req} wins</div>
      `}
    `;

    card.addEventListener("click", ()=>{
      if(unlocked){
        toast(current ? `${SLOT_LABEL[slot]}: ${current}` : `${SLOT_LABEL[slot]} is ready.`);
      }else{
        toast(`Locked. Win ${req} PvP matches to unlock ${SLOT_LABEL[slot]}.`);
      }
    });

    host.appendChild(card);
  }
}

function showPlusOneOnClosestSlot(){
  const host = $("traitSlots");
  if(!host) return;
  const target = findClosestLockedSlot();
  if(!target) return;

  const cards = host.querySelectorAll(".slotCard");
  for(const card of cards){
    const nameEl = card.querySelector(".slotName");
    if(!nameEl) continue;
    const label = nameEl.textContent.trim();
    const slot = Object.keys(SLOT_LABEL).find(k => SLOT_LABEL[k] === label);
    if(slot !== target) continue;

    const plus = document.createElement("div");
    plus.className = "plusOne";
    plus.textContent = "+1";
    card.appendChild(plus);
    setTimeout(()=>plus.remove(), 650);
    break;
  }
}

function pulseClosestLockedBar(){
  const host = $("traitSlots");
  if(!host) return;
  const target = findClosestLockedSlot();
  if(!target) return;

  const cards = host.querySelectorAll(".slotCard");
  for(const card of cards){
    const nameEl = card.querySelector(".slotName");
    if(!nameEl) continue;
    const label = nameEl.textContent.trim();
    const slot = Object.keys(SLOT_LABEL).find(k => SLOT_LABEL[k] === label);
    if(slot !== target) continue;

    const bar = card.querySelector(".slotProgressBar");
    if(bar){
      bar.classList.remove("barPulse");
      void bar.offsetWidth;
      bar.classList.add("barPulse");
    }
  }
}

function confettiBurst(){
  const wrap = document.createElement("div");
  wrap.className = "confetti";
  document.body.appendChild(wrap);

  const count = 18;
  for(let i=0;i<count;i++){
    const p = document.createElement("div");
    p.className = "confettiPiece";

    const dx = (Math.random()*220 - 110).toFixed(0) + "px";
    const dy = (Math.random()*220 + 90).toFixed(0) + "px";
    const rot = (Math.random()*540 - 270).toFixed(0) + "deg";
    p.style.setProperty("--dx", dx);
    p.style.setProperty("--dy", dy);
    p.style.setProperty("--rot", rot);

    const hue = Math.floor(Math.random()*360);
    p.style.background = `hsl(${hue} 90% 60%)`;
    p.style.animationDelay = (Math.random()*70).toFixed(0) + "ms";

    wrap.appendChild(p);
  }
  setTimeout(()=>wrap.remove(), 850);
}

function unlockCelebration(slots){
  confettiBurst();
  const frame = $("charFrame");
  if(frame){
    frame.classList.remove("portraitUnlockPulse");
    void frame.offsetWidth;
    frame.classList.add("portraitUnlockPulse");
  }
  playUnlockSound();
  toast(`Unlocked: ${slots.map(s=>SLOT_LABEL[s]).join(", ")}!`);
}

function checkSlotUnlocks(){
  const wins = state.progress.pvpWins || 0;
  const unlocked = state.progress.unlockedSlots;
  let newlyUnlocked = [];

  for(const slot of TRAIT_SLOTS){
    if(unlocked[slot]) continue;
    if(wins >= requiredWinsForSlot(slot)){
      unlocked[slot] = true;
      newlyUnlocked.push(slot);
    }
  }

  if(newlyUnlocked.length){
    saveState();
    unlockCelebration(newlyUnlocked);
    renderTraitSlots();
  }
}

/* =========================================================
   Build flow + bug fix (no spinning after naming/finalize)
========================================================= */
function currentPhase(){
  const phases = phasesForCharacter();
  const idx = Math.min(state.build.phaseIndex, phases.length-1);
  return phases[idx];
}

function setPhaseIndex(i){
  state.build.phaseIndex = i;
  const ph = currentPhase();
  state.build.phaseKey = ph.key;
  saveState();
  setWheel(ph.label, ph.options);
  $("phaseTag").textContent = `Phase: ${ph.label}`;
  $("wheelTitle").textContent = ph.label;
  $("wheelHint").textContent = "Spin the wheel";
  $("buildHint").textContent = `Spin for ${ph.label}.`;
}

function proceedToNextPhase(){
  const phases = phasesForCharacter();
  const next = state.build.phaseIndex + 1;
  if(next >= phases.length){
    // all done -> prompt name
    $("buildHint").textContent = "All spins complete. Finalize & name your character.";
    $("wheelHint").textContent = "Complete";
    return;
  }
  setPhaseIndex(next);
}

function setWheel(label, options){
  wheelOptions = [...options];
  // Reset rotation slightly so it doesn't look stuck
  wheelRotation = wheelRotation % (Math.PI*2);
  drawWheel();
}

/* =========================================================
   Spin result handler
========================================================= */
function onSpinResult(result){
  const ph = currentPhase();
  if(!ph) return;

  // Assign or run special handler
  if(ph.key === "demi"){
    onDemiSpinResult(result);
  }else if(ph.key === "werebeast"){
    onWerebeastSpinResult(result);
  }else{
    ph.assign(result);
    logBuild(`${ph.label}: ${result}`);
  }

  // Special: race affects background immediately
  if(ph.key === "race"){
    setRaceBackground(result);
    // Reset any demi data if not Demi-human
    if(result !== "Demi-human"){
      state.character.demi = null;
      state.character.werebeastType = null;
      // keep existing demiTraits if you want; for a clean build, clear them:
      state.character.demiTraits = [];
    }
  }

  // After selecting demi as "Werebeast", insert werebeast phase next
  // By calling phasesForCharacter() dynamically, proceedToNextPhase will pick it up.

  saveState();
  refreshUI();
  proceedToNextPhase();
}

/* =========================================================
   Build stats side list
========================================================= */
function buildStatLines(){
  const c = state.character;
  const lines = [
    ["Race", c.race || "‚Äî"],
    ["Demi", c.demi || "‚Äî"],
    ["Werebeast", c.werebeastType || "‚Äî"],
    ["Power", c.power || "‚Äî"],
    ["Weapon", c.weapon || "‚Äî"],
    ["Strength", c.strength || "‚Äî"],
    ["Durability", c.durability || "‚Äî"],
    ["Luck", c.luck || "‚Äî"],
  ];
  return lines;
}

function renderBuildStats(){
  const host = $("buildStats");
  host.innerHTML = "";
  for(const [k,v] of buildStatLines()){
    const div = document.createElement("div");
    div.className = "statLine";
    div.innerHTML = `<div class="statKey">${escapeHtml(k)}</div><div class="statVal">${escapeHtml(v)}</div>`;
    host.appendChild(div);
  }
}

/* =========================================================
   Name modal + filter
========================================================= */
const BANNED_WORDS = [
  // Add your own words here later if you want.
  // Keep it short, and don't include slurs.
];

function isNameAllowed(name){
  if(!name) return false;
  const trimmed = name.trim();
  if(trimmed.length < 2) return false;
  if(trimmed.length > 18) return false;

  // Only letters/numbers/spaces
  if(!/^[a-z0-9 ]+$/i.test(trimmed)) return false;

  const low = trimmed.toLowerCase();
  for(const w of BANNED_WORDS){
    if(w && low.includes(w.toLowerCase())) return false;
  }
  return true;
}

function openNameModal(){
  $("nameInput").value = state.character.name || "";
  $("nameModal").classList.remove("hidden");
  setTimeout(()=>$("nameInput").focus(), 30);
}
function closeNameModal(){
  $("nameModal").classList.add("hidden");
}
function saveName(){
  const name = $("nameInput").value.trim();
  if(!isNameAllowed(name)){
    toast("Name not allowed.");
    return;
  }
  state.character.name = name;
  state.character.finalized = true;

  // daily lock
  if(dailyLockEnabled()){
    state.daily.lastBuildDay = todayKeyUTC();
    state.daily.finalizedToday = true;
  }

  saveState();
  closeNameModal();
  refreshUI();
  toast("Saved!");
}

/* =========================================================
   Finalize + New Build buttons
========================================================= */
function canFinalize(){
  const phases = phasesForCharacter();
  const allKeys = phases.map(p=>p.key);

  // require core keys except conditional
  const c = state.character;
  if(!c.race) return false;
  if(!c.power) return false;
  if(!c.weapon) return false;
  if(!c.strength) return false;
  if(!c.durability) return false;
  if(!c.luck) return false;

  // if Demi-human -> must have demi and if werebeast -> werebeastType
  if(c.race === "Demi-human"){
    if(!c.demi) return false;
    if(c.demi === "Werebeast" && !c.werebeastType) return false;
  }

  // must be at the end
  return state.build.phaseIndex >= allKeys.length-1;
}

function finalizeBuild(){
  if(dailyLockEnabled() && state.daily.finalizedToday){
    toast("Daily build already used.");
    return;
  }
  if(!canFinalize()){
    toast("Finish all spins first.");
    return;
  }
  openNameModal();
}

function newBuild(){
  if(dailyLockEnabled() && state.daily.finalizedToday){
    toast("Locked until tomorrow.");
    return;
  }
  const keepProg = state.progress;
  const keepSet = state.settings;
  const keepDaily = state.daily;
  const keepCurrency = state.currency;
  state = defaultState();
  state.progress = keepProg;
  state.settings = keepSet;
  state.daily = keepDaily;
  state.currency = keepCurrency;

  state.build.phaseIndex = 0;
  state.character.finalized = false;
  state.character.name = "";
  state.lastMatch.traitEvent = null;

  saveState();
  setRaceBackground("");
  setPhaseIndex(0);
  $("buildLog").innerHTML = "";
  logBuild("New build started.");
  refreshUI();
}

/* =========================================================
   Skip button (testing)
========================================================= */
function skipPhase(){
  if(state.build.spinning) return;
  if(state.character.finalized){
    toast("Finalized. New build to continue.");
    return;
  }
  // pick random result without spinning
  const ph = currentPhase();
  if(!ph) return;
  const r = ph.options[Math.floor(Math.random()*ph.options.length)];
  onSpinResult(r);
}

/* =========================================================
   Volume toggle
========================================================= */
function toggleVolume(){
  state.settings.muted = !state.settings.muted;
  saveState();
  $("volBtn").textContent = state.settings.muted ? "üîá" : "üîä";
  toast(state.settings.muted ? "Muted" : "Sound on");
}

/* =========================================================
   Reset button (clears everything)
========================================================= */
function hardReset(){
  localStorage.removeItem(STORAGE_KEY);
  state = defaultState();
  saveState();
  location.reload();
}

/* =========================================================
   PvP / PvE Battles (simple, visually readable)
========================================================= */
function cloneChar(c){
  return JSON.parse(JSON.stringify(c));
}

function randomOpponent(){
  // Generate a reasonable opponent build (doesn't use daily lock)
  const opp = defaultState();
  opp.character.race = RACE_OPTIONS[Math.floor(Math.random()*RACE_OPTIONS.length)];

  // if opponent is Demi-human, pick demi + maybe werebeast
  if(opp.character.race === "Demi-human"){
    opp.character.demi = DEMI_TYPES[Math.floor(Math.random()*DEMI_TYPES.length)];
    if(opp.character.demi === "Werebeast"){
      opp.character.werebeastType = WEREBEAST_TYPES[Math.floor(Math.random()*WEREBEAST_TYPES.length)];
      opp.character.demiTraits.push({kind:"werebeast", type: opp.character.werebeastType});
    }else{
      opp.character.demiTraits.push({kind:"demi", type: opp.character.demi});
    }
  }

  opp.character.power = POWER_OPTIONS[Math.floor(Math.random()*POWER_OPTIONS.length)];
  opp.character.weapon = WEAPON_OPTIONS[Math.floor(Math.random()*WEAPON_OPTIONS.length)];
  opp.character.strength = STRENGTH_OPTIONS[Math.floor(Math.random()*STRENGTH_OPTIONS.length)];
  opp.character.durability = DURABILITY_OPTIONS[Math.floor(Math.random()*DURABILITY_OPTIONS.length)];
  opp.character.luck = LUCK_OPTIONS[Math.floor(Math.random()*LUCK_OPTIONS.length)];

  // opponent slot unlocks: scale with your wins so it feels fair-ish
  const w = state.progress.pvpWins || 0;
  opp.progress.pvpWins = Math.max(0, w + (Math.random()<0.5 ? -2 : 2));
  opp.progress.unlockedSlots = {
    head:true,
    arms: opp.progress.pvpWins>=3,
    back: opp.progress.pvpWins>=6,
    legs: opp.progress.pvpWins>=10,
    body: opp.progress.pvpWins>=15
  };

  return opp;
}

function setMatchTraitEvent(obj){
  state.lastMatch.traitEvent = obj;
}

function showStealPopup(trait){
  const el = $("stealPopup");
  el.textContent = `Stolen Trait: ${trait.type}`;
  el.classList.remove("hidden");
  playStealSound();
  setTimeout(()=>el.classList.add("hidden"), 1600);
}

function playStealAnimation(trait){
  const overlay = $("stealAnim");
  const chip = $("stealChip");
  if(!overlay || !chip) return;

  const enemyFrame = $("e_charFrame");
  const playerFrame = $("p_charFrame");

  const eRect = enemyFrame ? enemyFrame.getBoundingClientRect() : null;
  const pRect = playerFrame ? playerFrame.getBoundingClientRect() : null;

  const startX = eRect ? (eRect.left + eRect.width*0.5) : window.innerWidth*0.65;
  const startY = eRect ? (eRect.top + eRect.height*0.35) : window.innerHeight*0.35;

  const endX = pRect ? (pRect.left + pRect.width*0.5) : window.innerWidth*0.35;
  const endY = pRect ? (pRect.top + pRect.height*0.35) : window.innerHeight*0.35;

  chip.textContent = `+ ${trait.type}`;
  chip.style.left = startX + "px";
  chip.style.top  = startY + "px";

  chip.style.setProperty("--dx", endX + "px");
  chip.style.setProperty("--dy", endY + "px");

  overlay.classList.remove("hidden");
  chip.classList.remove("flyNow");
  void chip.offsetWidth;
  chip.classList.add("flyNow");

  setTimeout(()=>{
    overlay.classList.add("hidden");
    chip.classList.remove("flyNow");
  }, 700);
}

function getStealableTraits(attacker, defender){
  const atkSlots = attacker.progress?.unlockedSlots || {};
  const defTraits = defender.character?.demiTraits || [];
  const stealable = [];
  for(const trait of defTraits){
    const slots = slotsForTrait(trait);
    if(slots.length === 0) continue;
    if(slots.every(s => atkSlots[s])) stealable.push(trait);
  }
  return stealable;
}

function markStolenFrom(defender){
  defender.progress ||= {};
  defender.progress.lastStolenAt = Date.now();
  defender.progress.revengeReady = true;
}

function attemptTraitSteal(attacker, defender){
  // defender blocks 1 steal if they have Trait Lock
  if(defender?.progress?.traitLockCharges > 0){
    defender.progress.traitLockCharges -= 1;
    setMatchTraitEvent({ label:"Steal Blocked", note:"Opponent's Trait Lock prevented the steal.", value:"üõ°Ô∏è" });
    toast("Steal blocked by Trait Lock!");
    playBlockSound();
    return false;
  }

  if(Math.random() > TRAIT_STEAL_CHANCE) return false;

  const candidates = getStealableTraits(attacker, defender);
  if(candidates.length === 0) return false;

  const stolen = candidates[Math.floor(Math.random()*candidates.length)];

  defender.character.demiTraits = defender.character.demiTraits.filter(t => t !== stolen);
  attacker.character.demiTraits.push(stolen);

  markStolenFrom(defender);
  setMatchTraitEvent({ label:"Trait Stolen", note:`You stole ${stolen.type}.`, value:"üó°Ô∏è" });

  return stolen;
}

function awardCoins(n, reason="reward"){
  state.currency.coins += n;
}
function grantXP(n, reason="reward"){
  state.currency.xp += n;
}

function applyRevengeBonus(){
  if(!state.progress.revengeReady) return;
  state.progress.revengeReady = false;
  awardCoins(25, "revenge bonus");
  grantXP(18, "revenge bonus");
  toast("REVENGE BONUS! +Coins +XP");
  saveState();
}

function progressSnapshot(){
  const wins = state.progress.pvpWins || 0;
  const next = findClosestLockedSlot();
  if(!next){
    return [{ label:"All slots unlocked", note:"Max trait slots reached.", value:`${wins} wins` }];
  }
  const req = requiredWinsForSlot(next);
  return [
    { label:"PvP Wins", note:"Unlock more trait slots by winning.", value:`${wins}` },
    { label:`Next Slot: ${SLOT_LABEL[next]}`, note:"Progress to unlock.", value:`${Math.min(wins, req)} / ${req}` }
  ];
}

function fillLootRows(hostId, rows){
  const host = $(hostId);
  if(!host) return;
  host.innerHTML = "";
  rows.forEach(r=>{
    const row = document.createElement("div");
    row.className = "lootRow";
    row.innerHTML = `
      <div class="lootLeft">
        <div class="lootLabel">${escapeHtml(r.label || "")}</div>
        <div class="lootNote">${escapeHtml(r.note || "")}</div>
      </div>
      <div class="lootValue">${escapeHtml(r.value || "")}</div>
    `;
    host.appendChild(row);
  });
}

function openLoot(payload){
  $("lootTitle").textContent = payload.outcome === "win" ? "Victory" : "Defeat";
  $("lootSub").textContent = payload.sub || "";
  fillLootRows("lootRewards", payload.rewards || []);
  fillLootRows("lootTrait", payload.traitEvents || []);
  fillLootRows("lootProgress", payload.progress || []);
  $("lootModal").classList.remove("hidden");
}
function closeLoot(){ $("lootModal").classList.add("hidden"); }

/* =========================================================
   Battle simulator (no infinite fights)
========================================================= */
function battleSim(attackerChar, defenderChar, logEl, hpEls){
  // Returns true if attacker wins
  const aStats = finalStats(attackerChar);
  const dStats = finalStats(defenderChar);

  let aHP = 35 + aStats.durability*4;
  let dHP = 35 + dStats.durability*4;

  // anti-infinite: rage timer (damage ramps)
  let rage = 0;

  function dmg(att, def){
    const base = 6 + att.strength*1.4;
    const mit = 0.25 + (def.durability*0.02);
    const luckCrit = (Math.random() < (att.luck*0.012)) ? 1.6 : 1.0;
    const rageBoost = 1 + rage*0.06;

    const raw = base * luckCrit * rageBoost;
    const final = Math.max(2, Math.floor(raw * (1-mit)));
    return final;
  }

  function write(line){
    logEl.innerHTML = `<div>${escapeHtml(line)}</div>` + logEl.innerHTML;
  }

  const maxRounds = 24;
  for(let round=1; round<=maxRounds; round++){
    rage++;

    const aDmg = dmg(aStats, dStats);
    dHP -= aDmg;
    write(`Round ${round}: You hit for ${aDmg}.`);
    hpEls.p.style.width = `${Math.max(0, aHP)/(35 + aStats.durability*4)*100}%`;
    hpEls.e.style.width = `${Math.max(0, dHP)/(35 + dStats.durability*4)*100}%`;
    if(dHP <= 0) return true;

    const dDmg = dmg(dStats, aStats);
    aHP -= dDmg;
    write(`Round ${round}: Enemy hits for ${dDmg}.`);
    hpEls.p.style.width = `${Math.max(0, aHP)/(35 + aStats.durability*4)*100}%`;
    hpEls.e.style.width = `${Math.max(0, dHP)/(35 + dStats.durability*4)*100}%`;
    if(aHP <= 0) return false;
  }

  // If still alive, choose winner by remaining HP (prevents infinite)
  write("Rage timer ended the fight.");
  return aHP >= dHP;
}

/* =========================================================
   PvP win handling (progress bars + unlock checks + steal)
========================================================= */
function onPvpWin(){
  state.progress.pvpWins = (state.progress.pvpWins || 0) + 1;
  saveState();

  renderTraitSlots();
  showPlusOneOnClosestSlot();
  pulseClosestLockedBar();

  checkSlotUnlocks();
}

function onPvpVictory(playerState, enemyState){
  setMatchTraitEvent(null);

  onPvpWin();
  applyRevengeBonus();

  const stolen = attemptTraitSteal(playerState, enemyState);
  if(stolen){
    showStealPopup(stolen);
    playStealAnimation(stolen);
  }

  // rewards (tune anytime)
  awardCoins(20, "pvp");
  grantXP(22, "pvp");

  const rewards = [
    { label:"Coins", note:"Arena rewards", value:`+20 (Total: ${state.currency.coins})` },
    { label:"XP", note:"Battle experience", value:`+22 (Total: ${state.currency.xp})` }
  ];

  const traitEvents = state.lastMatch.traitEvent
    ? [state.lastMatch.traitEvent]
    : [{ label:"None", note:"No trait event this match.", value:"‚Äî" }];

  openLoot({
    outcome: "win",
    sub: "Arena match complete.",
    rewards,
    traitEvents,
    progress: progressSnapshot()
  });

  saveState();
  refreshUI();
}

function onPvpDefeat(){
  setMatchTraitEvent(null);

  awardCoins(6, "loss");
  grantXP(8, "loss");

  openLoot({
    outcome: "lose",
    sub: "You can still progress by fighting again.",
    rewards: [
      { label:"Coins", note:"Consolation", value:`+6 (Total: ${state.currency.coins})` },
      { label:"XP", note:"Consolation", value:`+8 (Total: ${state.currency.xp})` }
    ],
    traitEvents: [{ label:"None", note:"No trait event this match.", value:"‚Äî" }],
    progress: progressSnapshot()
  });

  saveState();
  refreshUI();
}

/* =========================================================
   Tab switching
========================================================= */
document.querySelectorAll(".tab").forEach(t=>{
  t.addEventListener("click", ()=>{
    document.querySelectorAll(".tab").forEach(x=>x.classList.remove("active"));
    t.classList.add("active");
    const key = t.dataset.tab;
    showTab(key);
  });
});

function showTab(key){
  ["build","stats","pve","pvp"].forEach(k=>{
    const sec = document.getElementById(`tab-${k}`);
    if(sec) sec.classList.toggle("hidden", k !== key);
  });
  refreshUI();
}

/* =========================================================
   PvE / PvP start buttons
========================================================= */
$("pvpStartBtn").addEventListener("click", ()=>{
  if(!state.character.finalized){
    toast("Finalize your build first.");
    return;
  }
  const enemy = randomOpponent();

  // Set portraits
  renderPortraitTo(enemy.character, "e_");
  renderPortraitTo(state.character, "p_");

  // role tags
  $("p_roleTag").textContent = state.character.werebeastType ? `Role: ${BEAST_ROLE[state.character.werebeastType] || "‚Äî"}` : "";
  $("e_roleTag").textContent = enemy.character.werebeastType ? `Role: ${BEAST_ROLE[enemy.character.werebeastType] || "‚Äî"}` : "";

  const logEl = $("pvpLog");
  logEl.innerHTML = "";

  // set HP bars full
  $("p_hp").style.width = "100%";
  $("e_hp").style.width = "100%";

  const playerState = { character: state.character, progress: state.progress };
  const enemyState = { character: enemy.character, progress: enemy.progress };

  const won = battleSim(playerState.character, enemyState.character, logEl, {p:$("p_hp"), e:$("e_hp")});
  if(won){
    logEl.innerHTML = `<div><b style="color:var(--good)">YOU WIN</b></div>` + logEl.innerHTML;
    onPvpVictory(playerState, enemyState);
  }else{
    logEl.innerHTML = `<div><b style="color:var(--bad)">YOU LOSE</b></div>` + logEl.innerHTML;
    // If you were stolen-from last time, revengeReady stays until you win.
    onPvpDefeat();
  }
});

$("pveStartBtn").addEventListener("click", ()=>{
  if(!state.character.finalized){
    toast("Finalize your build first.");
    return;
  }
  const enemy = randomOpponent();

  renderPortraitTo(enemy.character, "pve_e_");
  renderPortraitTo(state.character, "pve_p_");

  $("pve_p_roleTag").textContent = state.character.werebeastType ? `Role: ${BEAST_ROLE[state.character.werebeastType] || "‚Äî"}` : "";
  $("pve_e_roleTag").textContent = enemy.character.werebeastType ? `Role: ${BEAST_ROLE[enemy.character.werebeastType] || "‚Äî"}` : "";

  const logEl = $("pveLog");
  logEl.innerHTML = "";

  $("pve_p_hp").style.width = "100%";
  $("pve_e_hp").style.width = "100%";

  const won = battleSim(state.character, enemy.character, logEl, {p:$("pve_p_hp"), e:$("pve_e_hp")});
  if(won){
    logEl.innerHTML = `<div><b style="color:var(--good)">EVENT CLEARED</b> +Coins +XP</div>` + logEl.innerHTML;
    awardCoins(12, "pve");
    grantXP(14, "pve");
    saveState();
    refreshUI();
  }else{
    logEl.innerHTML = `<div><b style="color:var(--bad)">EVENT FAILED</b> (try again)</div>` + logEl.innerHTML;
  }
});

/* =========================================================
   Portrait rendering for other tabs (prefixes)
========================================================= */
function renderPortraitTo(char, prefix){
  // prefix examples: "p_", "e_", "pve_p_", "pve_e_"
  // We map to ids like p_base, but our apply functions use layer_*.
  // So we temporarily render by setting sources manually:
  function set(id, src){
    const el = document.getElementById(prefix + id);
    if(el) el.src = src || "";
  }

  // clear
  ["head","arms","legs","back","body"].forEach(k=>set(k,""));
  set("fx","");

  // base
  const rig = RACE_RIG[char.race] || "humanoid";
  if(rig === "golem_big" || rig === "giant_big"){
    set("base", RACE_BASE_IMAGE[char.race] || "");
    // big overlays
    const root = BIG_RIG_OVERLAY_PATH[char.race] || "";
    for(const slot of BIG_RIG_SLOTS){
      set(slot, root ? `${root}/${slot}/default.png` : "");
    }
  }else if(rig === "special_humanoid"){
    set("base", getSpecialHumanoidBase(char.race));
  }else if(rig === "dragon_animal"){
    set("base", "assets/bases/dragon/base.png");
  }else{
    set("base", getHumanoidBaseForRace(char.race));
    // apply traits overlays (newest wins)
    const slotSrc = {};
    const traits = Array.isArray(char.demiTraits) ? char.demiTraits : [];
    for(const t of traits){
      if(t.kind === "werebeast"){
        const key = t.type.toLowerCase().replaceAll(" ", "_");
        const slots = WEREBEAST_SLOTS[t.type] || [];
        for(const s of slots) slotSrc[s] = `assets/overlays/werebeast/${key}/${s}.png`;
      }
      if(t.kind === "demi"){
        const key = t.type.toLowerCase().replaceAll(" ", "_");
        const slots = DEMI_SLOTS[t.type] || [];
        for(const s of slots) slotSrc[s] = `assets/overlays/demi/${key}/${s}.png`;
      }
    }
    for(const s of Object.keys(slotSrc)){
      set(s, slotSrc[s]);
    }
  }

  // fx
  const beast = char.werebeastType;
  if(beast && BEAST_FX[beast]){
    set("fx", BEAST_FX[beast]);
    const fxEl = document.getElementById(prefix+"fx");
    if(fxEl) fxEl.classList.add("on");
  }else{
    const fxEl = document.getElementById(prefix+"fx");
    if(fxEl) fxEl.classList.remove("on");
  }
}

/* =========================================================
   Refresh UI
========================================================= */
function refreshUI(){
  updateDailyLock();

  // buttons
  $("volBtn").textContent = state.settings.muted ? "üîá" : "üîä";

  // build stats
  renderBuildStats();

  // trait slots
  renderTraitSlots();

  // phase tag
  const ph = currentPhase();
  $("phaseTag").textContent = `Phase: ${ph.label}`;
  $("wheelTitle").textContent = ph.label;

  // finalize button enabled?
  $("finalizeBtn").style.opacity = canFinalize() ? "1" : ".65";

  // disable spin if finalized or locked
  const locked = (dailyLockEnabled() && state.daily.finalizedToday) || state.character.finalized || state.build.spinning;
  $("spinBtn").style.opacity = locked ? ".55" : "1";
  $("spinBtn").style.pointerEvents = locked ? "none" : "auto";

  // background
  setRaceBackground(state.character.race || "");

  // portrait in build
  applyRaceBase(state.character, "");
  applyRigFraming(state.character, "charFrame");
  applyDemiTraits(state.character, "");
  applyIdleFx(state.character, "");

  // stats tab: copy portrait & values
  applyRaceBase(state.character, "s_");
  applyRigFraming(state.character, "statsCharFrame");
  applyDemiTraits(state.character, "s_");
  applyIdleFx(state.character, "s_");

  // stats lists
  const statsHost = $("statsList");
  const finalHost = $("finalStatsList");
  const c = state.character;

  if(statsHost){
    statsHost.innerHTML = "";
    const core = [
      ["Name", c.name || "‚Äî"],
      ["Race", c.race || "‚Äî"],
      ["Demi", c.demi || "‚Äî"],
      ["Werebeast", c.werebeastType || "‚Äî"],
      ["Power", c.power || "‚Äî"],
      ["Weapon", c.weapon || "‚Äî"],
      ["Trait Slots", `${Object.values(state.progress.unlockedSlots).filter(Boolean).length}/5 unlocked`],
      ["PvP Wins", String(state.progress.pvpWins || 0)]
    ];
    core.forEach(([k,v])=>{
      const div = document.createElement("div");
      div.className = "statLine";
      div.innerHTML = `<div class="statKey">${escapeHtml(k)}</div><div class="statVal">${escapeHtml(v)}</div>`;
      statsHost.appendChild(div);
    });
  }

  if(finalHost){
    finalHost.innerHTML = "";
    const fs = finalStats(c);
    Object.entries(fs).forEach(([k,v])=>{
      const div = document.createElement("div");
      div.className = "statLine";
      div.innerHTML = `<div class="statKey">${escapeHtml(k.toUpperCase())}</div><div class="statVal">${escapeHtml(v)}</div>`;
      finalHost.appendChild(div);
    });
  }

  $("namedTag").textContent = c.finalized ? "Finalized" : "Not finalized";

  // hint
  if(state.character.finalized){
    $("buildHint").textContent = "Build finalized. Start a new build to spin again.";
  }

  // skip button (only in test mode)
  $("skipBtn").style.display = TEST_MODE ? "inline-flex" : "none";
  $("testFastBtn").style.display = TEST_MODE ? "inline-flex" : "none";
  $("newBuildBtn").style.display = (dailyLockEnabled() && state.daily.finalizedToday) ? "none" : "inline-flex";
}

/* =========================================================
   Save / Load
========================================================= */
function saveState(){
  localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
}
function loadState(){
  const raw = localStorage.getItem(STORAGE_KEY);
  if(!raw) return defaultState();
  try{
    const s = JSON.parse(raw);
    // shallow patch missing keys
    const d = defaultState();
    return deepMerge(d, s);
  }catch(e){
    return defaultState();
  }
}
function deepMerge(base, extra){
  if(typeof base !== "object" || base === null) return extra;
  const out = Array.isArray(base) ? [...base] : {...base};
  if(typeof extra !== "object" || extra === null) return out;
  for(const k of Object.keys(extra)){
    if(k in out){
      out[k] = deepMerge(out[k], extra[k]);
    }else{
      out[k] = extra[k];
    }
  }
  return out;
}

/* =========================================================
   Bind UI events
========================================================= */
$("spinBtn").addEventListener("click", ()=>startSpin(false));
$("testFastBtn").addEventListener("click", ()=>startSpin(true));
$("skipBtn").addEventListener("click", skipPhase);
$("finalizeBtn").addEventListener("click", finalizeBuild);
$("newBuildBtn").addEventListener("click", newBuild);
$("volBtn").addEventListener("click", toggleVolume);
$("resetBtn").addEventListener("click", hardReset);

/* =========================================================
   Init
========================================================= */
function init(){
  updateDailyLock();

  // If daily lock enabled, reset daily flag when day changes
  const tk = todayKeyUTC();
  if(state.daily.lastBuildDay !== tk){
    state.daily.lastBuildDay = tk;
    state.daily.finalizedToday = false;
    saveState();
  }

  // restore phase/wheel
  const phases = phasesForCharacter();
  state.build.phaseIndex = Math.min(state.build.phaseIndex || 0, phases.length-1);
  setPhaseIndex(state.build.phaseIndex);

  // restore background
  setRaceBackground(state.character.race || "");

  // show log
  if(!$("buildLog").innerHTML){
    logBuild("Loaded.");
  }

  refreshUI();
  drawWheel();
  requestAnimationFrame(stepWheel);
}

init();
</script>
</body>
</html>
