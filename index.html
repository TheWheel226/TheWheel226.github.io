
<!-- âœ… PART 1 / 6 â€” index.html (start + <head> + CSS base) -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Wheel Forge</title>
  <style>
    :root{
      --bg:#0b0f17;
      --panel:#121a28;
      --panel2:#0f1623;
      --text:#e8eefc;
      --muted:rgba(232,238,252,.65);
      --good:#2ee59d;
      --bad:#ff4d6d;
      --warn:#ffcc66;
      --line:rgba(255,255,255,.10);
      --accent:#7aa8ff;
      --cursed:#ff2e55;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
      color:var(--text);
      background:var(--bg);
      overflow-x:hidden;
    }
    #bgImage{
      position:fixed; inset:0;
      background-size:cover;
      background-position:center;
      filter:saturate(1.05) contrast(1.05) brightness(.55);
      transform:scale(1.03);
      z-index:-2;
    }
    #bgShade{
      position:fixed; inset:0;
      background:radial-gradient(1000px 600px at 30% 10%, rgba(122,168,255,.25), transparent 60%),
                 linear-gradient(to bottom, rgba(0,0,0,.25), rgba(0,0,0,.75));
      z-index:-1;
    }
    .app{
      max-width:1120px;
      margin:0 auto;
      padding:18px 14px 80px;
    }
    header{
      display:flex; gap:10px; align-items:center; justify-content:space-between;
      padding:10px 12px;
      border:1px solid var(--line);
      background:rgba(18,26,40,.72);
      backdrop-filter: blur(10px);
      border-radius:14px;
    }
    .title{display:flex; flex-direction:column; line-height:1.1;}
    .title b{font-size:18px; letter-spacing:.2px}
    .title span{font-size:12px; color:var(--muted)}
    .pillRow{display:flex; gap:10px; align-items:center}
    .pill{
      font-size:12px;
      border:1px solid var(--line);
      padding:6px 10px;
      border-radius:999px;
      background:rgba(15,22,35,.85);
      color:var(--muted);
      white-space:nowrap;
    }
    .pill strong{color:var(--text)}
    .btn{
      border:1px solid var(--line);
      background:rgba(15,22,35,.85);
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      user-select:none;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:8px;
      font-weight:800;
      transition:transform .08s ease, filter .08s ease, opacity .15s ease;
    }
    .btn:active{transform:scale(.985)}
    .btn.primary{background:linear-gradient(135deg, rgba(122,168,255,.25), rgba(122,168,255,.06)); border-color:rgba(122,168,255,.35)}
    .btn.good{background:linear-gradient(135deg, rgba(46,229,157,.18), rgba(46,229,157,.06)); border-color:rgba(46,229,157,.35)}
    .btn.bad{background:linear-gradient(135deg, rgba(255,77,109,.20), rgba(255,77,109,.06)); border-color:rgba(255,77,109,.35)}
    .btn.ghost{background:transparent}
    .row{display:flex; gap:12px; flex-wrap:wrap}
    .grid{
      display:grid;
      grid-template-columns: 1.25fr .9fr;
      gap:12px;
      margin-top:12px;
    }
    @media (max-width:980px){ .grid{grid-template-columns:1fr} }
    .card{
      border:1px solid var(--line);
      background:rgba(18,26,40,.72);
      backdrop-filter: blur(10px);
      border-radius:16px;
      padding:12px;
    }
    .card h2{
      margin:0 0 8px;
      font-size:15px;
      letter-spacing:.2px;
      color:rgba(232,238,252,.92);
    }
    .muted{color:var(--muted)}
    .tabs{display:flex; gap:10px; flex-wrap:wrap; margin-top:12px;}
    .tab{
      padding:9px 12px;
      border-radius:999px;
      border:1px solid var(--line);
      background:rgba(15,22,35,.65);
      cursor:pointer;
      font-weight:900;
      font-size:12px;
      color:rgba(232,238,252,.72);
    }
    .tab.active{
      color:var(--text);
      border-color:rgba(122,168,255,.45);
      background:rgba(122,168,255,.14);
    }
    .hidden{display:none !important;}
  </style>
</head>
<!-- âœ… PART 2 / 6 â€” <body> + UI CSS (portraits, stats, modals, animations) -->
<body>
  <div id="bgImage"></div>
  <div id="bgShade"></div>

  <div class="app">
    <header>
      <div class="title">
        <b>Wheel Forge</b>
        <span class="muted">Build â€¢ Stats â€¢ PvE â€¢ PvP</span>
      </div>
      <div class="pillRow">
        <div id="dailyPill" class="pill">Daily Build: <strong>â€¦</strong></div>
        <button id="volBtn" class="btn">ðŸ”Š</button>
        <button id="resetBtn" class="btn ghost">Reset</button>
      </div>
    </header>

    <div class="tabs">
      <div class="tab active" data-tab="build">BUILD</div>
      <div class="tab" data-tab="stats">STATS</div>
      <div class="tab" data-tab="pve">PvE</div>
      <div class="tab" data-tab="pvp">PvP</div>
      <div id="phaseTag" class="pill">Phase: â€¦</div>
      <div id="namedTag" class="pill">Not finalized</div>
    </div>

    <style>
      .portraitWrap{display:flex; gap:12px; align-items:flex-start; flex-wrap:wrap}
      .frame{
        position:relative; width:260px; height:260px;
        border-radius:18px; border:1px solid var(--line);
        background:rgba(15,22,35,.65); overflow:hidden;
      }
      .frame.bigRig{width:300px;height:300px}
      .frame.cursed{box-shadow:0 0 0 2px rgba(255,46,85,.22), 0 0 36px rgba(255,46,85,.25) inset}
      .layer{position:absolute; inset:0; width:100%; height:100%; object-fit:contain; pointer-events:none;}
      .fx{mix-blend-mode:screen; opacity:.92}
      .idle-sway{animation:sway 3.0s ease-in-out infinite}
      @keyframes sway{0%,100%{transform:translateY(0)}50%{transform:translateY(4px)}}

      #wheelBox{display:flex; flex-direction:column; gap:10px}
      #wheelTitle{font-size:16px; font-weight:1000}
      #wheelHint{font-size:12px; color:var(--muted)}
      canvas{width:100%; max-width:520px; height:auto; border-radius:16px; border:1px solid var(--line); background:rgba(0,0,0,.15)}
      .btnRow{display:flex; gap:10px; flex-wrap:wrap}

      .statList{display:grid; gap:8px}
      .statLine{
        display:flex; justify-content:space-between; gap:10px;
        padding:10px 10px; border-radius:12px;
        border:1px solid var(--line);
        background:rgba(15,22,35,.55);
      }
      .statKey{color:rgba(232,238,252,.70); font-weight:900}
      .statVal{color:rgba(232,238,252,.95); font-weight:1000; text-align:right}

      .badgeRow{display:flex; gap:8px; flex-wrap:wrap; margin-top:8px}
      .badge{
        display:inline-flex; gap:8px; align-items:center;
        padding:6px 10px; border-radius:999px;
        border:1px solid var(--line);
        background:rgba(15,22,35,.65);
        font-size:12px; font-weight:1000;
      }

      .slotsGrid{display:grid; grid-template-columns:repeat(2, minmax(0, 1fr)); gap:10px}
      @media (max-width:520px){.slotsGrid{grid-template-columns:1fr}}
      .slotCard{
        border:1px solid var(--line);
        background:rgba(15,22,35,.55);
        border-radius:14px;
        padding:10px;
        position:relative;
      }
      .slotLocked{opacity:.82}
      .closestSlot{outline:2px solid rgba(122,168,255,.30)}
      .slotTop{display:flex; justify-content:space-between; align-items:center}
      .slotName{font-weight:1100}
      .slotDesc{margin-top:6px; color:rgba(232,238,252,.72); font-size:12px}
      .slotProgressWrap{
        margin-top:10px; height:8px;
        background:rgba(255,255,255,.08);
        border-radius:999px; overflow:hidden;
      }
      .slotProgressBar{
        height:100%;
        background:linear-gradient(90deg, rgba(122,168,255,.65), rgba(122,168,255,.20));
        width:0%;
      }
      .slotProgressText{margin-top:6px; font-size:12px; color:rgba(232,238,252,.65)}
      .plusOne{
        position:absolute; right:10px; bottom:10px;
        font-weight:1100; color:var(--good);
        animation:floatUp .65s ease-out 1;
      }
      @keyframes floatUp{0%{transform:translateY(0); opacity:1}100%{transform:translateY(-14px); opacity:0}}

      #toast{
        position:fixed; left:50%; bottom:18px;
        transform:translateX(-50%);
        background:rgba(10,15,25,.92);
        border:1px solid var(--line);
        padding:10px 12px; border-radius:999px;
        opacity:0; pointer-events:none;
        transition:opacity .18s ease;
        font-weight:1000; z-index:50;
      }
      #toast.show{opacity:1}

      .modal{
        position:fixed; inset:0;
        display:flex; align-items:center; justify-content:center;
        background:rgba(0,0,0,.55);
        z-index:60; padding:18px;
      }
      .modal.hidden{display:none}
      .modalCard{
        width:min(520px, 100%);
        border-radius:16px; border:1px solid var(--line);
        background:rgba(18,26,40,.95);
        padding:14px;
      }
      .modalTop{display:flex; justify-content:space-between; align-items:center; gap:12px}
      .modalTitle{font-weight:1100; font-size:16px}
      .modalSub{color:rgba(232,238,252,.70); font-size:12px; margin-top:6px}
      .modalBtns{display:flex; gap:10px; margin-top:12px; flex-wrap:wrap}

      .lootRow{
        display:flex; justify-content:space-between; gap:12px;
        padding:10px;
        border:1px solid var(--line);
        background:rgba(15,22,35,.55);
        border-radius:12px;
        margin-top:10px;
      }
      .lootLabel{font-weight:1100}
      .lootNote{font-size:12px; color:rgba(232,238,252,.65)}
      .lootValue{font-weight:1100}

      #stealAnim{position:fixed; inset:0; pointer-events:none; z-index:90;}
      #stealAnim.hidden{display:none}
      #stealChip{
        position:fixed;
        padding:10px 12px;
        border-radius:999px;
        border:1px solid rgba(255,255,255,.18);
        background:rgba(10,15,25,.92);
        font-weight:1100;
        opacity:0;
        transform:translate(-50%,-50%);
      }
      #stealChip.flyNow{opacity:1; animation:fly .65s ease-out forwards;}
      @keyframes fly{ to{ left:var(--dx); top:var(--dy); opacity:0; transform:translate(-50%,-50%) scale(.9);} }

      #stealPopup{
        position:fixed; top:12px; left:50%;
        transform:translateX(-50%);
        z-index:95;
        padding:10px 12px;
        border-radius:999px;
        border:1px solid rgba(255,255,255,.18);
        background:rgba(10,15,25,.92);
        font-weight:1100;
      }
      #stealPopup.hidden{display:none}
    </style>
    <!-- âœ… PART 3 / 6 â€” BUILD tab + wheel + portrait + trait slots -->
    <section id="tab-build" class="grid">
      <div class="card" id="wheelBox">
        <div>
          <div id="wheelTitle">Wheel</div>
          <div id="wheelHint">Spin to begin</div>
        </div>

        <canvas id="wheel" width="520" height="520"></canvas>

        <div class="btnRow">
          <button id="spinBtn" class="btn primary">Spin</button>
          <button id="finalizeBtn" class="btn good">Finalize</button>
          <button id="newBuildBtn" class="btn">New Build</button>
          <button id="skipBtn" class="btn ghost">Skip Phase</button>
          <button id="testFastBtn" class="btn ghost">Fast Spin</button>
        </div>

        <div class="muted" id="buildHint">Spin the wheel. It will auto-advance phases.</div>

        <div class="card" style="padding:12px; background:rgba(15,22,35,.45); border-color:rgba(255,255,255,.08)">
          <h2>Build Log</h2>
          <div id="buildLog" class="muted"></div>
        </div>
      </div>

      <div class="card">
        <h2>Character</h2>
        <div class="portraitWrap">
          <div id="charFrame" class="frame idle-sway">
            <img id="layer_base" class="layer" alt="">
            <img id="layer_body" class="layer" alt="">
            <img id="layer_back" class="layer" alt="">
            <img id="layer_legs" class="layer" alt="">
            <img id="layer_arms" class="layer" alt="">
            <img id="layer_head" class="layer" alt="">
            <img id="layer_armor" class="layer" alt="">
            <img id="layer_weapon" class="layer" alt="">
            <img id="layer_fx" class="layer fx" alt="">
          </div>

          <div style="flex:1; min-width:260px">
            <h2>Build Stats</h2>
            <div id="buildStats" class="statList"></div>
            <div id="buildBadges" class="badgeRow"></div>

            <h2 style="margin-top:12px">Trait Slots</h2>
            <div id="traitSlots" class="slotsGrid"></div>
          </div>
        </div>
      </div>
    </section>
   <!-- âœ… PART 4 / 6 â€” STATS + PvE + PvP + GRAVEYARD tabs + core JS (roster, save, tabs, wheel) -->

<!-- STATS TAB -->
<section id="tab-stats" class="grid hidden">
  <div class="card">
    <h2>Active Character</h2>
    <div class="muted" style="margin-bottom:8px">
      This shows the currently selected living character.
    </div>
    <div id="statsList" class="statList"></div>
  </div>

  <div class="card">
    <h2>Final Stats</h2>
    <div class="muted" style="margin-bottom:8px">
      Final stats are additive (race + powers + weapons + armor + mastery + transformation + permanent bonuses).
    </div>
    <div id="finalStatsList" class="statList"></div>
  </div>
</section>

<!-- PVE TAB -->
<section id="tab-pve" class="grid hidden">
  <div class="card">
    <h2>PvE Event</h2>
    <div class="muted" style="margin-bottom:10px">
      PvE loss = +1 injury. 3 injuries = permanent death.
    </div>
    <button id="pveStartBtn" class="btn primary">Start PvE</button>

    <div class="card" style="margin-top:12px; padding:12px; background:rgba(15,22,35,.45); border-color:rgba(255,255,255,.08)">
      <h2>Combat Log</h2>
      <div id="pveLog" class="muted"></div>
    </div>
  </div>

  <div class="card">
    <h2>Battle</h2>

    <div class="portraitWrap">
      <div style="min-width:260px">
        <div class="badgeRow">
          <div class="badge"><span class="icon">ðŸ§‘</span><span id="pve_p_roleTag">You</span></div>
          <div class="badge"><span class="icon">ðŸ©¹</span><span id="pve_injuryTag">Injuries: 0/3</span></div>
        </div>
        <div id="pve_p_charFrame" class="frame idle-sway">
          <img id="pve_p_layer_base" class="layer" alt="">
          <img id="pve_p_layer_body" class="layer" alt="">
          <img id="pve_p_layer_back" class="layer" alt="">
          <img id="pve_p_layer_legs" class="layer" alt="">
          <img id="pve_p_layer_arms" class="layer" alt="">
          <img id="pve_p_layer_head" class="layer" alt="">
          <img id="pve_p_layer_armor" class="layer" alt="">
          <img id="pve_p_layer_weapon" class="layer" alt="">
          <img id="pve_p_layer_fx" class="layer fx" alt="">
        </div>
        <div class="slotProgressWrap" style="margin-top:10px">
          <div id="pve_p_hp" class="slotProgressBar" style="width:100%"></div>
        </div>
        <div class="muted" style="margin-top:6px">HP</div>
      </div>

      <div style="min-width:260px">
        <div class="badgeRow">
          <div class="badge"><span class="icon">ðŸ‘¹</span><span id="pve_e_roleTag">Enemy</span></div>
        </div>
        <div id="pve_e_charFrame" class="frame idle-sway">
          <img id="pve_e_layer_base" class="layer" alt="">
          <img id="pve_e_layer_body" class="layer" alt="">
          <img id="pve_e_layer_back" class="layer" alt="">
          <img id="pve_e_layer_legs" class="layer" alt="">
          <img id="pve_e_layer_arms" class="layer" alt="">
          <img id="pve_e_layer_head" class="layer" alt="">
          <img id="pve_e_layer_armor" class="layer" alt="">
          <img id="pve_e_layer_weapon" class="layer" alt="">
          <img id="pve_e_layer_fx" class="layer fx" alt="">
        </div>
        <div class="slotProgressWrap" style="margin-top:10px">
          <div id="pve_e_hp" class="slotProgressBar" style="width:100%"></div>
        </div>
        <div class="muted" style="margin-top:6px">HP</div>
      </div>
    </div>
  </div>
</section>

<!-- PVP TAB -->
<section id="tab-pvp" class="grid hidden">
  <div class="card">
    <h2>PvP Match</h2>
    <div class="muted" style="margin-bottom:10px">
      PvP loss = +2 injuries. 3 injuries = permanent death.
    </div>
    <button id="pvpStartBtn" class="btn primary">Start PvP</button>

    <div class="card" style="margin-top:12px; padding:12px; background:rgba(15,22,35,.45); border-color:rgba(255,255,255,.08)">
      <h2>Combat Log</h2>
      <div id="pvpLog" class="muted"></div>
    </div>
  </div>

  <div class="card">
    <h2>Battle</h2>

    <div class="portraitWrap">
      <div style="min-width:260px">
        <div class="badgeRow">
          <div class="badge"><span class="icon">ðŸ§‘</span><span id="p_roleTag">You</span></div>
          <div class="badge"><span class="icon">ðŸ©¹</span><span id="pvp_injuryTag">Injuries: 0/3</span></div>
        </div>
        <div id="p_charFrame" class="frame idle-sway">
          <img id="p_layer_base" class="layer" alt="">
          <img id="p_layer_body" class="layer" alt="">
          <img id="p_layer_back" class="layer" alt="">
          <img id="p_layer_legs" class="layer" alt="">
          <img id="p_layer_arms" class="layer" alt="">
          <img id="p_layer_head" class="layer" alt="">
          <img id="p_layer_armor" class="layer" alt="">
          <img id="p_layer_weapon" class="layer" alt="">
          <img id="p_layer_fx" class="layer fx" alt="">
        </div>
        <div class="slotProgressWrap" style="margin-top:10px">
          <div id="p_hp" class="slotProgressBar" style="width:100%"></div>
        </div>
        <div class="muted" style="margin-top:6px">HP</div>
      </div>

      <div style="min-width:260px">
        <div class="badgeRow">
          <div class="badge"><span class="icon">ðŸ‘¹</span><span id="e_roleTag">Opponent</span></div>
        </div>
        <div id="e_charFrame" class="frame idle-sway">
          <img id="e_layer_base" class="layer" alt="">
          <img id="e_layer_body" class="layer" alt="">
          <img id="e_layer_back" class="layer" alt="">
          <img id="e_layer_legs" class="layer" alt="">
          <img id="e_layer_arms" class="layer" alt="">
          <img id="e_layer_head" class="layer" alt="">
          <img id="e_layer_armor" class="layer" alt="">
          <img id="e_layer_weapon" class="layer" alt="">
          <img id="e_layer_fx" class="layer fx" alt="">
        </div>
        <div class="slotProgressWrap" style="margin-top:10px">
          <div id="e_hp" class="slotProgressBar" style="width:100%"></div>
        </div>
        <div class="muted" style="margin-top:6px">HP</div>
      </div>
    </div>
  </div>
</section>

<!-- GRAVEYARD TAB -->
<section id="tab-grave" class="grid hidden">
  <div class="card">
    <h2>Graveyard</h2>
    <div class="muted" style="margin-bottom:10px">
      Dead characters are permanent. You can still view their final build here.
    </div>
    <div id="graveList" class="statList"></div>
  </div>

  <div class="card">
    <h2>Selected Grave</h2>
    <div class="muted" style="margin-bottom:10px">
      Tap a grave entry to view details.
    </div>
    <div id="graveDetail" class="statList"></div>
  </div>
</section>

<!-- Toast + Modals + Steal FX -->
<div id="toast"></div>

<div id="stealAnim" class="hidden">
  <div id="stealChip"></div>
</div>
<div id="stealPopup" class="hidden"></div>

<div id="lootModal" class="modal hidden">
  <div class="modalCard">
    <div class="modalTop">
      <div>
        <div id="lootTitle" class="modalTitle">Victory</div>
        <div id="lootSub" class="modalSub"></div>
      </div>
      <button class="btn ghost" id="lootCloseBtn">âœ–</button>
    </div>

    <h2 style="margin-top:12px">Rewards</h2>
    <div id="lootRewards"></div>

    <h2 style="margin-top:12px">Trait Events</h2>
    <div id="lootTrait"></div>

    <h2 style="margin-top:12px">Progress</h2>
    <div id="lootProgress"></div>

    <div class="modalBtns">
      <button class="btn good" id="lootOkBtn">OK</button>
    </div>
  </div>
</div>

<div id="choiceModal" class="modal hidden">
  <div class="modalCard">
    <div class="modalTop">
      <div>
        <div id="choiceTitle" class="modalTitle">Choose</div>
        <div id="choiceSub" class="modalSub"></div>
      </div>
      <button class="btn ghost" id="choiceCloseBtn">âœ–</button>
    </div>
    <div id="choiceBtns" class="modalBtns"></div>
  </div>
</div>

<script>
/* =========================
   CORE HELPERS
========================= */
const $ = (id)=>document.getElementById(id);
function escapeHtml(s){
  return String(s ?? "").replace(/[&<>"']/g, m=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[m]));
}
let _toastTimer=null;
function toast(msg){
  const t = $("toast");
  if(!t) return;
  t.textContent = msg;
  t.classList.add("show");
  clearTimeout(_toastTimer);
  _toastTimer=setTimeout(()=>t.classList.remove("show"), 1400);
}

/* =========================
   CONSTANTS
========================= */
const MAX_INJURIES = 3;
const PVE_LOSS_INJURY = 1;
const PVP_LOSS_INJURY = 2;

/* FIXED RACE LIST */
const RACE_OPTIONS = [
  "Gnome","Goblin","Zombie","Skeleton","Human","Orc","Cyborg","Giant","Demi human","Golem",
  "Dragon","Vampire","Hivemind","Shinigami","Soul eater","Demon","Alien","God","Hybrid"
];

const POWER_OPTIONS = [
  "No Power","Adaptation","Regeneration","Gravity Manipulation","Time Manipulation","Telekinesis",
  "Teleportation","Fire","Ice Manipulation","Lightning","Weapon Creation","Heavenly Restriction",
  "Immortal","Rinnegan"
];
const WEAPON_OPTIONS = [
  "No Weapon","Sword","Scythe","Axe","Hammer","Spear","Brass Knuckles","Blades of Chaos","Samehada",
  "Uzumaki Chains","Infinity Gauntlet","Green Lantern Ring"
];
const ARMOR_OPTIONS = [
  "No Armor","Berserk Armor","Iron Man Suit","Jauger","Symbiote","Ashborn's Armor","Rock Lee Weights","Goku's Gi"
];
const CLAN_OPTIONS = ["No Clan","Uchiha","Gojo","D Clan","Kamado"];
const TRAINER_OPTIONS = ["No Trainer","Master Roshi","Jiraiya","Hisoka","Korro","Yuujirou"];
const POWER_MASTERY_OPTIONS = ["None","Dormant","Awakening","Controlled","Mastered","Planetary","Cosmic","Universal","Omnipotent"];

const TRANSFORM_OPTIONS = ["None","Kaioken","Eight Gates","Super Saiyan","Titan Transformation","Tailed Beast"];
const KAIOKEN_OPTIONS = ["X2","X3","X4","X5","X10","X20","X50","X100"];
const GATES_OPTIONS = ["First Gate","Second Gate","Third Gate","Fourth Gate","Fifth Gate","Sixth Gate","Seventh Gate","Eighth Gate"];
const SAIYAN_FORM_OPTIONS = ["SSJ1","SSJ2","SSJ3","SSG","SSB","UI"];
const TITAN_TYPE_OPTIONS = ["Pure Titan","Armored Titan","Attack Titan","Beast Titan","Founding Titan"];
const TAILED_BEAST_OPTIONS = ["1 Tail","2 Tails","3 Tails","4 Tails","5 Tails","6 Tails","7 Tails","8 Tails","9 Tails"];

/* Words that show to user (numbers under the hood) */
const STRENGTH_WORDS = ["Weak","Average","Strong","City","Mountain","Country","Planet","Star","Galaxy","Universal","???"];
const SPEED_WORDS    = ["Slow","Average","Fast","Mach","Lightning","Light","FTL","Galaxy","Universal","???"];
const DUR_WORDS      = ["Fragile","Average","Tough","Steel","City","Mountain","Country","Planet","Star","Universal","???"];
const FIGHT_WORDS    = ["Clumsy","Average","Trained","Elite","Master","Legendary","Mythic","Universal","???"];
const IQ_WORDS       = ["Low","Average","Smart","Genius","Supergenius","Cosmic","Universal","???"];

/* =========================
   STATE + SAVE (ROSTER)
========================= */
const STORAGE_KEY = "wheel_forge_state_v2_roster";

function makeCharacter(){
  const id = "c_" + Math.random().toString(16).slice(2) + "_" + Date.now().toString(16);
  return {
    id,
    createdAt: Date.now(),
    name:"",
    dead:false,
    injuries:0,

    // build content
    race:null,
    powers:[],
    weapons:[],
    armors:[],
    clan:"No Clan",
    trainer:"No Trainer",
    powerMastery:"None",
    transformation:"None",
    transformDetail:null,

    strengthW:"Average",
    speedW:"Average",
    durabilityW:"Average",
    fightW:"Average",
    iqW:"Average",
    luckW:"5",

    // lock spin once race chosen (no redo)
    raceLocked:false
  };
}

function defaultState(){
  return {
    roster: [],
    activeId: null,
    graveyard: [],
    progress:{
      pvpWins:0,
      soulsCaptured:0,
      soulBonus:{ strength:0, speed:0, durability:0, fight:0, iq:0 },
      adaptationStacks:0,
      lastStolenAt:0
    },
    currency:{ coins:0, xp:0 },
    settings:{ sound:true },
    ui:{ activeTab:"build", graveSelectedId:null }
  };
}

let state = defaultState();

function saveState(){
  localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
}

function loadState(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(!raw) return;
    const parsed = JSON.parse(raw);
    state = { ...defaultState(), ...parsed };

    state.progress = { ...defaultState().progress, ...(parsed.progress||{}) };
    state.currency = { ...defaultState().currency, ...(parsed.currency||{}) };
    state.settings = { ...defaultState().settings, ...(parsed.settings||{}) };
    state.ui       = { ...defaultState().ui, ...(parsed.ui||{}) };

    state.roster = Array.isArray(parsed.roster) ? parsed.roster : [];
    state.graveyard = Array.isArray(parsed.graveyard) ? parsed.graveyard : [];
  }catch(e){}
}

loadState();

/* MIGRATE: if someone still has an old single-character save in memory, preserve it */
(function migrateLegacyIfNeeded(){
  if(state.roster.length > 0) return;

  // If old key exists, try to pull it in
  const oldRaw = localStorage.getItem("wheel_forge_state_v1");
  if(!oldRaw) return;

  try{
    const old = JSON.parse(oldRaw);
    if(old && old.character){
      const c = makeCharacter();
      // best-effort copy
      Object.assign(c, old.character);
      c.id = "legacy_" + c.id;
      c.dead = false;
      c.injuries = 0;
      c.raceLocked = !!c.race;
      state.roster.push(c);
      state.activeId = c.id;

      // carry progress/currency/settings if present
      if(old.progress) state.progress = { ...state.progress, ...old.progress };
      if(old.currency) state.currency = { ...state.currency, ...old.currency };
      if(old.settings) state.settings = { ...state.settings, ...old.settings };

      saveState();
    }
  }catch(e){}
})();

/* =========================
   ROSTER HELPERS
========================= */
function getActive(){
  return state.roster.find(x=>x.id===state.activeId) || null;
}
function setActive(id){
  const found = state.roster.find(x=>x.id===id && !x.dead);
  if(!found) return false;
  state.activeId = id;
  saveState();
  return true;
}
function ensureActiveLiving(){
  let a = getActive();
  if(a && !a.dead) return a;

  const living = state.roster.find(x=>!x.dead);
  if(living){
    state.activeId = living.id;
    saveState();
    return living;
  }
  return null;
}

function addNewCharacterAndActivate(){
  const c = makeCharacter();
  state.roster.push(c);
  state.activeId = c.id;
  saveState();
  return c;
}

/* =========================
   TABS (now includes GRAVEYARD)
========================= */
function showTab(key){
  const keys = ["build","stats","pve","pvp","grave"];
  keys.forEach(k=>{
    $("tab-"+k)?.classList.toggle("hidden", k!==key);
    document.querySelector(`.tab[data-tab="${k}"]`)?.classList.toggle("active", k===key);
  });
  state.ui.activeTab = key;
  saveState();
}

/* Add Graveyard tab button (inject into existing tab bar) */
(function injectGraveTab(){
  const tabsRow = document.querySelector(".tabs");
  if(!tabsRow) return;

  // avoid duplicates
  if(document.querySelector('.tab[data-tab="grave"]')) return;

  const btn = document.createElement("div");
  btn.className = "tab";
  btn.dataset.tab = "grave";
  btn.textContent = "GRAVE";
  tabsRow.insertBefore(btn, $("phaseTag"));

  btn.addEventListener("click", ()=>showTab("grave"));
})();

document.querySelectorAll(".tab[data-tab]").forEach(btn=>{
  btn.addEventListener("click", ()=>showTab(btn.dataset.tab));
});

/* =========================
   PORTRAIT HOOKS (safe no-image fallback)
========================= */
function applyRaceBase(char, prefix){
  const base = $(prefix+"layer_base");
  if(base) base.src = "";
}
function applyRigFraming(char, frameId){
  const f = $(frameId);
  if(!f) return;
  f.classList.toggle("cursed", false);
}
function applyDemiTraits(char, prefix){}
function applyIdleFx(char, prefix){}

/* =========================
   WHEEL (RACE ONLY, NO REDO)
========================= */
const wheel = $("wheel");
const ctx = wheel?.getContext("2d");
let wheelAngle = 0;
let wheelSpinning = false;

function drawWheel(){
  if(!ctx || !wheel) return;
  const w = wheel.width, h = wheel.height;
  ctx.clearRect(0,0,w,h);

  const cx=w/2, cy=h/2;
  const r=Math.min(cx,cy)-8;
  const n=RACE_OPTIONS.length;

  ctx.beginPath();
  ctx.arc(cx,cy,r+4,0,Math.PI*2);
  ctx.strokeStyle="rgba(255,255,255,.15)";
  ctx.lineWidth=10;
  ctx.stroke();

  for(let i=0;i<n;i++){
    const a0 = wheelAngle + (i * (Math.PI*2/n));
    const a1 = wheelAngle + ((i+1) * (Math.PI*2/n));

    ctx.beginPath();
    ctx.moveTo(cx,cy);
    ctx.arc(cx,cy,r,a0,a1);
    ctx.closePath();
    ctx.fillStyle = i%2===0 ? "rgba(122,168,255,.14)" : "rgba(255,255,255,.06)";
    ctx.fill();

    const mid=(a0+a1)/2;
    ctx.save();
    ctx.translate(cx,cy);
    ctx.rotate(mid);
    ctx.textAlign="right";
    ctx.fillStyle="rgba(232,238,252,.92)";
    ctx.font="900 14px system-ui";
    ctx.fillText(RACE_OPTIONS[i], r-14, 6);
    ctx.restore();
  }

  ctx.beginPath();
  ctx.moveTo(cx, 10);
  ctx.lineTo(cx-12, 34);
  ctx.lineTo(cx+12, 34);
  ctx.closePath();
  ctx.fillStyle="rgba(255,204,102,.95)";
  ctx.fill();
}

function pickFromWheel(){
  const n = RACE_OPTIONS.length;
  const slice = (Math.PI*2)/n;
  const pointerAngle = (Math.PI*2) - (wheelAngle % (Math.PI*2));
  const idx = Math.floor((pointerAngle / slice)) % n;
  return RACE_OPTIONS[idx];
}

function logBuild(msg){
  const el = $("buildLog");
  if(!el) return;
  const time = new Date().toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
  el.innerHTML = `<div><span class="muted">[${time}]</span> ${escapeHtml(msg)}</div>` + el.innerHTML;
}

function randomFrom(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

/* New Build now creates a NEW character (does not overwrite) */
function newBuild(){
  const c = addNewCharacterAndActivate();

  // generate rolls (except race - race comes from wheel)
  c.clan = randomFrom(CLAN_OPTIONS);
  c.trainer = randomFrom(TRAINER_OPTIONS);
  c.powerMastery = randomFrom(POWER_MASTERY_OPTIONS);
  c.transformation = randomFrom(TRANSFORM_OPTIONS);

  c.strengthW = randomFrom(STRENGTH_WORDS.slice(0,10));
  c.speedW = randomFrom(SPEED_WORDS.slice(0,9));
  c.durabilityW = randomFrom(DUR_WORDS.slice(0,10));
  c.fightW = randomFrom(FIGHT_WORDS.slice(0,7));
  c.iqW = randomFrom(IQ_WORDS.slice(0,7));
  c.luckW = String(1+Math.floor(Math.random()*10));

  if(Math.random()<0.85) c.powers.push(randomFrom(POWER_OPTIONS));
  if(Math.random()<0.85) c.weapons.push(randomFrom(WEAPON_OPTIONS));
  if(Math.random()<0.75) c.armors.push(randomFrom(ARMOR_OPTIONS));

  c.powers = c.powers.filter(x=>x && x!=="No Power");
  c.weapons = c.weapons.filter(x=>x && x!=="No Weapon");
  c.armors = c.armors.filter(x=>x && x!=="No Armor");

  c.transformDetail = null;
  if(c.transformation==="Kaioken") c.transformDetail={kind:"kaioken", value:randomFrom(KAIOKEN_OPTIONS)};
  if(c.transformation==="Eight Gates") c.transformDetail={kind:"gates", value:randomFrom(GATES_OPTIONS)};
  if(c.transformation==="Super Saiyan") c.transformDetail={kind:"ssj", value:randomFrom(SAIYAN_FORM_OPTIONS)};
  if(c.transformation==="Titan Transformation") c.transformDetail={kind:"titan", value:randomFrom(TITAN_TYPE_OPTIONS)};
  if(c.transformation==="Tailed Beast") c.transformDetail={kind:"tailed", value:randomFrom(TAILED_BEAST_OPTIONS)};

  $("buildLog").innerHTML = "";
  logBuild("New character created.");
  $("wheelTitle").textContent = "Race";
  $("wheelHint").textContent = "Spin the wheel (no redo)";
  $("buildHint").textContent = "Spin for Race. Race locks permanently after spin.";

  saveState();
  refreshUI();
}

/* Spin is blocked once race is chosen */
async function spinWheel(){
  const c = ensureActiveLiving();
  if(!c){
    toast("No living character. Make a new build.");
    return;
  }
  if(c.raceLocked){
    toast("Race is locked for this character.");
    return;
  }
  if(wheelSpinning) return;
  wheelSpinning=true;

  let v = 0.35 + Math.random()*0.35;
  const friction = 0.985 - Math.random()*0.006;
  const minTicks = 60 + Math.floor(Math.random()*40);
  let ticks=0;

  function step(){
    ticks++;
    wheelAngle += v;
    v *= friction;
    drawWheel();

    if(ticks > minTicks && v < 0.01){
      wheelSpinning=false;
      const result = pickFromWheel();
      c.race = result;
      c.raceLocked = true;

      logBuild(`Race â†’ ${result} (LOCKED)`);
      $("wheelTitle").textContent = "Race";
      $("wheelHint").textContent = `Result: ${result} (locked)`;
      $("buildHint").textContent = `Race locked. This character is ready for PvE/PvP.`;

      saveState();
      refreshUI();
      return;
    }
    requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
}

/* =========================
   UI RENDER
========================= */
function buildStatLines(c){
  const lines = [];
  lines.push(["Status", c.dead ? "DEAD" : "Alive"]);
  lines.push(["Injuries", `${c.injuries||0}/${MAX_INJURIES}`]);

  lines.push(["Race", c.race || "â€”"]);
  lines.push(["Power(s)", (c.powers||[]).length ? c.powers.join(", ") : "â€”"]);
  lines.push(["Weapon(s)", (c.weapons||[]).length ? c.weapons.join(", ") : "â€”"]);
  lines.push(["Armor(s)", (c.armors||[]).length ? c.armors.join(", ") : "â€”"]);
  lines.push(["Clan", c.clan || "â€”"]);
  lines.push(["Trainer", c.trainer || "â€”"]);
  lines.push(["Power Mastery", c.powerMastery || "â€”"]);
  lines.push(["Transformation", c.transformation==="None" ? "None" : `${c.transformation} (${c.transformDetail?.value||"?"})`]);

  lines.push(["Strength", c.strengthW]);
  lines.push(["Speed", c.speedW]);
  lines.push(["Durability", c.durabilityW]);
  lines.push(["Fight", c.fightW]);
  lines.push(["IQ", c.iqW]);
  lines.push(["Luck", c.luckW]);
  return lines;
}

function renderBuildStats(){
  const c = ensureActiveLiving();
  const host = $("buildStats");
  if(!host) return;

  host.innerHTML = "";
  if(!c){
    const div = document.createElement("div");
    div.className="statLine";
    div.innerHTML = `<div class="statKey">No Living Character</div><div class="statVal">Press New Build</div>`;
    host.appendChild(div);
    return;
  }

  buildStatLines(c).forEach(([k,v])=>{
    const div = document.createElement("div");
    div.className="statLine";
    div.innerHTML = `<div class="statKey">${escapeHtml(k)}</div><div class="statVal">${escapeHtml(v)}</div>`;
    host.appendChild(div);
  });

  const badges = $("buildBadges");
  if(badges){
    badges.innerHTML = "";
    const b=document.createElement("div");
    b.className="badge";
    b.innerHTML=`<span class="icon">ðŸ‘¥</span><span>Roster: ${state.roster.filter(x=>!x.dead).length} alive / ${state.graveyard.length} dead</span>`;
    badges.appendChild(b);
  }

  // update injury tags on battle tabs
  $("pve_injuryTag") && ($("pve_injuryTag").textContent = `Injuries: ${c.injuries||0}/3`);
  $("pvp_injuryTag") && ($("pvp_injuryTag").textContent = `Injuries: ${c.injuries||0}/3`);
}

function renderGraveyard(){
  const host = $("graveList");
  const detail = $("graveDetail");
  if(!host || !detail) return;

  host.innerHTML = "";
  detail.innerHTML = "";

  if(state.graveyard.length === 0){
    const div = document.createElement("div");
    div.className="statLine";
    div.innerHTML = `<div class="statKey">No graves yet</div><div class="statVal">â€”</div>`;
    host.appendChild(div);
    return;
  }

  state.graveyard
    .slice()
    .sort((a,b)=>(b.diedAt||0)-(a.diedAt||0))
    .forEach(g=>{
      const row = document.createElement("div");
      row.className="statLine";
      row.style.cursor="pointer";
      const nm = g.name ? g.name : "(Unnamed)";
      row.innerHTML = `<div class="statKey">ðŸª¦ ${escapeHtml(nm)}</div><div class="statVal">${escapeHtml(g.race||"â€”")}</div>`;
      row.addEventListener("click", ()=>{
        state.ui.graveSelectedId = g.id;
        saveState();
        renderGraveDetail();
      });
      host.appendChild(row);
    });

  renderGraveDetail();
}

function renderGraveDetail(){
  const detail = $("graveDetail");
  if(!detail) return;
  detail.innerHTML = "";

  const id = state.ui.graveSelectedId;
  const g = state.graveyard.find(x=>x.id===id) || state.graveyard[0];
  if(!g){
    detail.innerHTML = `<div class="statLine"><div class="statKey">None selected</div><div class="statVal">â€”</div></div>`;
    return;
  }

  const title = document.createElement("div");
  title.className="statLine";
  title.innerHTML = `<div class="statKey">Selected</div><div class="statVal">ðŸª¦ ${escapeHtml(g.name||"(Unnamed)")}</div>`;
  detail.appendChild(title);

  buildStatLines(g).forEach(([k,v])=>{
    const div = document.createElement("div");
    div.className="statLine";
    div.innerHTML = `<div class="statKey">${escapeHtml(k)}</div><div class="statVal">${escapeHtml(v)}</div>`;
    detail.appendChild(div);
  });
}

function refreshUI(){
  const c = ensureActiveLiving();

  $("phaseTag").textContent = c ? (c.raceLocked ? "Phase: Ready" : "Phase: Race") : "Phase: No Character";
  $("namedTag").textContent = c ? (c.name ? `Active: ${c.name}` : "Active: (Unnamed)") : "No active";

  // safe portraits
  if(c){
    applyRaceBase(c, "");
    applyRigFraming(c, "charFrame");
    applyDemiTraits(c, "");
    applyIdleFx(c, "");
  }

  renderBuildStats();
  renderGraveyard();

  // keep active tab
  const tab = state.ui.activeTab || "build";
  showTab(tab);

  // wheel hint
  $("wheelTitle").textContent = "Race";
  if(!c){
    $("wheelHint").textContent = "Press New Build";
  } else if(!c.raceLocked){
    $("wheelHint").textContent = "Spin the wheel (no redo)";
  } else {
    $("wheelHint").textContent = `Result: ${c.race} (locked)`;
  }

  // hide finalize button (not needed)
  const fin = $("finalizeBtn");
  if(fin) fin.style.display = "none";

  // hide reset button (you said no reset)
  const reset = $("resetBtn");
  if(reset) reset.style.display = "none";
}

/* =========================
   BUTTONS
========================= */
$("spinBtn")?.addEventListener("click", spinWheel);
$("newBuildBtn")?.addEventListener("click", newBuild);

/* reset is disabled */
$("resetBtn")?.addEventListener("click", (e)=>{ e.preventDefault(); toast("Reset is disabled."); });

$("lootCloseBtn")?.addEventListener("click", ()=>$("lootModal")?.classList.add("hidden"));
$("lootOkBtn")?.addEventListener("click", ()=>$("lootModal")?.classList.add("hidden"));

$("choiceCloseBtn")?.addEventListener("click", ()=>{
  $("choiceModal")?.classList.add("hidden");
  window.__choiceResolve?.(null);
  window.__choiceResolve=null;
});

/* choice modal used by soul stone */
function openChoiceModal({title, sub, options}){
  $("choiceTitle").textContent = title || "Choose";
  $("choiceSub").textContent = sub || "";
  const host = $("choiceBtns");
  host.innerHTML = "";

  return new Promise(resolve=>{
    window.__choiceResolve = resolve;
    (options||[]).forEach(opt=>{
      const b=document.createElement("button");
      b.className="btn";
      b.textContent = opt.label;
      b.addEventListener("click", ()=>{
        $("choiceModal").classList.add("hidden");
        resolve(opt.value);
        window.__choiceResolve=null;
      });
      host.appendChild(b);
    });
    $("choiceModal").classList.remove("hidden");
  });
}

/* init */
drawWheel();
if(state.roster.length === 0){
  // start with one character so the game isn't empty
  newBuild();
} else {
  ensureActiveLiving();
  refreshUI();
}
</script>
<!-- âœ… PART 5 / 6 â€” Additive stat math + wordâ†”number + flee chance + cursed check -->
<!-- Paste this RIGHT AFTER your Part 4 script ends -->

<script>
/* =========================================================
   STAT WORD -> NUMBER (under the hood)
   Shows words to player, but code uses big numbers.
========================================================= */
const STAT_WORD_TO_NUM = {
  strength: {
    "Weak":10, "Average":20, "Strong":35, "City":60, "Mountain":90, "Country":130,
    "Planet":180, "Star":250, "Galaxy":340, "Universal":500, "???":900
  },
  speed: {
    "Slow":10, "Average":20, "Fast":35, "Mach":55, "Lightning":80, "Light":120,
    "FTL":180, "Galaxy":260, "Universal":380, "???":800
  },
  durability: {
    "Fragile":10, "Average":20, "Tough":35, "Steel":55, "City":80, "Mountain":110,
    "Country":150, "Planet":210, "Star":280, "Universal":420, "???":850
  },
  fight: {
    "Clumsy":10, "Average":20, "Trained":35, "Elite":55, "Master":80, "Legendary":110,
    "Mythic":150, "Universal":250, "???":700
  },
  iq: {
    "Low":10, "Average":20, "Smart":35, "Genius":60, "Supergenius":95, "Cosmic":140,
    "Universal":220, "???":600
  }
};

function statWordToNumber(statKey, word){
  const map = STAT_WORD_TO_NUM[statKey] || {};
  if(map[word] != null) return map[word];

  // fallback: if unknown, try parse numeric
  const n = Number(word);
  if(Number.isFinite(n)) return Math.max(1, Math.floor(n));
  return 20;
}

/* =========================================================
   NUMBER -> LABEL (for display)
   If values go past the top, show "???"
========================================================= */
function labelForStat(statKey, n){
  const map = STAT_WORD_TO_NUM[statKey] || {};
  const entries = Object.entries(map).filter(([k])=>k!=="???");
  // sort by value ascending
  entries.sort((a,b)=>a[1]-b[1]);

  // if above last known tier -> ???
  const maxTier = entries.length ? entries[entries.length-1][1] : 999999;
  if(n > maxTier) return "???";

  // closest tier at or below
  let best = entries[0]?.[0] || "Average";
  for(const [label,val] of entries){
    if(n >= val) best = label;
  }
  return best;
}

/* =========================================================
   MASTERY RANK
========================================================= */
const MASTERY_RANK = {
  "None":0, "Dormant":1, "Awakening":2, "Controlled":3,
  "Mastered":4, "Planetary":5, "Cosmic":6, "Universal":7, "Omnipotent":8
};
function masteryAtLeast(char, key){
  const cur = MASTERY_RANK[char.powerMastery || "None"] || 0;
  return cur >= (MASTERY_RANK[key] || 0);
}

/* =========================================================
   LUCK
========================================================= */
function parseLuck(char){
  const n = parseInt(char.luckW || "0", 10);
  return Number.isFinite(n) ? Math.max(1, Math.min(10, n)) : 5;
}

/* =========================================================
   BASE STATS
========================================================= */
function statBaseFromWords(char){
  return {
    strength: statWordToNumber("strength", char.strengthW),
    speed: statWordToNumber("speed", char.speedW),
    durability: statWordToNumber("durability", char.durabilityW),
    fight: statWordToNumber("fight", char.fightW),
    iq: statWordToNumber("iq", char.iqW)
  };
}

/* =========================================================
   ADDITIVE MODS TABLES
========================================================= */
function addMods(mods, add){
  for(const k of Object.keys(add)){
    mods[k] = (mods[k] || 0) + add[k];
  }
}

function powerMods(power){
  switch(power){
    case "Adaptation": return { durability: 12, fight: 6 };
    case "Regeneration": return { durability: 20 };
    case "Gravity Manipulation": return { strength: 14, fight: 6 };
    case "Time Manipulation": return { speed: 18, iq: 8 };
    case "Telekinesis": return { iq: 14, fight: 6 };
    case "Teleportation": return { speed: 14 };
    case "Fire": return { strength: 8 };
    case "Ice Manipulation": return { durability: 8 };
    case "Lightning": return { speed: 14 };
    case "Weapon Creation": return { fight: 12 };
    case "Heavenly Restriction": return { strength: 22, speed: 18, durability: 18, fight: 16, iq: -6 };
    case "Immortal": return { durability: 26 };
    case "Rinnegan": return { iq: 14, fight: 14 };
    default: return {};
  }
}

function weaponMods(weapon){
  switch(weapon){
    case "Sword": return { fight: 12 };
    case "Scythe": return { fight: 12, strength: 6 };
    case "Axe": return { strength: 14 };
    case "Hammer": return { strength: 12, durability: 8 };
    case "Spear": return { fight: 6, speed: 6 };
    case "Brass Knuckles": return { fight: 6, strength: 6 };
    case "Blades of Chaos": return { fight: 12, speed: 6 };
    case "Samehada": return { durability: 8, fight: 12 };
    case "Uzumaki Chains": return { durability: 14, fight: 6 };
    case "Infinity Gauntlet": return { strength: 22, durability: 22, iq: 16, fight: 16 };
    case "Green Lantern Ring": return { iq: 22, durability: 14 };
    default: return {};
  }
}

function armorMods(armor){
  switch(armor){
    case "Berserk Armor": return { strength: 14, durability: 14, fight: 8 };
    case "Iron Man Suit": return { speed: 14, durability: 14, iq: 8 };
    case "Jauger": return { durability: 12 };
    case "Symbiote": return { strength: 8, speed: 8, durability: 8, fight: 8 };
    case "Ashborn's Armor": return { durability: 18, fight: 8 };
    case "Rock Lee Weights": return { speed: -10, strength: 12, durability: 6 };
    case "Goku's Gi": return { fight: 8 };
    default: return {};
  }
}

function trainerMods(trainer){
  switch(trainer){
    case "Master Roshi": return { fight: 14, iq: 8 };
    case "Jiraiya": return { fight: 14, iq: 8 };
    case "Hisoka": return { fight: 14, iq: 8 };
    case "Korro": return { durability: 8, fight: 8 };
    case "Yuujirou": return { strength: 20, fight: 14 };
    default: return {};
  }
}

function clanMods(clan){
  switch(clan){
    case "Uchiha": return { fight: 14, iq: 8 };
    case "Gojo": return { iq: 14, speed: 8 };
    case "D Clan": return { durability: 8, fight: 8 };
    case "Kamado": return { fight: 14 };
    default: return {};
  }
}

/* =========================================================
   TRANSFORM MODS (additive + optional multipliers)
========================================================= */
function transformMods(char){
  const t = char.transformation;
  const d = char.transformDetail?.value || "None";
  if(!t || t === "None" || d === "None") return { add:{}, mult:{} };

  if(t === "Kaioken"){
    const m = parseInt(String(d).replace("X",""),10);
    const mul = Number.isFinite(m) ? Math.min(100, Math.max(2, m)) : 2;
    return {
      add:{},
      mult:{
        strength: 1 + mul*0.02,
        speed: 1 + mul*0.02,
        durability: 1 + mul*0.006,
        fight: 1 + mul*0.012
      }
    };
  }

  if(t === "Eight Gates"){
    const idx = Math.max(0, GATES_OPTIONS.indexOf(d));
    const boost = (idx>=7) ? 70 : 10 + idx*8;
    return { add:{ strength:boost, speed:boost, fight:Math.floor(boost*0.7) }, mult:{} };
  }

  if(t === "Super Saiyan"){
    const idx = Math.max(0, SAIYAN_FORM_OPTIONS.indexOf(d));
    return { add:{ strength: 18+idx*12, speed: 10+idx*6, durability: 10+idx*6, fight: 10+idx*6 }, mult:{} };
  }

  if(t === "Titan Transformation"){
    const idx = Math.max(0, TITAN_TYPE_OPTIONS.indexOf(d));
    return { add:{ strength: 16+idx*6, durability: 22+idx*8, fight: 8+Math.floor(idx*3) }, mult:{} };
  }

  if(t === "Tailed Beast"){
    const idx = Math.max(0, TAILED_BEAST_OPTIONS.indexOf(d)); // 0..8
    return { add:{ strength: idx*8, durability: idx*8, speed: Math.floor(idx*4), fight: Math.floor(idx*4) }, mult:{} };
  }

  return { add:{}, mult:{} };
}

/* =========================================================
   CURSED CHECK (simple)
========================================================= */
function computeIsCursed(char){
  // Example rule: Heavenly Restriction + Infinity Gauntlet = cursed
  const hasHR = (char.powers||[]).includes("Heavenly Restriction");
  const hasIG = (char.weapons||[]).includes("Infinity Gauntlet");
  return !!(hasHR && hasIG);
}

/* =========================================================
   FINAL STATS (ADDITIVE + PERMANENT BONUSES)
========================================================= */
function computeFinalStats(char){
  const base = statBaseFromWords(char);
  const mods = { strength:0, speed:0, durability:0, fight:0, iq:0 };

  (char.powers || []).forEach(p => addMods(mods, powerMods(p)));
  (char.weapons || []).forEach(w => addMods(mods, weaponMods(w)));
  (char.armors || []).forEach(a => addMods(mods, armorMods(a)));

  addMods(mods, trainerMods(char.trainer));
  addMods(mods, clanMods(char.clan));

  // mastery bumps
  if(masteryAtLeast(char,"Mastered")) addMods(mods, { fight: 6, durability: 6 });
  if(masteryAtLeast(char,"Cosmic")) addMods(mods, { strength: 12, speed: 12, iq: 8 });
  if(masteryAtLeast(char,"Universal")) addMods(mods, { strength: 18, speed: 18, durability: 18, fight: 12, iq: 12 });

  // permanent progression
  if((char.powers || []).includes("Adaptation")){
    const stacks = state.progress.adaptationStacks || 0;
    addMods(mods, { durability: stacks * 2 });
  }
  addMods(mods, state.progress.soulBonus || {});

  // transform
  const tm = transformMods(char);

  // apply additive
  let out = {
    strength: base.strength + mods.strength + (tm.add.strength||0),
    speed: base.speed + mods.speed + (tm.add.speed||0),
    durability: base.durability + mods.durability + (tm.add.durability||0),
    fight: base.fight + mods.fight + (tm.add.fight||0),
    iq: base.iq + mods.iq + (tm.add.iq||0),
    luck: parseLuck(char)
  };

  // apply multipliers
  for(const k of ["strength","speed","durability","fight","iq"]){
    const mul = tm.mult[k] || 1;
    out[k] = Math.round(out[k] * mul);
  }

  // labels
  out.labels = {
    strength: labelForStat("strength", out.strength),
    speed: labelForStat("speed", out.speed),
    durability: labelForStat("durability", out.durability),
    fight: labelForStat("fight", out.fight),
    iq: labelForStat("iq", out.iq)
  };

  out.isCursed = computeIsCursed(char);
  return out;
}

/* =========================================================
   FLEE CHANCE (only if speed is close; farther gap = lower chance)
========================================================= */
function fleeChanceFromSpeedGap(pSpeed, eSpeed){
  const gap = Math.abs(pSpeed - eSpeed);

  // hard lock: too far apart = impossible
  if(gap >= 80) return 0;

  // base chance favors the faster runner slightly
  const fasterIsPlayer = pSpeed >= eSpeed;
  const base = fasterIsPlayer ? 0.55 : 0.35;

  // gap penalty ramps down chance
  const penalty = (gap / 80) * 0.55; // up to -55%
  return Math.max(0.05, Math.min(0.85, base - penalty));
}

/* =========================================================
   STATS TAB RENDER
========================================================= */
function renderStatsTab(){
  const host = $("statsList");
  const host2 = $("finalStatsList");
  if(!host || !host2) return;

  const c = ensureActiveLiving();
  host.innerHTML = "";
  host2.innerHTML = "";

  if(!c){
    host.innerHTML = `<div class="statLine"><div class="statKey">No living character</div><div class="statVal">Press New Build</div></div>`;
    host2.innerHTML = host.innerHTML;
    return;
  }

  // Raw build lines
  const lines = buildStatLines(c);
  for(const [k,v] of lines){
    const div = document.createElement("div");
    div.className = "statLine";
    div.innerHTML = `<div class="statKey">${escapeHtml(k)}</div><div class="statVal">${escapeHtml(v)}</div>`;
    host.appendChild(div);
  }

  // Final computed stats
  const fin = computeFinalStats(c);
  const statOrder = [
    ["strength","Strength"],
    ["speed","Speed"],
    ["durability","Durability"],
    ["fight","Fight"],
    ["iq","IQ"],
    ["luck","Luck"]
  ];

  statOrder.forEach(([key,label])=>{
    const div = document.createElement("div");
    div.className = "statLine";

    if(key === "luck"){
      div.innerHTML = `<div class="statKey">${label}</div><div class="statVal">${fin.luck}</div>`;
    } else {
      const word = fin.labels[key];
      div.innerHTML = `<div class="statKey">${label}</div><div class="statVal">${escapeHtml(word)} <span class="muted">(${fin[key]})</span></div>`;
    }
    host2.appendChild(div);
  });

  if(fin.isCursed){
    const div = document.createElement("div");
    div.className = "statLine";
    div.innerHTML = `<div class="statKey">Cursed</div><div class="statVal">YES</div>`;
    host2.appendChild(div);
  }
}

/* Patch refreshUI to also render stats tab */
const _refreshUI_p5 = refreshUI;
refreshUI = function(){
  _refreshUI_p5();
  renderStatsTab();
};
</script>
<!-- âœ… PART 6 / 6 â€” Roster (permadeath), PvE/PvP (strikes), loot + steal + soul stone -->
<!-- Paste this AFTER Part 5 -->

<script>
/* =========================================================
   ROSTER / PERMADEATH RULES
   - No "Finalize" needed (locking happens on first spin result)
   - New Build creates a NEW character (does not overwrite)
   - Only death removes a character
   - PvE: 1 strike -> death
   - PvP: 2 strikes -> death
========================================================= */

// If older parts still assume state.character exists, keep it,
// but we ALSO maintain a roster: state.roster + state.activeId.
function ensureRoster(){
  state.roster ||= [];
  state.activeId ||= null;

  // migrate old single character into roster once
  if(state.roster.length === 0 && state.character){
    const migrated = {
      id: "c_" + Math.random().toString(36).slice(2,10),
      createdAt: Date.now(),
      name: state.character.name || "",
      finalized: !!state.character.finalized,
      dead: false,
      strikesPVE: 0,
      strikesPVP: 0,
      // copy build fields
      race: state.character.race || null,
      powers: [...(state.character.powers||[])],
      weapons: [...(state.character.weapons||[])],
      armors: [...(state.character.armors||[])],
      clan: state.character.clan || "No Clan",
      trainer: state.character.trainer || "No Trainer",
      powerMastery: state.character.powerMastery || "None",
      transformation: state.character.transformation || "None",
      transformDetail: state.character.transformDetail || null,
      strengthW: state.character.strengthW || "Average",
      speedW: state.character.speedW || "Average",
      durabilityW: state.character.durabilityW || "Average",
      fightW: state.character.fightW || "Average",
      iqW: state.character.iqW || "Average",
      luckW: state.character.luckW || "5",

      // build flow
      phase: state.character.phase || "race",
      wheelLocked: !!state.character.wheelLocked
    };
    state.roster.push(migrated);
    state.activeId = migrated.id;
    saveState();
  }

  // keep state.character pointing at active for backward compat
  const active = getActiveChar();
  if(active) state.character = active;
}

function getActiveChar(){
  if(!state.roster || !state.activeId) return null;
  return state.roster.find(c => c.id === state.activeId) || null;
}

function ensureActiveLiving(){
  ensureRoster();
  const c = getActiveChar();
  if(c && !c.dead) return c;

  // pick latest living if active is dead
  const living = (state.roster||[]).filter(x=>!x.dead);
  if(living.length){
    state.activeId = living[living.length-1].id;
    saveState();
    return getActiveChar();
  }
  return null;
}

function makeNewCharacter(){
  const id = "c_" + Math.random().toString(36).slice(2,10);
  const c = {
    id,
    createdAt: Date.now(),
    name: "",
    finalized: false,
    dead: false,
    strikesPVE: 0,
    strikesPVP: 0,

    // build
    phase: "race",
    wheelLocked: false,

    race: null,
    powers: [],
    weapons: [],
    armors: [],
    clan: randomFrom(CLAN_OPTIONS),
    trainer: randomFrom(TRAINER_OPTIONS),
    powerMastery: randomFrom(POWER_MASTERY_OPTIONS),
    transformation: randomFrom(TRANSFORM_OPTIONS),
    transformDetail: null,

    strengthW: randomFrom(STRENGTH_WORDS.slice(0,10)),
    speedW: randomFrom(SPEED_WORDS.slice(0,9)),
    durabilityW: randomFrom(DUR_WORDS.slice(0,10)),
    fightW: randomFrom(FIGHT_WORDS.slice(0,7)),
    iqW: randomFrom(IQ_WORDS.slice(0,7)),
    luckW: String(1+Math.floor(Math.random()*10))
  };

  // gear/power rolls
  if(Math.random()<0.85) c.powers.push(randomFrom(POWER_OPTIONS));
  if(Math.random()<0.85) c.weapons.push(randomFrom(WEAPON_OPTIONS));
  if(Math.random()<0.75) c.armors.push(randomFrom(ARMOR_OPTIONS));

  c.powers = c.powers.filter(x=>x && x!=="No Power");
  c.weapons = c.weapons.filter(x=>x && x!=="No Weapon");
  c.armors = c.armors.filter(x=>x && x!=="No Armor");

  // transform detail
  if(c.transformation==="Kaioken") c.transformDetail={kind:"kaioken", value:randomFrom(KAIOKEN_OPTIONS)};
  if(c.transformation==="Eight Gates") c.transformDetail={kind:"gates", value:randomFrom(GATES_OPTIONS)};
  if(c.transformation==="Super Saiyan") c.transformDetail={kind:"ssj", value:randomFrom(SAIYAN_FORM_OPTIONS)};
  if(c.transformation==="Titan Transformation") c.transformDetail={kind:"titan", value:randomFrom(TITAN_TYPE_OPTIONS)};
  if(c.transformation==="Tailed Beast") c.transformDetail={kind:"tailed", value:randomFrom(TAILED_BEAST_OPTIONS)};

  state.roster ||= [];
  state.roster.push(c);
  state.activeId = c.id;
  state.character = c; // compat
  saveState();

  $("buildLog").innerHTML = "";
  logBuild("New character created (roster).");
  $("wheelHint").textContent = "Spin to begin";
  $("buildHint").textContent = "Spin the wheel. It will auto-advance phases.";

  refreshUI();
}

function killActive(reason){
  const c = ensureActiveLiving();
  if(!c) return;
  c.dead = true;
  c.finalized = true;
  saveState();
  toast("Character died.");

  logBuild(`â˜ ï¸ ${c.race || "Character"} died. (${reason})`);

  // switch to another living if exists
  ensureActiveLiving();
  refreshUI();
}

/* =========================================================
   OVERRIDE: buildStatLines / renderBuildStats to accept char
========================================================= */
const _buildStatLines_old = typeof buildStatLines === "function" ? buildStatLines : null;
buildStatLines = function(charArg){
  const c = charArg || ensureActiveLiving() || getActiveChar() || state.character;

  const lines = [];
  if(!c){
    lines.push(["Character", "None"]);
    return lines;
  }

  lines.push(["Status", c.dead ? "DEAD" : "ALIVE"]);
  lines.push(["Race", c.race || "â€”"]);
  lines.push(["Power(s)", (c.powers||[]).length ? c.powers.join(", ") : "â€”"]);
  lines.push(["Weapon(s)", (c.weapons||[]).length ? c.weapons.join(", ") : "â€”"]);
  lines.push(["Armor(s)", (c.armors||[]).length ? c.armors.join(", ") : "â€”"]);
  lines.push(["Clan", c.clan || "â€”"]);
  lines.push(["Trainer", c.trainer || "â€”"]);
  lines.push(["Power Mastery", c.powerMastery || "â€”"]);
  lines.push(["Transformation", c.transformation==="None" ? "None" : `${c.transformation} (${c.transformDetail?.value||"?"})`]);

  lines.push(["Strength", c.strengthW]);
  lines.push(["Speed", c.speedW]);
  lines.push(["Durability", c.durabilityW]);
  lines.push(["Fight", c.fightW]);
  lines.push(["IQ", c.iqW]);
  lines.push(["Luck", c.luckW]);

  lines.push(["PvE Strikes", String(c.strikesPVE||0) + " / 1"]);
  lines.push(["PvP Strikes", String(c.strikesPVP||0) + " / 2"]);

  return lines;
};

const _renderBuildStats_old = typeof renderBuildStats === "function" ? renderBuildStats : null;
renderBuildStats = function(){
  const c = ensureActiveLiving();
  const host = $("buildStats");
  if(!host) return;
  host.innerHTML = "";

  const lines = buildStatLines(c);
  lines.forEach(([k,v])=>{
    const div = document.createElement("div");
    div.className="statLine";
    div.innerHTML = `<div class="statKey">${escapeHtml(k)}</div><div class="statVal">${escapeHtml(v)}</div>`;
    host.appendChild(div);
  });

  const badges = $("buildBadges");
  if(badges){
    badges.innerHTML = "";
    const b=document.createElement("div");
    b.className="badge";
    if(!c) b.innerHTML = `<span class="icon">âž•</span><span>No character</span>`;
    else if(c.dead) b.innerHTML = `<span class="icon">â˜ ï¸</span><span>Dead</span>`;
    else if(c.wheelLocked) b.innerHTML = `<span class="icon">ðŸ”’</span><span>Locked</span>`;
    else b.innerHTML = `<span class="icon">ðŸŽ²</span><span>Rolling</span>`;
    badges.appendChild(b);
  }
};

/* =========================================================
   FINALIZE BUTTON REMOVAL (soft)
   - keep it but make it harmless / optional
========================================================= */
$("finalizeBtn")?.addEventListener("click", (e)=>{
  e.preventDefault();
  toast("No finalize needed. Your character locks as you spin.");
});

/* =========================================================
   REMOVE RESET BUTTON (disable it)
========================================================= */
const resetBtn = $("resetBtn");
if(resetBtn){
  resetBtn.style.display = "none";
}

/* =========================================================
   NEW BUILD = NEW CHARACTER (roster) instead of overwrite
========================================================= */
$("newBuildBtn")?.addEventListener("click", (e)=>{
  e.preventDefault();
  makeNewCharacter();
});

/* =========================================================
   WHEEL PHASE SYSTEM (Race -> Power -> Weapon -> Armor -> Clan -> Trainer -> Mastery -> Transform)
   - Auto-advance each spin
   - After first spin, phase locks as it goes (no redo)
========================================================= */
const BUILD_PHASES = ["race","power","weapon","armor","clan","trainer","mastery","transform"];
function phaseTitle(phase){
  switch(phase){
    case "race": return "Race";
    case "power": return "Power";
    case "weapon": return "Weapon";
    case "armor": return "Armor";
    case "clan": return "Clan";
    case "trainer": return "Trainer";
    case "mastery": return "Power Mastery";
    case "transform": return "Transformation";
    default: return "Wheel";
  }
}

function phaseOptions(phase){
  switch(phase){
    case "race": return RACE_OPTIONS;
    case "power": return POWER_OPTIONS;
    case "weapon": return WEAPON_OPTIONS;
    case "armor": return ARMOR_OPTIONS;
    case "clan": return CLAN_OPTIONS;
    case "trainer": return TRAINER_OPTIONS;
    case "mastery": return POWER_MASTERY_OPTIONS;
    case "transform": return TRANSFORM_OPTIONS;
    default: return RACE_OPTIONS;
  }
}

function applyPhaseResult(c, phase, value){
  if(phase === "race"){
    c.race = value;
    return;
  }
  if(phase === "power"){
    if(value && value!=="No Power"){
      c.powers ||= [];
      if(!c.powers.includes(value)) c.powers.push(value);
    }
    return;
  }
  if(phase === "weapon"){
    if(value && value!=="No Weapon"){
      c.weapons ||= [];
      if(!c.weapons.includes(value)) c.weapons.push(value);
    }
    return;
  }
  if(phase === "armor"){
    if(value && value!=="No Armor"){
      c.armors ||= [];
      if(!c.armors.includes(value)) c.armors.push(value);
    }
    return;
  }
  if(phase === "clan"){
    c.clan = value || "No Clan";
    return;
  }
  if(phase === "trainer"){
    c.trainer = value || "No Trainer";
    return;
  }
  if(phase === "mastery"){
    c.powerMastery = value || "None";
    return;
  }
  if(phase === "transform"){
    c.transformation = value || "None";
    c.transformDetail = null;

    if(c.transformation==="Kaioken") c.transformDetail={kind:"kaioken", value:randomFrom(KAIOKEN_OPTIONS)};
    if(c.transformation==="Eight Gates") c.transformDetail={kind:"gates", value:randomFrom(GATES_OPTIONS)};
    if(c.transformation==="Super Saiyan") c.transformDetail={kind:"ssj", value:randomFrom(SAIYAN_FORM_OPTIONS)};
    if(c.transformation==="Titan Transformation") c.transformDetail={kind:"titan", value:randomFrom(TITAN_TYPE_OPTIONS)};
    if(c.transformation==="Tailed Beast") c.transformDetail={kind:"tailed", value:randomFrom(TAILED_BEAST_OPTIONS)};
    return;
  }
}

function nextPhase(phase){
  const i = BUILD_PHASES.indexOf(phase);
  if(i < 0) return "race";
  return BUILD_PHASES[Math.min(BUILD_PHASES.length-1, i+1)];
}

function isBuildComplete(c){
  return !!(c.race && c.phase === "transform" && c.wheelLocked);
}

// Override wheel draw to use current phase options/labels
function drawWheelPhase(){
  const c = ensureActiveLiving();
  if(!c) return drawWheel(); // fallback
  const opts = phaseOptions(c.phase || "race");
  // temporarily swap RACE_OPTIONS rendering by drawing with opts
  if(!ctx || !wheel) return;
  const w = wheel.width, h = wheel.height;
  ctx.clearRect(0,0,w,h);

  const cx=w/2, cy=h/2;
  const r=Math.min(cx,cy)-8;
  const n=opts.length;

  ctx.beginPath();
  ctx.arc(cx,cy,r+4,0,Math.PI*2);
  ctx.strokeStyle="rgba(255,255,255,.15)";
  ctx.lineWidth=10;
  ctx.stroke();

  for(let i=0;i<n;i++){
    const a0 = wheelAngle + (i * (Math.PI*2/n));
    const a1 = wheelAngle + ((i+1) * (Math.PI*2/n));

    ctx.beginPath();
    ctx.moveTo(cx,cy);
    ctx.arc(cx,cy,r,a0,a1);
    ctx.closePath();
    ctx.fillStyle = i%2===0 ? "rgba(122,168,255,.14)" : "rgba(255,255,255,.06)";
    ctx.fill();

    const mid=(a0+a1)/2;
    ctx.save();
    ctx.translate(cx,cy);
    ctx.rotate(mid);
    ctx.textAlign="right";
    ctx.fillStyle="rgba(232,238,252,.92)";
    ctx.font="900 14px system-ui";
    ctx.fillText(opts[i], r-14, 6);
    ctx.restore();
  }

  ctx.beginPath();
  ctx.moveTo(cx, 10);
  ctx.lineTo(cx-12, 34);
  ctx.lineTo(cx+12, 34);
  ctx.closePath();
  ctx.fillStyle="rgba(255,204,102,.95)";
  ctx.fill();
}

// Override pickFromWheel to use phase options
function pickFromWheelPhase(){
  const c = ensureActiveLiving();
  const opts = phaseOptions(c?.phase || "race");
  const n = opts.length;
  const slice = (Math.PI*2)/n;
  const pointerAngle = (Math.PI*2) - (wheelAngle % (Math.PI*2));
  const idx = Math.floor((pointerAngle / slice)) % n;
  return opts[idx];
}

// Override spinWheel to lock + advance phases and stop after complete
const _spinWheel_old = spinWheel;
spinWheel = async function(){
  const c = ensureActiveLiving();
  if(!c){
    toast("Press New Build first.");
    return;
  }
  if(c.dead){
    toast("That character is dead.");
    return;
  }
  if(c.wheelLocked && c.phase === "transform"){
    toast("Build already complete.");
    return;
  }

  if(wheelSpinning) return;
  wheelSpinning=true;

  let v = 0.35 + Math.random()*0.35;
  const friction = 0.985 - Math.random()*0.006;
  const minTicks = 55 + Math.floor(Math.random()*45);
  let ticks=0;

  function step(){
    ticks++;
    wheelAngle += v;
    v *= friction;
    drawWheelPhase();

    if(ticks > minTicks && v < 0.01){
      wheelSpinning=false;

      const phase = c.phase || "race";
      const result = pickFromWheelPhase();

      applyPhaseResult(c, phase, result);

      // lock that phase permanently by advancing
      const wasLast = (phase === "transform");
      if(wasLast){
        c.wheelLocked = true;
        c.finalized = true;
        logBuild(`${phaseTitle(phase)} â†’ ${result}`);
        logBuild("âœ… Build complete. No re-rolls.");
        $("wheelTitle").textContent = "Complete";
        $("wheelHint").textContent = "Build locked";
        $("buildHint").textContent = "Go to STATS / PvE / PvP.";
      } else {
        logBuild(`${phaseTitle(phase)} â†’ ${result}`);
        c.phase = nextPhase(phase);
        $("wheelTitle").textContent = phaseTitle(c.phase);
        $("wheelHint").textContent = `Next: ${phaseTitle(c.phase)}`;
        $("buildHint").textContent = `Spin for ${phaseTitle(c.phase)}.`;
      }

      state.character = c;
      saveState();
      refreshUI();
      return;
    }
    requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
};

/* Hook draw on init */
const _drawWheel_old = drawWheel;
drawWheel = function(){
  drawWheelPhase();
};

/* =========================================================
   SKIP / FAST SPIN buttons
========================================================= */
$("skipBtn")?.addEventListener("click", ()=>{
  const c = ensureActiveLiving();
  if(!c || c.dead) return;
  if(c.wheelLocked && c.phase==="transform") return;
  c.phase = nextPhase(c.phase || "race");
  toast(`Skipped to ${phaseTitle(c.phase)}`);
  saveState();
  drawWheelPhase();
  refreshUI();
});
$("testFastBtn")?.addEventListener("click", ()=>{
  // just spin normally; speed is already fine. This is a placeholder.
  spinWheel();
});

/* =========================================================
   PvE/PvP HELPERS
========================================================= */
function logPVP(msg){
  const el = $("pvpLog");
  if(!el) return;
  const time = new Date().toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
  el.innerHTML = `<div><span class="muted">[${time}]</span> ${escapeHtml(msg)}</div>` + el.innerHTML;
}
function logPVE(msg){
  const el = $("pveLog");
  if(!el) return;
  const time = new Date().toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
  el.innerHTML = `<div><span class="muted">[${time}]</span> ${escapeHtml(msg)}</div>` + el.innerHTML;
}
function setHP(barId, pct){
  const el = $(barId);
  if(!el) return;
  el.style.width = `${Math.max(0, Math.min(1, pct)) * 100}%`;
}
function roll(chance){ return Math.random() < chance; }

function computeHP(stats){
  return 70 + stats.durability*0.9 + stats.fight*0.35;
}
function computeDamage(att, def){
  const atk = att.strength*0.9 + att.fight*1.1 + att.speed*0.35;
  const mitig = def.durability*0.8 + def.fight*0.4;
  const base = Math.max(8, atk - mitig*0.55);
  const varMul = 0.85 + (att.luck-1)*0.02 + Math.random()*0.18;
  return Math.round(base * varMul);
}

const FLEE_HP_THRESHOLD = 0.25;
function tryFlee(playerStats, enemyStats, logger){
  const chance = fleeChanceFromSpeedGap(playerStats.speed, enemyStats.speed);
  if(chance <= 0){
    logger(`Flee failed: speed gap too large.`);
    return { fled:false };
  }
  if(roll(chance)){
    logger(`Flee succeeded! (chance ${(chance*100).toFixed(0)}%)`);
    return { fled:true };
  }
  logger(`Flee failed. (chance ${(chance*100).toFixed(0)}%)`);
  return { fled:false };
}

/* =========================================================
   SOUND (safe no-audio fallback)
========================================================= */
function playStealSound(){ /* optional later */ }
function playBlockSound(){ /* optional later */ }

/* =========================================================
   ENEMY GENERATION
========================================================= */
const TRAIT_STEAL_CHANCE = 0.22;

function genEnemyBase(){
  const enemy = {
    id:"enemy_"+Math.random().toString(36).slice(2,8),
    name: "Enemy",
    race: randomFrom(RACE_OPTIONS),
    powers:[],
    weapons:[],
    armors:[],
    clan: randomFrom(CLAN_OPTIONS),
    trainer: randomFrom(TRAINER_OPTIONS),
    powerMastery: randomFrom(POWER_MASTERY_OPTIONS),
    transformation: randomFrom(TRANSFORM_OPTIONS),
    transformDetail:null,

    strengthW: randomFrom(STRENGTH_WORDS),
    speedW: randomFrom(SPEED_WORDS),
    durabilityW: randomFrom(DUR_WORDS),
    fightW: randomFrom(FIGHT_WORDS),
    iqW: randomFrom(IQ_WORDS),
    luckW: String(1+Math.floor(Math.random()*10))
  };

  if(Math.random() < 0.75) enemy.powers.push(randomFrom(POWER_OPTIONS));
  if(Math.random() < 0.75) enemy.weapons.push(randomFrom(WEAPON_OPTIONS));
  if(Math.random() < 0.65) enemy.armors.push(randomFrom(ARMOR_OPTIONS));

  if(enemy.transformation === "Kaioken") enemy.transformDetail = {kind:"kaioken", value: randomFrom(KAIOKEN_OPTIONS)};
  if(enemy.transformation === "Eight Gates") enemy.transformDetail = {kind:"gates", value: randomFrom(GATES_OPTIONS)};
  if(enemy.transformation === "Super Saiyan") enemy.transformDetail = {kind:"ssj", value: randomFrom(SAIYAN_FORM_OPTIONS)};
  if(enemy.transformation === "Titan Transformation") enemy.transformDetail = {kind:"titan", value: randomFrom(TITAN_TYPE_OPTIONS)};
  if(enemy.transformation === "Tailed Beast") enemy.transformDetail = {kind:"tailed", value: randomFrom(TAILED_BEAST_OPTIONS)};

  enemy.powers = enemy.powers.filter(x=>x && x!=="No Power");
  enemy.weapons = enemy.weapons.filter(x=>x && x!=="No Weapon");
  enemy.armors = enemy.armors.filter(x=>x && x!=="No Armor");

  return enemy;
}

/* =========================================================
   SOUL STONE
========================================================= */
function hasSoulStone(char){
  return (char.weapons || []).includes("Infinity Gauntlet");
}
async function soulStonePickBonus(){
  const choices = [
    { label:"+1 Strength", value:"strength" },
    { label:"+1 Speed", value:"speed" },
    { label:"+1 Durability", value:"durability" },
    { label:"+1 Fight", value:"fight" },
    { label:"+1 IQ", value:"iq" },
  ];
  const picked = await openChoiceModal({
    title:"Soul Stone",
    sub:"Choose a permanent +1 bonus stat.",
    options: choices
  });
  if(!picked) return;
  state.progress.soulsCaptured = (state.progress.soulsCaptured || 0) + 1;
  state.progress.soulBonus[picked] = (state.progress.soulBonus[picked] || 0) + 1;
  saveState();
  toast(`Soul captured: +1 ${picked.toUpperCase()}`);
}

/* =========================================================
   ADAPTATION stacks
========================================================= */
function applyAdaptationWin(char){
  if(!(char.powers || []).includes("Adaptation")) return;
  state.progress.adaptationStacks = (state.progress.adaptationStacks || 0) + 1;
  saveState();
}

/* =========================================================
   STEAL / COPY (additive)
========================================================= */
function showStealPopup(text){
  const p = $("stealPopup");
  if(!p) return;
  p.textContent = text;
  p.classList.remove("hidden");
  setTimeout(()=>p.classList.add("hidden"), 1100);
}
function playStealAnim(text){
  const wrap = $("stealAnim");
  const chip = $("stealChip");
  if(!wrap || !chip) return;

  wrap.classList.remove("hidden");
  chip.textContent = text;
  chip.style.left = "50%";
  chip.style.top = "18%";

  chip.classList.remove("flyNow");
  void chip.offsetWidth;
  chip.classList.add("flyNow");

  setTimeout(()=>wrap.classList.add("hidden"), 750);
}

function enemyTraitsPool(enemy){
  const pool = [];
  (enemy.powers||[]).forEach(x => x && x!=="No Power" && pool.push({kind:"power", value:x}));
  (enemy.weapons||[]).forEach(x => x && x!=="No Weapon" && pool.push({kind:"weapon", value:x}));
  (enemy.armors||[]).forEach(x => x && x!=="No Armor" && pool.push({kind:"armor", value:x}));
  if(enemy.clan && enemy.clan!=="No Clan") pool.push({kind:"clan", value:enemy.clan});
  if(enemy.trainer && enemy.trainer!=="No Trainer") pool.push({kind:"trainer", value:enemy.trainer});
  if(enemy.transformation && enemy.transformation!=="None") pool.push({kind:"transform", value:enemy.transformation});
  return pool;
}

function addTraitToPlayer(tr){
  const c = ensureActiveLiving();
  if(!c) return;

  if(tr.kind === "power"){
    c.powers ||= [];
    if(!c.powers.includes(tr.value)) c.powers.push(tr.value);
  }
  if(tr.kind === "weapon"){
    c.weapons ||= [];
    if(!c.weapons.includes(tr.value)) c.weapons.push(tr.value);
  }
  if(tr.kind === "armor"){
    c.armors ||= [];
    if(!c.armors.includes(tr.value)) c.armors.push(tr.value);
  }
  if(tr.kind === "clan"){
    // additive list (does not overwrite)
    c.fusions ||= [];
    if(!c.fusions.includes(`Clan:${tr.value}`)) c.fusions.push(`Clan:${tr.value}`);
  }
  if(tr.kind === "trainer"){
    c.fusions ||= [];
    if(!c.fusions.includes(`Trainer:${tr.value}`)) c.fusions.push(`Trainer:${tr.value}`);
  }
  if(tr.kind === "transform"){
    c.fusions ||= [];
    if(!c.fusions.includes(`Transform:${tr.value}`)) c.fusions.push(`Transform:${tr.value}`);
  }

  state.character = c;
  saveState();
}

async function maybeStealTrait(enemy, logger){
  const now = Date.now();
  if(now - (state.progress.lastStolenAt || 0) < 5000) return;

  const pool = enemyTraitsPool(enemy);
  if(pool.length === 0) return;
  if(!roll(TRAIT_STEAL_CHANCE)) return;

  const pick = randomFrom(pool);
  addTraitToPlayer(pick);

  state.progress.lastStolenAt = now;
  saveState();

  showStealPopup(`Stole ${pick.kind}: ${pick.value}`);
  playStealAnim(`+ ${pick.value}`);
  playStealSound();
  logger(`Stole ${pick.kind}: ${pick.value} (additive).`);
}

/* =========================================================
   LOOT MODAL
========================================================= */
function openLootModal({title, sub, rewards, traitEvents, progress}){
  const modal = $("lootModal");
  if(!modal) return;

  $("lootTitle").textContent = title || "Victory";
  $("lootSub").textContent = sub || "";

  const makeRow = (x) => {
    const row = document.createElement("div");
    row.className = "lootRow";
    row.innerHTML = `
      <div class="lootLeft">
        <div class="lootLabel">${escapeHtml(x.label||"")}</div>
        <div class="lootNote">${escapeHtml(x.note||"")}</div>
      </div>
      <div class="lootValue">${escapeHtml(x.value||"")}</div>
    `;
    return row;
  };

  const rHost = $("lootRewards");
  const tHost = $("lootTrait");
  const pHost = $("lootProgress");

  rHost.innerHTML = "";
  tHost.innerHTML = "";
  pHost.innerHTML = "";

  (rewards||[]).forEach(x=>rHost.appendChild(makeRow(x)));
  (traitEvents||[]).forEach(x=>tHost.appendChild(makeRow(x)));
  (progress||[]).forEach(x=>pHost.appendChild(makeRow(x)));

  modal.classList.remove("hidden");
}
$("lootCloseBtn")?.addEventListener("click", ()=>$("lootModal")?.classList.add("hidden"));
$("lootOkBtn")?.addEventListener("click", ()=>$("lootModal")?.classList.add("hidden"));

/* =========================================================
   PvP (2 strikes)
========================================================= */
async function startPVP(){
  const player = ensureActiveLiving();
  if(!player){
    toast("Press New Build first.");
    return;
  }
  if(player.dead){
    toast("That character is dead.");
    return;
  }
  if(!player.wheelLocked || player.phase !== "transform"){
    toast("Finish the wheel first.");
    return;
  }

  $("pvpLog").innerHTML = "";
  const enemy = genEnemyBase();

  // portraits safe
  applyRaceBase(player, "p_"); applyRigFraming(player, "p_charFrame"); applyDemiTraits(player, "p_"); applyIdleFx(player, "p_");
  applyRaceBase(enemy, "e_"); applyRigFraming(enemy, "e_charFrame"); applyDemiTraits(enemy, "e_"); applyIdleFx(enemy, "e_");

  $("p_roleTag").textContent = player.name ? player.name : "You";
  $("e_roleTag").textContent = "Opponent";

  const pStats = computeFinalStats(player);
  const eStats = computeFinalStats(enemy);

  let pHP = computeHP(pStats);
  let eHP = computeHP(eStats);
  let pMax = pHP, eMax = eHP;

  setHP("p_hp", 1); setHP("e_hp", 1);

  logPVP(`Match started vs ${enemy.race}.`);
  if(pStats.isCursed) logPVP(`The arena laughsâ€¦ cursed build detected.`);
  if(eStats.isCursed) logPVP(`Opponent is cursed too.`);

  let turn = 0;
  while(pHP > 0 && eHP > 0 && turn < 60){
    turn++;

    if(pHP / pMax <= FLEE_HP_THRESHOLD){
      const flee = tryFlee(pStats, eStats, logPVP);
      if(flee.fled){
        logPVP("You fled the match.");
        return;
      }
    }

    const playerFirst = (pStats.speed + Math.random()*3) >= (eStats.speed + Math.random()*3);

    const doHit = (attStats, defStats, target) => {
      const dmg = computeDamage(attStats, defStats);
      if(target === "enemy"){
        eHP -= dmg;
        logPVP(`You hit for ${dmg}.`);
        setHP("e_hp", eHP/eMax);
      } else {
        pHP -= dmg;
        logPVP(`Enemy hit for ${dmg}.`);
        setHP("p_hp", pHP/pMax);
      }
    };

    if(playerFirst){
      doHit(pStats, eStats, "enemy");
      if(eHP > 0) doHit(eStats, pStats, "player");
    } else {
      doHit(eStats, pStats, "player");
      if(pHP > 0) doHit(pStats, eStats, "enemy");
    }

    await maybeStealTrait(enemy, logPVP);
    await new Promise(r=>setTimeout(r, 80));
  }

  if(pHP <= 0){
    player.strikesPVP = (player.strikesPVP || 0) + 1;
    saveState();
    logPVP(`Defeat. PvP strike ${player.strikesPVP}/2`);

    if(player.strikesPVP >= 2){
      killActive("PvP: 2 strikes");
      logPVP("â˜ ï¸ Your character is dead (PvP 2 strikes).");
    } else {
      toast("PvP strike gained (2 = death).");
      refreshUI();
    }
    playBlockSound();
    return;
  }

  logPVP("Victory!");
  state.progress.pvpWins = (state.progress.pvpWins || 0) + 1;
  state.currency.coins = (state.currency.coins || 0) + 20;
  state.currency.xp = (state.currency.xp || 0) + 10;
  saveState();

  applyAdaptationWin(player);

  if(hasSoulStone(player)){
    await soulStonePickBonus();
  }

  openLootModal({
    title:"PvP Victory",
    sub:`You defeated a ${enemy.race}.`,
    rewards:[
      {label:"Coins", note:"+20", value:`${state.currency.coins}`},
      {label:"XP", note:"+10", value:`${state.currency.xp}`},
    ],
    traitEvents:[
      {label:"Steal Chance", note:"Possible", value:""},
      {label:"Adaptation", note:(player.powers||[]).includes("Adaptation") ? "+1 stack" : "â€”", value:`${state.progress.adaptationStacks||0}`},
      {label:"Souls", note:hasSoulStone(player) ? "+1 if chosen" : "â€”", value:`${state.progress.soulsCaptured||0}`},
    ],
    progress:[
      {label:"PvP Wins", note:"+1", value:`${state.progress.pvpWins}`},
    ]
  });

  refreshUI();
}

/* =========================================================
   PvE (1 strike)
========================================================= */
async function startPVE(){
  const player = ensureActiveLiving();
  if(!player){
    toast("Press New Build first.");
    return;
  }
  if(player.dead){
    toast("That character is dead.");
    return;
  }
  if(!player.wheelLocked || player.phase !== "transform"){
    toast("Finish the wheel first.");
    return;
  }

  $("pveLog").innerHTML = "";
  const enemy = genEnemyBase();
  enemy.name = "Event Enemy";
  enemy.powerMastery = randomFrom(["Controlled","Mastered","Cosmic","Universal"]);
  if(Math.random() < 0.9) enemy.powers.push(randomFrom(POWER_OPTIONS));

  applyRaceBase(player, "pve_p_"); applyRigFraming(player, "pve_p_charFrame"); applyDemiTraits(player, "pve_p_"); applyIdleFx(player, "pve_p_");
  applyRaceBase(enemy, "pve_e_"); applyRigFraming(enemy, "pve_e_charFrame"); applyDemiTraits(enemy, "pve_e_"); applyIdleFx(enemy, "pve_e_");

  $("pve_p_roleTag").textContent = player.name ? player.name : "You";
  $("pve_e_roleTag").textContent = enemy.name;

  const pStats = computeFinalStats(player);
  const eStats = computeFinalStats(enemy);

  let pHP = computeHP(pStats);
  let eHP = computeHP(eStats) + 30;
  let pMax = pHP, eMax = eHP;

  setHP("pve_p_hp", 1); setHP("pve_e_hp", 1);

  logPVE(`PvE started vs ${enemy.race}.`);
  if(pStats.isCursed) logPVE(`The enemy taunts your cursed auraâ€¦`);

  let turn = 0;
  while(pHP > 0 && eHP > 0 && turn < 70){
    turn++;

    if(pHP / pMax <= FLEE_HP_THRESHOLD){
      const flee = tryFlee(pStats, eStats, logPVE);
      if(flee.fled){
        logPVE("You escaped the event.");
        return;
      }
    }

    const playerFirst = (pStats.speed + Math.random()*3) >= (eStats.speed + Math.random()*3);

    const hit = (att, def, target) => {
      const dmg = computeDamage(att, def);
      if(target === "enemy"){
        eHP -= dmg;
        logPVE(`You dealt ${dmg}.`);
        setHP("pve_e_hp", eHP/eMax);
      } else {
        pHP -= dmg;
        logPVE(`Enemy dealt ${dmg}.`);
        setHP("pve_p_hp", pHP/pMax);
      }
    };

    if(playerFirst){
      hit(pStats, eStats, "enemy");
      if(eHP > 0) hit(eStats, pStats, "player");
    } else {
      hit(eStats, pStats, "player");
      if(pHP > 0) hit(pStats, eStats, "enemy");
    }

    await new Promise(r=>setTimeout(r, 80));
  }

  if(pHP <= 0){
    player.strikesPVE = (player.strikesPVE || 0) + 1;
    saveState();
    logPVE("Defeat. PvE strike 1/1");
    killActive("PvE: 1 strike");
    logPVE("â˜ ï¸ Your character is dead (PvE 1 strike).");
    playBlockSound();
    refreshUI();
    return;
  }

  logPVE("Victory!");
  state.currency.coins = (state.currency.coins || 0) + 12;
  state.currency.xp = (state.currency.xp || 0) + 8;
  applyAdaptationWin(player);

  if(hasSoulStone(player) && Math.random() < 0.35){
    await soulStonePickBonus();
  }

  saveState();

  openLootModal({
    title:"PvE Victory",
    sub:`You won the event.`,
    rewards:[
      {label:"Coins", note:"+12", value:`${state.currency.coins}`},
      {label:"XP", note:"+8", value:`${state.currency.xp}`},
    ],
    traitEvents:[
      {label:"Adaptation", note:(player.powers||[]).includes("Adaptation") ? "+1 stack" : "â€”", value:`${state.progress.adaptationStacks||0}`},
      {label:"Souls", note:hasSoulStone(player) ? "possible" : "â€”", value:`${state.progress.soulsCaptured||0}`},
    ],
    progress:[]
  });

  refreshUI();
}

/* Hook up buttons */
$("pvpStartBtn")?.addEventListener("click", startPVP);
$("pveStartBtn")?.addEventListener("click", startPVE);

/* =========================================================
   FINAL: ensure roster + init wheel + UI
========================================================= */
ensureRoster();

// If there is no character yet, auto-create one
if(!ensureActiveLiving()){
  makeNewCharacter();
}

$("wheelTitle").textContent = phaseTitle(ensureActiveLiving()?.phase || "race");
$("wheelHint").textContent = "Spin to begin";
drawWheelPhase();
refreshUI();
</script>
<script>
/* =========================================================
   HOTFIX: Rebind Spin/Fast buttons to the NEW spinWheel
   (because Part 4 attached old function references)
========================================================= */
(function rebindSpinButtons(){
  const spin = $("spinBtn");
  const fast = $("testFastBtn");

  if(spin){
    // wipe old listeners by cloning
    const clone = spin.cloneNode(true);
    spin.parentNode.replaceChild(clone, spin);
    clone.addEventListener("click", ()=>spinWheel()); // calls latest spinWheel
  }

  if(fast){
    const clone2 = fast.cloneNode(true);
    fast.parentNode.replaceChild(clone2, fast);
    clone2.addEventListener("click", ()=>spinWheel());
  }
})();

/* =========================================================
   HOTFIX: Prevent Part 4 refreshUI from forcing "Race" title
========================================================= */
const _refreshUI_fix = refreshUI;
refreshUI = function(){
  _refreshUI_fix();

  const c = ensureActiveLiving?.() || state.character;
  if(!c) return;

  // keep wheel UI synced to phase
  $("wheelTitle").textContent = phaseTitle(c.phase || "race");
  $("wheelHint").textContent = c.wheelLocked && c.phase==="transform"
    ? "Build locked"
    : `Spin for ${phaseTitle(c.phase || "race")}`;

  drawWheelPhase();
};
</script>
