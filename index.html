<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Wheel RPG</title>

<style>
  :root{
    --bg:#0a0f1c;
    --panel:rgba(17,26,51,0.82);
    --panel2:rgba(24,34,74,0.92);
    --border:rgba(79,104,255,0.22);
    --text:#e8eeff;
    --muted:#9fb0ff;
    --accent:#4b7cff;
    --accent2:#6a94ff;
    --good:#36d399;
    --bad:#ff4b6e;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    background:var(--bg);
    color:var(--text);
    overflow-x:hidden;
  }
  #bgLayer{
    position:fixed; inset:0;
    background-size:cover;
    background-position:center;
    opacity:0.24;
    filter:saturate(1.1) contrast(1.05);
    transition: background-image .6s ease, opacity .6s ease;
    pointer-events:none;
  }
  #bgVignette{
    position:fixed; inset:0;
    background: radial-gradient(ellipse at center, rgba(0,0,0,0.18) 0%, rgba(0,0,0,0.72) 70%, rgba(0,0,0,0.88) 100%);
    pointer-events:none;
  }

  #app{position:relative; min-height:100vh; display:flex;}
  #main{flex:1; padding:16px; display:flex; flex-direction:column; gap:14px;}

  .panel{
    background:var(--panel);
    border:1px solid var(--border);
    border-radius:14px;
    padding:14px;
    backdrop-filter: blur(6px);
  }

  #topBar{
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:12px;
    flex-wrap:wrap;
  }
  .tabs{display:flex; gap:10px; flex-wrap:wrap;}
  .tab{
    cursor:pointer;
    font-weight:900;
    font-size:13px;
    padding:8px 10px;
    border-radius:10px;
    border:1px solid rgba(255,255,255,0.14);
    background:rgba(0,0,0,0.18);
  }
  .tab.active{
    background: rgba(79,104,255,0.25);
    border-color: rgba(79,104,255,0.5);
  }

  .btn{
    cursor:pointer;
    border:none;
    border-radius:10px;
    padding:10px 12px;
    font-weight:900;
    color:white;
    background:var(--accent);
  }
  .btn:hover{background:var(--accent2)}
  .btn:disabled{opacity:.45; cursor:not-allowed}
  .btn.secondary{
    background:rgba(255,255,255,0.08);
    border:1px solid rgba(255,255,255,0.14);
  }
  .btn.secondary:hover{background:rgba(255,255,255,0.12)}
  .btn.danger{background:#d63b57}
  .btn.danger:hover{background:var(--bad)}

  .row{display:flex; gap:14px; flex-wrap:wrap;}
  .big{font-size:20px; font-weight:1000}
  .muted{color:var(--muted)}

  #wheelBox{width:360px; display:flex; flex-direction:column; align-items:center; gap:10px;}
  #wheelTitle{font-size:18px; font-weight:1000}
  #wheelHint{color:var(--muted); font-size:12px; text-align:center}
  #pointer{
    width:0;height:0;
    border-left:14px solid transparent;
    border-right:14px solid transparent;
    border-bottom:22px solid rgba(255,255,255,0.92);
    margin-top:-6px;
    filter: drop-shadow(0px 3px 6px rgba(0,0,0,0.4));
  }
  canvas{
    border-radius:50%;
    background: rgba(0,0,0,0.22);
    border:2px solid rgba(79,104,255,0.35);
    box-shadow: 0 10px 30px rgba(0,0,0,0.42);
  }

  input{
    width:min(420px, 100%);
    padding:10px 12px;
    border-radius:10px;
    border:1px solid rgba(255,255,255,0.14);
    background: rgba(0,0,0,0.25);
    color: var(--text);
    outline:none;
  }
  .mono{
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    white-space:pre-wrap;
    color:rgba(255,255,255,0.92);
  }

  /* battle visuals */
  #battleArena{
    position:relative;
    min-height:260px;
    border-radius:14px;
    overflow:hidden;
    background: rgba(0,0,0,0.22);
    border:1px solid rgba(255,255,255,0.12);
  }
  #battleBg{
    position:absolute; inset:0;
    background-size:cover;
    background-position:center;
    opacity:0.36;
    transition: background-image .6s ease, opacity .6s ease;
  }
  #battleOverlay{
    position:absolute; inset:0;
    background: radial-gradient(ellipse at center, rgba(0,0,0,0.05) 0%, rgba(0,0,0,0.58) 70%, rgba(0,0,0,0.76) 100%);
  }
  #fighters{
    position:relative;
    height:260px;
    padding:14px;
    display:flex;
    justify-content:space-around;
    align-items:flex-end;
    gap:12px;
  }
  .fighter{
    width:42%;
    min-width:220px;
    max-width:380px;
    height:100%;
    display:flex;
    flex-direction:column;
    justify-content:flex-end;
    align-items:center;
    gap:8px;
    position:relative;
  }
  .portrait{
    width:170px;
    height:185px;
    border-radius:14px;
    border:2px solid rgba(79,104,255,0.35);
    background: rgba(0,0,0,0.28);
    box-shadow: 0 10px 25px rgba(0,0,0,0.35);
    display:flex;
    align-items:center;
    justify-content:center;
    text-align:center;
    padding:10px;
    position:relative;
    overflow:hidden;
  }
  .portrait .label{
    position:absolute;
    left:10px; right:10px; bottom:8px;
    font-size:12px;
    color: rgba(255,255,255,0.92);
    text-shadow: 0 2px 6px rgba(0,0,0,0.85);
    text-align:left;
    font-weight:900;
  }
  .hpbar{
    width:190px;
    height:12px;
    border-radius:999px;
    background: rgba(255,255,255,0.1);
    overflow:hidden;
    border:1px solid rgba(255,255,255,0.12);
  }
  .hpfill{
    height:100%;
    width:100%;
    background: linear-gradient(90deg, rgba(54,211,153,1), rgba(79,104,255,1));
    transition: width .25s ease;
  }
  .floatText{
    position:absolute;
    top:28px;
    font-weight:1000;
    opacity:0;
    transform: translateY(0px);
    transition: opacity .1s, transform .6s;
    pointer-events:none;
    text-shadow: 0 3px 10px rgba(0,0,0,0.85);
  }
  @keyframes shake{
    0%{transform:translate(0,0)}
    25%{transform:translate(-3px,2px)}
    50%{transform:translate(3px,-2px)}
    75%{transform:translate(-2px,-2px)}
    100%{transform:translate(0,0)}
  }
  .shake{animation:shake .25s linear;}

  /* codex list */
  .list{display:flex; flex-direction:column; gap:8px; max-height:320px; overflow:auto; padding-right:6px;}
  .item{
    padding:10px;
    border-radius:10px;
    border:1px solid rgba(255,255,255,0.12);
    background: rgba(0,0,0,0.18);
  }
  .item .small{font-size:12px; color:var(--muted); margin-top:4px}

  @media (max-width: 860px){
    #main{padding:12px}
    #wheelBox{width:100%}
  }
</style>
</head>

<body>
<div id="bgLayer"></div>
<div id="bgVignette"></div>

<div id="app">
  <main id="main">
    <div class="panel" id="topBar">
      <div class="tabs">
        <div class="tab active" id="tab_build" onclick="setTab('build')">Build</div>
        <div class="tab" id="tab_stats" onclick="setTab('stats')">Stats</div>
        <div class="tab" id="tab_pve" onclick="setTab('pve')">PvE</div>
        <div class="tab" id="tab_pvp" onclick="setTab('pvp')">PvP</div>
        <div class="tab" id="tab_codex" onclick="setTab('codex')">Codex</div>
      </div>

      <div style="display:flex; align-items:center; gap:10px; flex-wrap:wrap;">
        <button class="btn secondary" onclick="finishBuildEarly()">Finish Build</button>

        <button class="btn secondary" id="btnMute" onclick="toggleMute()">ðŸ”Š</button>
        <div class="muted" style="font-size:12px;">Volume</div>
        <input id="volSlider" type="range" min="0" max="100" value="60"
               style="width:140px;" oninput="setVolumeFromSlider()">
      </div>
    </div>

    <!-- BUILD -->
    <section id="view_build" class="row">
      <div class="panel" style="flex:1;">
        <div class="row" style="align-items:flex-start;">
          <div id="wheelBox">
            <div id="wheelTitle">Spin for Race</div>
            <div id="wheelHint">Smoother spin + tick-per-slice + softer whoosh sound.</div>
            <div id="pointer"></div>
            <canvas id="wheelCanvas" width="320" height="320"></canvas>
            <button class="btn" id="spinBtn" onclick="startSpin()">SPIN</button>
            <div class="muted" style="font-size:12px;">
              Wheel order: Race â†’ Power â†’ Weapon â†’ Strength â†’ Durability â†’ Regen
            </div>
          </div>

          <div class="panel" style="flex:1; min-width:280px;">
            <div class="big" id="spinResult">Result: ---</div>
            <div class="muted" id="spinMeta" style="margin-top:6px;">---</div>

            <div style="margin-top:12px; border-top:1px solid rgba(255,255,255,0.12); padding-top:12px;">
              <div class="big">Name your character</div>
              <div class="muted" style="margin-top:6px;">
                After the last wheel, spinning locks and you name your character.
              </div>

              <div id="nameBox" style="display:none; margin-top:10px;">
                <input id="nameInput" maxlength="18" placeholder="Enter first name..." oninput="updateNamePreview()"/>
                <div style="margin-top:8px;">
                  <span class="muted">Preview:</span>
                  <span id="namePreview" style="font-weight:1000; margin-left:6px;"></span>
                </div>
                <div style="margin-top:10px; display:flex; gap:10px; flex-wrap:wrap;">
                  <button class="btn" onclick="confirmName()">Confirm Name</button>
                  <button class="btn secondary" onclick="skipName()">Skip</button>
                </div>
                <div id="nameError" style="color:var(--bad); margin-top:8px; font-weight:900;"></div>
              </div>
            </div>

            <div style="margin-top:12px; border-top:1px solid rgba(255,255,255,0.12); padding-top:12px;">
              <div class="big">Fusion</div>
              <div class="muted" id="fusionText" style="margin-top:6px;">---</div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- STATS -->
    <section id="view_stats" class="row" style="display:none;">
      <div class="panel" style="flex:1;">
        <div class="big">Your Character</div>
        <div class="muted" style="margin-top:6px;">Everything you rolled is shown here.</div>

        <div class="row" style="margin-top:12px;">
          <div class="panel" style="flex:1; min-width:260px;">
            <div class="muted">Name</div>
            <div class="big" id="s_name">---</div>
          </div>

          <div class="panel" style="flex:1; min-width:260px;">
            <div class="muted">Race</div>
            <div class="big" id="s_race">---</div>
          </div>

          <div class="panel" style="flex:1; min-width:260px;">
            <div class="muted">Power</div>
            <div class="big" id="s_power">---</div>
          </div>

          <div class="panel" style="flex:1; min-width:260px;">
            <div class="muted">Weapon</div>
            <div class="big" id="s_weapon">---</div>
          </div>
        </div>

        <div class="row" style="margin-top:12px;">
          <div class="panel" style="flex:1; min-width:260px;">
            <div class="muted">Strength</div>
            <div class="big" id="s_str">---</div>
          </div>

          <div class="panel" style="flex:1; min-width:260px;">
            <div class="muted">Durability</div>
            <div class="big" id="s_dur">---</div>
          </div>

          <div class="panel" style="flex:1; min-width:260px;">
            <div class="muted">Regen</div>
            <div class="big" id="s_regen">---</div>
          </div>

          <div class="panel" style="flex:1; min-width:260px;">
            <div class="muted">Fusion</div>
            <div class="big" id="s_fusion">---</div>
          </div>
        </div>

        <div style="margin-top:14px; display:flex; gap:10px; flex-wrap:wrap;">
          <button class="btn secondary" onclick="saveGame()">Save</button>
          <button class="btn secondary" onclick="loadGame()">Load</button>
          <button class="btn danger" onclick="resetGame()">Reset</button>
        </div>

        <div class="muted" style="margin-top:10px; font-size:12px;">
          DEV_MODE is ON for testing (no daily lock).
        </div>
      </div>
    </section>

    <!-- PVE -->
    <section id="view_pve" class="row" style="display:none;">
      <div class="panel" style="flex:1;">
        <div class="big">PvE Event Wheel</div>
        <div class="muted" style="margin-top:6px;">Spin an event, then fight the encounter.</div>

        <div style="margin-top:10px; display:flex; gap:10px; flex-wrap:wrap;">
          <button class="btn" onclick="spinEvent()">Spin Event</button>
          <button class="btn secondary" onclick="fightPvE()">Fight PvE</button>
        </div>

        <div style="margin-top:10px;">
          <div class="big" id="eventName">Event: ---</div>
          <div class="muted" id="eventDesc" style="margin-top:6px;">---</div>
        </div>

        <div style="margin-top:14px;">
          <div class="big">Battle Arena</div>
          <div id="battleArena" style="margin-top:10px;">
            <div id="battleBg"></div>
            <div id="battleOverlay"></div>
            <div id="fighters">
              <div class="fighter">
                <div class="portrait" id="p_portrait">
                  <div class="label" id="p_label">Player</div>
                  <div class="floatText" id="p_float"></div>
                  <div style="opacity:.85; font-size:13px;" id="p_portraitText">---</div>
                </div>
                <div class="hpbar"><div class="hpfill" id="p_hp"></div></div>
              </div>

              <div class="fighter">
                <div class="portrait" id="e_portrait">
                  <div class="label" id="e_label">Enemy</div>
                  <div class="floatText" id="e_float"></div>
                  <div style="opacity:.85; font-size:13px;" id="e_portraitText">---</div>
                </div>
                <div class="hpbar"><div class="hpfill" id="e_hp"></div></div>
              </div>
            </div>
          </div>

          <div class="mono" id="battleLog" style="margin-top:10px;">---</div>
        </div>
      </div>
    </section>

    <!-- PVP -->
    <section id="view_pvp" class="row" style="display:none;">
      <div class="panel" style="flex:1;">
        <div class="big">PvP Arena (Simulator)</div>
        <div class="muted" style="margin-top:6px;">
          Soft scaling (no caps). Lucky builds are stronger, but scaling prevents insane gaps.
        </div>

        <div style="margin-top:10px; display:flex; gap:10px; flex-wrap:wrap;">
          <button class="btn" onclick="simulatePvP()">Simulate PvP Fight</button>
          <button class="btn secondary" onclick="generateOpponent()">New Opponent</button>
        </div>

        <div style="margin-top:10px;">
          <div class="big">Opponent</div>
          <div class="muted" id="oppLine" style="margin-top:6px;">---</div>
        </div>

        <div class="mono" id="pvpLog" style="margin-top:10px;">---</div>
      </div>
    </section>

    <!-- CODEX -->
    <section id="view_codex" class="row" style="display:none;">
      <div class="panel" style="flex:1;">
        <div class="big">Codex</div>
        <div class="muted" style="margin-top:6px;">Fusions youâ€™ve discovered are saved here.</div>
        <div class="list" id="codexList" style="margin-top:12px;"></div>
      </div>
    </section>

  </main>
</div>

<script>
/* =========================
   SETTINGS
========================= */

const DEV_MODE = true;

const STORE_KEY = "wheel_rpg_save_full_v2";
const SOUND_STORE_KEY = "wheel_rpg_sound_v3";
const DAILY_BUILD_KEY = "wheel_rpg_last_build_day_v1";
const TIMEZONE = "America/Chicago";

/* =========================
   DATA (WHEELS)
========================= */

const WHEELS = {
  race: [
    "Human","Orc","Cyborg","Giant","Demi human","Golem","Dragon","Vampire","Hivemind","Shinigami",
    "Soul eater","Demon","Alien","God","Hybrid","Gnome","Goblin","Zombie","Skeleton"
  ],
  power: [
    "No power","Adaptation","Art creation","Bankai","Future sight","Gravity manipulation","Kaioken",
    "Titan transformation","Devil fruit","Necromancy","Immortal","Flight","Power eater","Tailed beast",
    "Ice manipulation","Time manipulation","Electric","Invisibility","Mimicry","Regeneration","Toon force",
    "Shapeshifting","Cloning","Final form","Weapon creation","Laser vision","Eight gates","Curse mark",
    "One for all","Heavenly restriction","Fire manipulation","Teleportation","Telekinesis","Golem creation"
  ],
  weapon: [
    "No weapon","Bow","Meatball launcher","Guitar","Nunchucks","Axe","Rocket launcher","Knife","Infinity gauntlet",
    "Daggers","Demon slayer sword","Omnitrix","Sword","Escanors axe","Scythe","Pistol","Wooden shield",
    "Blades of chaos","Samehada","Green lantern ring","Uzumaki chains","Magic staff","Bat","Water gun","Hammer",
    "Brass knuckles","Piece of bread","Stick"
  ],
  strength: [5,10,15,20,25,30,35,40,50,60,70,80,90,100],
  durability: [10,15,20,25,30,40,50,60,70,80,90,100],
  regen: [0,1,2,3,4,5,6,7,8,9,10]
};

function rarityPercentFor(category, value){
  const arr = WHEELS[category].map(String);
  const idx = arr.indexOf(String(value));
  if(idx < 0 || arr.length < 2) return 25;
  const p = 100 - Math.floor((idx/(arr.length-1))*90);
  return Math.max(1, Math.min(95, p));
}

/* =========================
   THEMES (Background hooks)
========================= */

const RACE_THEME = {
  Vampire: { img: "images/backgrounds/castle.svg",     grad: "linear-gradient(135deg, rgba(120,0,30,.55), rgba(0,0,0,.75))" },
  Golem:   { img: "images/backgrounds/cave.svg",       grad: "linear-gradient(135deg, rgba(90,70,40,.55), rgba(0,0,0,.75))" },
  Goblin:  { img: "images/backgrounds/forest.svg",     grad: "linear-gradient(135deg, rgba(0,110,60,.50), rgba(0,0,0,.75))" },
  Human:   { img: "images/backgrounds/city.svg",       grad: "linear-gradient(135deg, rgba(30,70,140,.50), rgba(0,0,0,.75))" },
  God:     { img: "images/backgrounds/celestial.svg",  grad: "linear-gradient(135deg, rgba(140,120,255,.45), rgba(0,0,0,.75))" },
  Default: { img: "images/backgrounds/default_arena.svg", grad: "linear-gradient(135deg, rgba(79,104,255,.30), rgba(0,0,0,.78))" }
};

function applyRaceTheme(race){
  const bgLayer = document.getElementById("bgLayer");
  const theme = RACE_THEME[race] || RACE_THEME.Default;

  // cache-buster so GitHub Pages updates immediately if you change images
  const bust = `?v=${encodeURIComponent(race)}_${Date.now()}`;

  // Always show a visible change (gradient), then image on top if it loads
  bgLayer.style.backgroundImage = `${theme.grad}, url('${theme.img}${bust}')`;
  bgLayer.style.opacity = 0.30; // a bit stronger so itâ€™s obvious
  bgLayer.style.backgroundSize = "cover";
  bgLayer.style.backgroundPosition = "center";
}

/* =========================
   FUSIONS (Starter examples)
========================= */

const FUSIONS = [
  { conditions:["Vampire","Regeneration"], result:"Blood Overlord", tier:"Rare" },
  { conditions:["Golem","Fire manipulation"], result:"Magma Titan", tier:"Rare" },
  { conditions:["Human","Tailed beast"], result:"Perfect Jinchuriki", tier:"Legendary" },
  { conditions:["God","Time manipulation"], result:"Time Deity", tier:"Legendary" },
  { conditions:["Soul eater","Necromancy"], result:"Death Monarch", tier:"Rare" },
  { conditions:["Toon force","God"], result:"Cartoon Creator", tier:"Divine" }
];
  
function findFusion(traits){
  for(const f of FUSIONS){
    if(f.conditions.every(c => traits.includes(c))) return f;
  }
  return null;
}

/* =========================
   STATE + SAVE
========================= */

let state = {
  tab: "build",
  buildStep: 0,
  spinning: false,
  buildLocked: false,

  character: {
    name: "",
    lockedLastName: "",
    race: null,
    power: null,
    weapon: null,
    strength: null,
    durability: null,
    regen: null,
    fusion: null
  },

  codex: { fusions: [] },
  pve: { currentEvent: null },
  pvp: { opponent: null }
};

function saveGame(){
  localStorage.setItem(STORE_KEY, JSON.stringify(state));
  toast("Saved!");
}
function loadGame(){
  const raw = localStorage.getItem(STORE_KEY);
  if(!raw){ refreshUI(); refreshCodex(); return; }
  try{
    state = JSON.parse(raw);
    refreshUI();
    refreshCodex();
    toast("Loaded!");
  }catch{
    toast("Save corrupted.");
  }
}
function resetGame(){
  localStorage.removeItem(STORE_KEY);

  state.buildStep = 0;
  state.spinning = false;
  state.buildLocked = false;

  state.character = { name:"", lockedLastName:"", race:null, power:null, weapon:null, strength:null, durability:null, regen:null, fusion:null };
  state.codex = { fusions:[] };
  state.pve = { currentEvent:null };
  state.pvp = { opponent:null };

  setTab("build");
  refreshUI();
  refreshCodex();
  toast("Reset complete.");
}

/* =========================
   DAILY BUILD LOCK HELPERS
========================= */

function getTodayKeyTZ(){
  return new Intl.DateTimeFormat("en-CA", {
    timeZone: TIMEZONE,
    year: "numeric",
    month: "2-digit",
    day: "2-digit"
  }).format(new Date());
}
function msUntilNextLocalMidnight(){
  const now = new Date();
  const next = new Date(now);
  next.setHours(24,0,0,0);
  return Math.max(0, next - now);
}
function formatCountdown(ms){
  const totalMin = Math.ceil(ms / 60000);
  const h = Math.floor(totalMin / 60);
  const m = totalMin % 60;
  return `${h}h ${m}m`;
}

/* =========================
   PROCEDURAL SOUND ENGINE (Softer whoosh)
========================= */

let soundState = { volume: 0.6, muted: false };
let lastTickSliceIndex = null;

function loadSoundSettings(){
  const raw = localStorage.getItem(SOUND_STORE_KEY);
  if(raw){
    try{
      const saved = JSON.parse(raw);
      if(typeof saved.volume === "number") soundState.volume = saved.volume;
      if(typeof saved.muted === "boolean") soundState.muted = saved.muted;
    }catch{}
  }
  syncSoundUI();
  setMasterVolume(soundState.volume);
}
function saveSoundSettings(){
  localStorage.setItem(SOUND_STORE_KEY, JSON.stringify(soundState));
}
function syncSoundUI(){
  const slider = document.getElementById("volSlider");
  const btn = document.getElementById("btnMute");
  if(slider) slider.value = Math.round(soundState.volume * 100);
  if(btn) btn.textContent = soundState.muted ? "ðŸ”‡" : "ðŸ”Š";
}
function setVolumeFromSlider(){
  const slider = document.getElementById("volSlider");
  if(!slider) return;
  soundState.volume = Math.max(0, Math.min(1, Number(slider.value)/100));
  setMasterVolume(soundState.volume);
  saveSoundSettings();
}
function toggleMute(){
  soundState.muted = !soundState.muted;
  setMasterVolume(soundState.volume);
  syncSoundUI();
  saveSoundSettings();
}

const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx = null;
let masterGain = null;

// spin layers
let spinWhirr = null;
let spinNoise = null;
let spinNoiseGain = null;

function ensureAudio(){
  if(audioCtx) return;
  audioCtx = new AudioCtx();
  masterGain = audioCtx.createGain();
  masterGain.connect(audioCtx.destination);
  setMasterVolume(soundState.volume);
}
function setMasterVolume(v){
  if(!masterGain) return;
  masterGain.gain.value = soundState.muted ? 0 : v;
}

document.addEventListener("touchstart", ()=>{ ensureAudio(); audioCtx.resume(); }, { once:true });
document.addEventListener("click", ()=>{ ensureAudio(); audioCtx.resume(); }, { once:true });

function tone(freq, duration, type="sine", gain=0.2){
  ensureAudio();
  const t0 = audioCtx.currentTime;
  const osc = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  osc.type = type;
  osc.frequency.setValueAtTime(freq, t0);
  g.gain.setValueAtTime(Math.max(0.001,gain), t0);
  g.gain.exponentialRampToValueAtTime(0.001, t0 + duration);
  osc.connect(g); g.connect(masterGain);
  osc.start(t0); osc.stop(t0 + duration);
}
function noise(duration=0.06, gain=0.15, filterHz=2500){
  ensureAudio();
  const t0 = audioCtx.currentTime;
  const len = Math.floor(audioCtx.sampleRate * duration);
  const buffer = audioCtx.createBuffer(1, len, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);
  for(let i=0;i<len;i++) data[i] = (Math.random()*2 - 1) * (1 - i/len);

  const src = audioCtx.createBufferSource();
  src.buffer = buffer;

  const filt = audioCtx.createBiquadFilter();
  filt.type = "lowpass";
  filt.frequency.setValueAtTime(filterHz, t0);

  const g = audioCtx.createGain();
  g.gain.setValueAtTime(gain, t0);
  g.gain.exponentialRampToValueAtTime(0.001, t0 + duration);

  src.connect(filt); filt.connect(g); g.connect(masterGain);
  src.start(t0);
}
function playTick(){
  noise(0.02, 0.10, 3600);
  tone(1180, 0.02, "square", 0.05);
}

function playSpinLoop(){
  ensureAudio();
  stopSpinLoop();
  const t0 = audioCtx.currentTime;

  spinWhirr = audioCtx.createOscillator();
  const whirrGain = audioCtx.createGain();
  const whirrFilter = audioCtx.createBiquadFilter();

  spinWhirr.type = "triangle";
  spinWhirr.frequency.setValueAtTime(120, t0);

  whirrFilter.type = "lowpass";
  whirrFilter.frequency.setValueAtTime(900, t0);
  whirrFilter.Q.setValueAtTime(0.6, t0);

  whirrGain.gain.setValueAtTime(0.001, t0);
  whirrGain.gain.exponentialRampToValueAtTime(0.035, t0 + 0.10);

  const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 1.0, audioCtx.sampleRate);
  const d = buffer.getChannelData(0);
  for(let i=0;i<d.length;i++) d[i] = Math.random()*2 - 1;

  spinNoise = audioCtx.createBufferSource();
  spinNoise.buffer = buffer;
  spinNoise.loop = true;

  const noiseFilter = audioCtx.createBiquadFilter();
  noiseFilter.type = "bandpass";
  noiseFilter.frequency.setValueAtTime(850, t0);
  noiseFilter.Q.setValueAtTime(0.75, t0);

  spinNoiseGain = audioCtx.createGain();
  spinNoiseGain.gain.setValueAtTime(0.001, t0);
  spinNoiseGain.gain.exponentialRampToValueAtTime(0.030, t0 + 0.12);

  spinWhirr.connect(whirrFilter);
  whirrFilter.connect(whirrGain);
  whirrGain.connect(masterGain);

  spinNoise.connect(noiseFilter);
  noiseFilter.connect(spinNoiseGain);
  spinNoiseGain.connect(masterGain);

  spinWhirr.start(t0);
  spinNoise.start(t0);
}

function stopSpinLoop(){
  if(!audioCtx) return;
  const t0 = audioCtx.currentTime;

  if(spinNoiseGain){
    spinNoiseGain.gain.cancelScheduledValues(t0);
    spinNoiseGain.gain.setValueAtTime(Math.max(0.001, spinNoiseGain.gain.value), t0);
    spinNoiseGain.gain.exponentialRampToValueAtTime(0.001, t0 + 0.10);
  }
  if(spinWhirr){ try{ spinWhirr.stop(t0 + 0.11); }catch{} spinWhirr = null; }
  if(spinNoise){ try{ spinNoise.stop(t0 + 0.11); }catch{} spinNoise = null; }
  spinNoiseGain = null;
}

function setSpinPitchFromVelocity(v){
  if(!audioCtx || !spinWhirr) return;
  const t0 = audioCtx.currentTime;

  const freq = 85 + v * 240;
  spinWhirr.frequency.setTargetAtTime(freq, t0, 0.04);

  if(spinNoiseGain){
    const ng = 0.010 + v * 0.045;
    spinNoiseGain.gain.setTargetAtTime(Math.max(0.001, ng), t0, 0.06);
  }
}

function playRarityStinger(percent){
  if(percent <= 2){
    tone(784, 0.18, "triangle", 0.20);
    setTimeout(()=>tone(988, 0.22, "triangle", 0.20), 60);
    setTimeout(()=>tone(1175, 0.28, "triangle", 0.20), 120);
  }else if(percent <= 6){
    tone(659, 0.16, "triangle", 0.18);
    setTimeout(()=>tone(988, 0.24, "triangle", 0.18), 80);
  }else if(percent <= 15){
    tone(523, 0.14, "triangle", 0.16);
    setTimeout(()=>tone(784, 0.18, "triangle", 0.14), 70);
  }else{
    tone(392, 0.08, "sine", 0.12);
  }
}
function playHit(){
  noise(0.04, 0.18, 1800);
  tone(160, 0.06, "square", 0.08);
}
function playWin(){
  tone(523, 0.14, "triangle", 0.20);
  setTimeout(()=>tone(659, 0.16, "triangle", 0.20), 70);
  setTimeout(()=>tone(784, 0.22, "triangle", 0.20), 140);
}
function playLose(){
  tone(220, 0.22, "triangle", 0.18);
  setTimeout(()=>tone(164, 0.28, "triangle", 0.16), 90);
}

/* =========================
   TABS
========================= */

function setTab(tab){
  state.tab = tab;

  document.getElementById("tab_build").classList.toggle("active", tab==="build");
  document.getElementById("tab_stats").classList.toggle("active", tab==="stats");
  document.getElementById("tab_pve").classList.toggle("active", tab==="pve");
  document.getElementById("tab_pvp").classList.toggle("active", tab==="pvp");
  document.getElementById("tab_codex").classList.toggle("active", tab==="codex");

  document.getElementById("view_build").style.display = tab==="build" ? "" : "none";
  document.getElementById("view_stats").style.display = tab==="stats" ? "" : "none";
  document.getElementById("view_pve").style.display = tab==="pve" ? "" : "none";
  document.getElementById("view_pvp").style.display = tab==="pvp" ? "" : "none";
  document.getElementById("view_codex").style.display = tab==="codex" ? "" : "none";
}

/* =========================
   WHEEL (Canvas)
========================= */

const canvas = document.getElementById("wheelCanvas");
const ctx = canvas.getContext("2d");

let wheelAngle = 0;
let spinVel = 0;
let targetStopAngle = 0;
let currentWheelItems = [];

function getCurrentStepKey(){
  return ["race","power","weapon","strength","durability","regen"][state.buildStep] || "race";
}
function wheelTitleFor(stepKey){
  return stepKey==="race" ? "Spin for Race" :
         stepKey==="power" ? "Spin for Power" :
         stepKey==="weapon" ? "Spin for Weapon" :
         stepKey==="strength" ? "Spin for Strength" :
         stepKey==="durability" ? "Spin for Durability" :
         stepKey==="regen" ? "Spin for Regen" : "Spin";
}
function setWheelItems(stepKey){
  currentWheelItems = WHEELS[stepKey].map(String);
  drawWheel();
}
function drawWheel(){
  const W = canvas.width, H = canvas.height;
  const cx = W/2, cy = H/2;
  const r = Math.min(W,H)/2 - 8;

  ctx.clearRect(0,0,W,H);
  const n = currentWheelItems.length;
  if(n === 0) return;

  const slice = (Math.PI*2)/n;

  ctx.beginPath();
  ctx.arc(cx, cy, r+2, 0, Math.PI*2);
  ctx.strokeStyle = "rgba(255,255,255,0.15)";
  ctx.lineWidth = 6;
  ctx.stroke();

  for(let i=0;i<n;i++){
    const a0 = wheelAngle + i*slice;
    const a1 = a0 + slice;

    ctx.beginPath();
    ctx.moveTo(cx,cy);
    ctx.arc(cx,cy,r,a0,a1);
    ctx.closePath();
    ctx.fillStyle = i%2===0 ? "rgba(79,104,255,0.35)" : "rgba(54,211,153,0.25)";
    ctx.fill();

    ctx.strokeStyle = "rgba(255,255,255,0.08)";
    ctx.lineWidth = 2;
    ctx.stroke();

    const label = currentWheelItems[i];
    const mid = (a0+a1)/2;
    ctx.save();
    ctx.translate(cx,cy);
    ctx.rotate(mid);
    ctx.textAlign = "right";
    ctx.fillStyle = "rgba(255,255,255,0.92)";
    ctx.font = "900 12px system-ui";
    ctx.fillText(shorten(label, 18), r-10, 4);
    ctx.restore();
  }

  ctx.beginPath();
  ctx.arc(cx,cy,36,0,Math.PI*2);
  ctx.fillStyle = "rgba(0,0,0,0.35)";
  ctx.fill();
  ctx.strokeStyle = "rgba(255,255,255,0.12)";
  ctx.lineWidth = 2;
  ctx.stroke();

  ctx.fillStyle = "rgba(255,255,255,0.9)";
  ctx.font = "1000 12px system-ui";
  ctx.textAlign = "center";
  ctx.fillText("SPIN", cx, cy+4);
}

function startSpin(){
  if(state.buildLocked){ toast("Character is locked. Reset to build again."); return; }
  if(!DEV_MODE){
    const today = getTodayKeyTZ();
    const lastBuild = localStorage.getItem(DAILY_BUILD_KEY);
    if(lastBuild === today){
      toast(`Daily build used. Come back in ${formatCountdown(msUntilNextLocalMidnight())}.`);
      return;
    }
  }
  if(state.spinning) return;

  const stepKey = getCurrentStepKey();
  setWheelItems(stepKey);

  state.spinning = true;
  document.getElementById("spinBtn").disabled = true;

  lastTickSliceIndex = null;
  playSpinLoop();

  const n = currentWheelItems.length;
  const slice = (Math.PI*2)/n;
  const resultIndex = Math.floor(Math.random()*n);

  const pointerAngle = -Math.PI/2;
  const sliceMid = (resultIndex + 0.5) * slice;
  const baseStop = pointerAngle - sliceMid;

  const spins = 5 + Math.floor(Math.random()*3);
  targetStopAngle = baseStop + spins * Math.PI*2;

  /* FIX: slower, less chaotic start speed */
  spinVel = 0.22 + Math.random()*0.08;

  animateSpin(stepKey, resultIndex);
}

function animateSpin(stepKey, resultIndex){
  /* FIX: smoother decel */
  const friction = 0.992;

  function frame(){
    wheelAngle += spinVel;

    const n = currentWheelItems.length;
    if(n > 0){
      const slice = (Math.PI*2)/n;
      const normalized = ((wheelAngle % (Math.PI*2)) + (Math.PI*2)) % (Math.PI*2);
      const sliceIndex = Math.floor(normalized / slice);

      if(lastTickSliceIndex === null) lastTickSliceIndex = sliceIndex;
      if(sliceIndex !== lastTickSliceIndex){
        lastTickSliceIndex = sliceIndex;
        playTick();
      }
    }

    setSpinPitchFromVelocity(spinVel);

    const remaining = targetStopAngle - wheelAngle;

    /* FIX: smoother approach and braking */
    if(remaining < 1.2){
      wheelAngle += remaining * 0.08;
      spinVel *= 0.955;
    }else{
      spinVel *= friction;
    }

    drawWheel();

    if(Math.abs(targetStopAngle - wheelAngle) < 0.01 && spinVel < 0.02){
      wheelAngle = targetStopAngle;
      drawWheel();

      state.spinning = false;
      document.getElementById("spinBtn").disabled = false;

      stopSpinLoop();

      const value = currentWheelItems[resultIndex];
      onSpinResult(stepKey, value);
      return;
    }

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
}

function onSpinResult(stepKey, value){
  const c = state.character;

  if(stepKey==="race") c.race = value;
  if(stepKey==="power") c.power = value;
  if(stepKey==="weapon") c.weapon = value;
  if(stepKey==="strength") c.strength = Number(value);
  if(stepKey==="durability") c.durability = Number(value);
  if(stepKey==="regen") c.regen = Number(value);

  if(stepKey==="race") applyRaceTheme(value);

  document.getElementById("spinResult").textContent = `Result: ${value}`;
  const rp = rarityPercentFor(stepKey, value);
  document.getElementById("spinMeta").textContent = `Rarity (placeholder): ${rp}%`;
  playRarityStinger(rp);

  state.buildStep++;
  if(state.buildStep > 5) state.buildStep = 6;

  updateFusion();
  refreshUI();

  if(isBuildComplete()){
    showNaming();
  }

  saveGame();
}

/* =========================
   BUILD FLOW + NAME
========================= */

function isBuildComplete(){
  const c = state.character;
  return c.race && c.power && c.weapon && c.strength!==null && c.durability!==null && c.regen!==null;
}
function showNaming(){
  state.buildLocked = true;
  document.getElementById("nameBox").style.display = "";
  document.getElementById("spinBtn").disabled = true;

  if(!DEV_MODE){
    localStorage.setItem(DAILY_BUILD_KEY, getTodayKeyTZ());
  }

  updateNamePreview();
  saveGame();
}

const BANNED = ["porn","sex","nazi","rape"];

function updateNamePreview(){
  const first = document.getElementById("nameInput").value.trim();
  const last = state.character.lockedLastName ? ` ${state.character.lockedLastName}` : "";
  document.getElementById("namePreview").textContent = (first || "") + last;
}
function confirmName(){
  const first = document.getElementById("nameInput").value.trim();
  const err = document.getElementById("nameError");

  if(!first){ err.textContent = "Name cannot be empty."; return; }

  const low = first.toLowerCase();
  for(const w of BANNED){
    if(low.includes(w)){ err.textContent = "That name isnâ€™t allowed."; return; }
  }

  const last = state.character.lockedLastName ? ` ${state.character.lockedLastName}` : "";
  state.character.name = first + last;

  err.textContent = "";
  document.getElementById("nameBox").style.display = "none";

  toast("Name saved!");
  refreshUI();
  saveGame();
}
function skipName(){
  state.character.name = "Unnamed";
  document.getElementById("nameBox").style.display = "none";
  refreshUI();
  saveGame();
}
function finishBuildEarly(){
  if(!state.character.race) state.character.race = "Human";
  if(!state.character.power) state.character.power = "No power";
  if(!state.character.weapon) state.character.weapon = "No weapon";
  if(state.character.strength===null) state.character.strength = 20;
  if(state.character.durability===null) state.character.durability = 30;
  if(state.character.regen===null) state.character.regen = 2;

  applyRaceTheme(state.character.race);
  updateFusion();
  refreshUI();

  if(isBuildComplete() && !state.character.name){
    showNaming();
  }
  toast("Build filled for testing.");
  saveGame();
}

/* =========================
   FUSION + CODEX
========================= */

function updateFusion(){
  const c = state.character;
  const traits = [c.race, c.power].filter(Boolean);
  const fusion = findFusion(traits);
  c.fusion = fusion ? fusion.result : null;

  document.getElementById("fusionText").textContent = fusion
    ? `${fusion.result} (Tier: ${fusion.tier}) unlocked by: ${fusion.conditions.join(" + ")}`
    : "No fusion found for current traits (yet).";

  if(fusion){
    discoverFusion(fusion.result, fusion.tier);
  }
}
function discoverFusion(name, tier){
  const list = state.codex.fusions;
  if(list.some(x => x.name === name)) return;
  list.unshift({ name, tier, discoveredAt: new Date().toISOString() });
  refreshCodex();
  toast(`Discovered fusion: ${name}!`);
}
function refreshCodex(){
  const box = document.getElementById("codexList");
  box.innerHTML = "";
  const list = state.codex.fusions;

  if(list.length === 0){
    box.innerHTML = `<div class="item"><div style="font-weight:1000;">No fusions discovered yet</div><div class="small">Spin traits and trigger your first fusion.</div></div>`;
    return;
  }

  for(const f of list){
    const el = document.createElement("div");
    el.className = "item";
    el.innerHTML = `
      <div style="font-weight:1000;">${escapeHtml(f.name)} <span class="muted" style="font-weight:900;">(${escapeHtml(f.tier)})</span></div>
      <div class="small">Discovered: ${new Date(f.discoveredAt).toLocaleString()}</div>
    `;
    box.appendChild(el);
  }
}

/* =========================
   PvE EVENTS + VISUAL FIGHT
========================= */

const PVE_EVENTS = [
  { name:"Golem Ambush", enemyRace:"Golem", enemyPower:"Golem creation", enemyWeapon:"Hammer", str:18, dur:55, regen:2, bg:"images/backgrounds/cave.svg",
    desc:"A heavy enemy rushes from the rocks." },
  { name:"Vampire Raid", enemyRace:"Vampire", enemyPower:"Regeneration", enemyWeapon:"Knife", str:16, dur:35, regen:5, bg:"images/backgrounds/castle.svg",
    desc:"Fast strikes and healing between attacks." },
  { name:"Forest Hunters", enemyRace:"Goblin", enemyPower:"Invisibility", enemyWeapon:"Bow", str:14, dur:25, regen:1, bg:"images/backgrounds/forest.svg",
    desc:"Quick ranged attacks from the shadows." },
  { name:"Divine Test", enemyRace:"God", enemyPower:"Time manipulation", enemyWeapon:"Magic staff", str:22, dur:40, regen:3, bg:"images/backgrounds/celestial.svg",
    desc:"A dangerous opponent bends the flow of battle." }
];

function spinEvent(){
  const ev = PVE_EVENTS[Math.floor(Math.random()*PVE_EVENTS.length)];
  state.pve.currentEvent = ev;
  document.getElementById("eventName").textContent = `Event: ${ev.name}`;
  document.getElementById("eventDesc").textContent = ev.desc;
  toast("Event selected!");
  saveGame();
}
function fightPvE(){
  if(!state.pve.currentEvent){ toast("Spin an event first."); return; }
  if(!isBuildComplete()){ toast("Finish your build first (or use Finish Build)."); return; }
  runBattle({
    mode:"pve",
    player: buildFighterFromCharacter(state.character),
    enemy: buildFighterFromEvent(state.pve.currentEvent),
    arenaBg: state.pve.currentEvent.bg || (RACE_THEME_BG[state.character.race] || RACE_THEME_BG.Default)
  });
}

function runBattle({mode, player, enemy, arenaBg}){
  const logEl = document.getElementById("battleLog");
  const bgEl = document.getElementById("battleBg");

  bgEl.style.backgroundImage = arenaBg ? `url('${arenaBg}')` : "";

  document.getElementById("p_label").textContent = `${state.character.name || "Player"} â€¢ ${player.race}`;
  document.getElementById("e_label").textContent = `Enemy â€¢ ${enemy.race}`;

  document.getElementById("p_portraitText").textContent = `${player.race}\n${player.power}\n${player.weapon}`;
  document.getElementById("e_portraitText").textContent = `${enemy.race}\n${enemy.power}\n${enemy.weapon}`;

  let pHP = player.maxHP, eHP = enemy.maxHP;
  const pMax = pHP, eMax = eHP;

  setHP("p_hp", pHP, pMax);
  setHP("e_hp", eHP, eMax);

  logEl.textContent = `${mode.toUpperCase()} BATTLE\n${player.race} vs ${enemy.race}\n\n`;

  let turn = 0;
  const maxTurns = 35;

  function step(){
    turn++;
    if(turn>maxTurns || pHP<=0 || eHP<=0){
      const winner =
        pHP<=0 && eHP<=0 ? "Draw" :
        pHP<=0 ? "Enemy Wins" :
        eHP<=0 ? "Player Wins" :
        (pHP>eHP ? "Player Wins (time)" : "Enemy Wins (time)");

      logEl.textContent += `\nResult: ${winner}\n`;

      if(winner.includes("Player Wins")) playWin();
      else if(winner.includes("Enemy Wins")) playLose();

      toast(winner);
      return;
    }

    let pDmg = Math.max(player.strength - enemy.durability*0.10, 1);
    let eDmg = Math.max(enemy.strength - player.durability*0.10, 1);

    pDmg = Math.max(pDmg, eMax*0.01);
    eDmg = Math.max(eDmg, pMax*0.01);

    eHP -= pDmg;
    pHP -= eDmg;

    pHP += Math.min(player.regen, pMax*0.10);
    eHP += Math.min(enemy.regen, eMax*0.10);

    pHP = Math.min(pHP, pMax);
    eHP = Math.min(eHP, eMax);

    playHit();
    popFloat("e_float", `-${pDmg.toFixed(0)}`);
    popFloat("p_float", `-${eDmg.toFixed(0)}`);
    shake("e_portrait");
    shake("p_portrait");

    setHP("p_hp", pHP, pMax);
    setHP("e_hp", eHP, eMax);

    logEl.textContent += `T${turn}: P=${Math.max(0,pHP).toFixed(0)}  E=${Math.max(0,eHP).toFixed(0)}\n`;

    if(turn>20){
      eHP -= pDmg*0.05*(turn-20);
      pHP -= eDmg*0.05*(turn-20);
    }

    setTimeout(step, 450);
  }
  step();
}

function setHP(id, hp, max){
  const pct = Math.max(0, Math.min(100, (hp/max)*100));
  document.getElementById(id).style.width = pct + "%";
}
function popFloat(id, text){
  const el = document.getElementById(id);
  el.textContent = text;
  el.style.color = "rgba(255,75,110,1)";
  el.style.opacity = "1";
  el.style.transform = "translateY(-24px)";
  setTimeout(()=>{
    el.style.opacity = "0";
    el.style.transform = "translateY(-46px)";
  }, 50);
  setTimeout(()=>{
    el.style.opacity = "0";
    el.style.transform = "translateY(0px)";
  }, 650);
}
function shake(portraitId){
  const el = document.getElementById(portraitId);
  el.classList.remove("shake");
  void el.offsetWidth;
  el.classList.add("shake");
}

/* =========================
   PvP (SOFT SCALING)
========================= */

function generateOpponent(){
  const opp = {
    name: "Opponent",
    race: WHEELS.race[Math.floor(Math.random()*WHEELS.race.length)],
    power: WHEELS.power[Math.floor(Math.random()*WHEELS.power.length)],
    weapon: WHEELS.weapon[Math.floor(Math.random()*WHEELS.weapon.length)],
    strength: Number(WHEELS.strength[Math.floor(Math.random()*WHEELS.strength.length)]),
    durability: Number(WHEELS.durability[Math.floor(Math.random()*WHEELS.durability.length)]),
    regen: Number(WHEELS.regen[Math.floor(Math.random()*WHEELS.regen.length)])
  };

  const fusion = findFusion([opp.race, opp.power]);
  opp.fusion = fusion ? fusion.result : null;

  state.pvp.opponent = opp;
  document.getElementById("oppLine").textContent =
    `${opp.race} | ${opp.power} | ${opp.weapon} | STR ${opp.strength} DUR ${opp.durability} REG ${opp.regen}` + (opp.fusion? ` | Fusion: ${opp.fusion}`:"");

  saveGame();
  toast("New opponent generated.");
}

function pvpScale(totalPower){
  return Math.pow(totalPower, 0.78) * 7;
}
function totalPowerFromStats(f){
  const bonus = f.bonusPower || 0;
  return (f.strength*2) + (f.durability*1.6) + (f.regen*25) + bonus;
}
function simulatePvP(){
  if(!isBuildComplete()){ toast("Finish your build first (or use Finish Build)."); return; }
  if(!state.pvp.opponent){ generateOpponent(); }

  const p = buildFighterFromCharacter(state.character);
  const e = buildFighterFromOpponent(state.pvp.opponent);

  const log = runBattleSimPvP(p, e);
  document.getElementById("pvpLog").textContent = log;
}
function runBattleSimPvP(player, enemy){
  const pTotal = totalPowerFromStats(player);
  const eTotal = totalPowerFromStats(enemy);

  const pScaled = pvpScale(pTotal);
  const eScaled = pvpScale(eTotal);

  let pHP = 120 + player.durability*2.2;
  let eHP = 120 + enemy.durability*2.2;
  const pMax = pHP, eMax = eHP;

  let turn = 0;
  const maxTurns = 40;

  let log = `PvP (soft scaling)\nPlayerScaled=${pScaled.toFixed(1)} EnemyScaled=${eScaled.toFixed(1)}\n\n`;

  while(pHP>0 && eHP>0 && turn<maxTurns){
    turn++;

    const pDmg = Math.max((pScaled/12) * rand(0.9,1.1), 1);
    const eDmg = Math.max((eScaled/12) * rand(0.9,1.1), 1);

    eHP -= pDmg;
    pHP -= eDmg;

    pHP += Math.min(player.regen, pMax*0.10);
    eHP += Math.min(enemy.regen, eMax*0.10);

    pHP = Math.min(pHP, pMax);
    eHP = Math.min(eHP, eMax);

    if(turn>25){
      eHP -= pDmg*0.05*(turn-25);
      pHP -= eDmg*0.05*(turn-25);
    }

    log += `T${turn}: P=${Math.max(0,pHP).toFixed(0)}  E=${Math.max(0,eHP).toFixed(0)}\n`;
  }

  let winner = "Draw";
  if(pHP<=0 && eHP>0) winner = "Enemy Wins";
  if(eHP<=0 && pHP>0) winner = "Player Wins";
  if(turn>=maxTurns){
    winner = pHP>eHP ? "Player Wins (time)" : "Enemy Wins (time)";
  }
  log += `\nResult: ${winner}\n`;
  return log;
}

/* =========================
   FIGHTER BUILDERS
========================= */

function buildFighterFromCharacter(c){
  const fusion = findFusion([c.race, c.power]);
  const bonusPower =
    fusion?.tier === "Rare" ? 80 :
    fusion?.tier === "Legendary" ? 150 :
    fusion?.tier === "Divine" ? 260 : 0;

  return {
    name: c.name || "Player",
    race: c.race,
    power: c.power,
    weapon: c.weapon,
    strength: c.strength,
    durability: c.durability,
    regen: c.regen,
    bonusPower,
    maxHP: 140 + c.durability*2.4
  };
}
function buildFighterFromEvent(ev){
  const fusion = findFusion([ev.enemyRace, ev.enemyPower]);
  const bonusPower =
    fusion?.tier === "Rare" ? 80 :
    fusion?.tier === "Legendary" ? 150 :
    fusion?.tier === "Divine" ? 260 : 0;

  return {
    name: "Enemy",
    race: ev.enemyRace,
    power: ev.enemyPower,
    weapon: ev.enemyWeapon,
    strength: ev.str,
    durability: ev.dur,
    regen: ev.regen,
    bonusPower,
    maxHP: 140 + ev.dur*2.4
  };
}
function buildFighterFromOpponent(o){
  const fusion = findFusion([o.race, o.power]);
  const bonusPower =
    fusion?.tier === "Rare" ? 80 :
    fusion?.tier === "Legendary" ? 150 :
    fusion?.tier === "Divine" ? 260 : 0;

  return {
    name: o.name || "Opponent",
    race: o.race,
    power: o.power,
    weapon: o.weapon,
    strength: o.strength,
    durability: o.durability,
    regen: o.regen,
    bonusPower
  };
}

/* =========================
   UI REFRESH + TOAST
========================= */

function refreshUI(){
  const stepKey = getCurrentStepKey();
  document.getElementById("wheelTitle").textContent = wheelTitleFor(stepKey);

  const c = state.character;

  document.getElementById("s_name").textContent = c.name || "---";
  document.getElementById("s_race").textContent = c.race || "---";
  document.getElementById("s_power").textContent = c.power || "---";
  document.getElementById("s_weapon").textContent = c.weapon || "---";
  document.getElementById("s_str").textContent = (c.strength ?? "---");
  document.getElementById("s_dur").textContent = (c.durability ?? "---");
  document.getElementById("s_regen").textContent = (c.regen ?? "---");
  document.getElementById("s_fusion").textContent = c.fusion || "---";

  document.getElementById("spinBtn").disabled = !!state.buildLocked;

  setWheelItems(stepKey);
}

function toast(msg){
  console.log(msg);
  const meta = document.getElementById("spinMeta");
  if(meta) meta.textContent = msg;
}

/* =========================
   UTIL
========================= */

function shorten(s, n){
  s = String(s);
  return s.length>n ? s.slice(0,n-1)+"â€¦" : s;
}
function rand(a,b){ return a + Math.random()*(b-a); }
function escapeHtml(s){
  return String(s)
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}

/* =========================
   INIT
========================= */

(function init(){
  loadSoundSettings();
  loadGame();

  if(!state.pvp.opponent) generateOpponent();

  applyRaceTheme(state.character.race || "Human");
  updateFusion();
  refreshCodex();
  refreshUI();
})();
</script>
</body>
</html>
