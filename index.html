<!-- âœ… PART 1 / 6 â€” index.html (start + <head> + CSS base) -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Wheel Forge</title>
  <style>
    :root{
      --bg:#0b0f17;
      --panel:#121a28;
      --panel2:#0f1623;
      --text:#e8eefc;
      --muted:rgba(232,238,252,.65);
      --good:#2ee59d;
      --bad:#ff4d6d;
      --warn:#ffcc66;
      --line:rgba(255,255,255,.10);
      --accent:#7aa8ff;
      --cursed:#ff2e55;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
      color:var(--text);
      background:var(--bg);
      overflow-x:hidden;
    }
    #bgImage{
      position:fixed; inset:0;
      background-size:cover;
      background-position:center;
      filter:saturate(1.05) contrast(1.05) brightness(.55);
      transform:scale(1.03);
      z-index:-2;
    }
    #bgShade{
      position:fixed; inset:0;
      background:radial-gradient(1000px 600px at 30% 10%, rgba(122,168,255,.25), transparent 60%),
                 linear-gradient(to bottom, rgba(0,0,0,.25), rgba(0,0,0,.75));
      z-index:-1;
    }
    .app{
      max-width:1120px;
      margin:0 auto;
      padding:18px 14px 80px;
    }
    header{
      display:flex; gap:10px; align-items:center; justify-content:space-between;
      padding:10px 12px;
      border:1px solid var(--line);
      background:rgba(18,26,40,.72);
      backdrop-filter: blur(10px);
      border-radius:14px;
    }
    .title{
      display:flex; flex-direction:column; line-height:1.1;
    }
    .title b{font-size:18px; letter-spacing:.2px}
    .title span{font-size:12px; color:var(--muted)}
    .pillRow{display:flex; gap:10px; align-items:center}
    .pill{
      font-size:12px;
      border:1px solid var(--line);
      padding:6px 10px;
      border-radius:999px;
      background:rgba(15,22,35,.85);
      color:var(--muted);
      white-space:nowrap;
    }
    .pill strong{color:var(--text)}
    .btn{
      border:1px solid var(--line);
      background:rgba(15,22,35,.85);
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      user-select:none;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:8px;
      font-weight:700;
      transition:transform .08s ease, filter .08s ease, opacity .15s ease;
    }
    .btn:active{transform:scale(.985)}
    .btn.primary{background:linear-gradient(135deg, rgba(122,168,255,.25), rgba(122,168,255,.06)); border-color:rgba(122,168,255,.35)}
    .btn.good{background:linear-gradient(135deg, rgba(46,229,157,.18), rgba(46,229,157,.06)); border-color:rgba(46,229,157,.35)}
    .btn.bad{background:linear-gradient(135deg, rgba(255,77,109,.20), rgba(255,77,109,.06)); border-color:rgba(255,77,109,.35)}
    .btn.ghost{background:transparent}
    .row{display:flex; gap:12px; flex-wrap:wrap}
    .grid{
      display:grid;
      grid-template-columns: 1.25fr .9fr;
      gap:12px;
      margin-top:12px;
    }
    @media (max-width:980px){
      .grid{grid-template-columns:1fr}
    }
    .card{
      border:1px solid var(--line);
      background:rgba(18,26,40,.72);
      backdrop-filter: blur(10px);
      border-radius:16px;
      padding:12px;
    }
    .card h2{
      margin:0 0 8px;
      font-size:15px;
      letter-spacing:.2px;
      color:rgba(232,238,252,.92);
    }
    .muted{color:var(--muted)}
    .tabs{
      display:flex; gap:10px; flex-wrap:wrap;
      margin-top:12px;
    }
    .tab{
      padding:9px 12px;
      border-radius:999px;
      border:1px solid var(--line);
      background:rgba(15,22,35,.65);
      cursor:pointer;
      font-weight:800;
      font-size:12px;
      color:rgba(232,238,252,.72);
    }
    .tab.active{
      color:var(--text);
      border-color:rgba(122,168,255,.45);
      background:rgba(122,168,255,.14);
    }
    .hidden{display:none !important;}
  </style>
</head>
<!-- âœ… PART 2 / 6 â€” CSS (portraits, stats lines, modals, animations) -->
<body>
  <div id="bgImage"></div>
  <div id="bgShade"></div>

  <div class="app">
    <header>
      <div class="title">
        <b>Wheel Forge</b>
        <span class="muted">Build â€¢ Stats â€¢ PvE â€¢ PvP</span>
      </div>
      <div class="pillRow">
        <div id="dailyPill" class="pill">Daily Build: <strong>â€¦</strong></div>
        <button id="volBtn" class="btn">ðŸ”Š</button>
        <button id="resetBtn" class="btn ghost">Reset</button>
      </div>
    </header>

    <div class="tabs">
      <div class="tab active" data-tab="build">BUILD</div>
      <div class="tab" data-tab="stats">STATS</div>
      <div class="tab" data-tab="pve">PvE</div>
      <div class="tab" data-tab="pvp">PvP</div>
      <div id="phaseTag" class="pill">Phase: â€¦</div>
      <div id="namedTag" class="pill">Not finalized</div>
    </div>

    <style>
      /* Portrait frames */
      .portraitWrap{display:flex; gap:12px; align-items:flex-start; flex-wrap:wrap}
      .frame{
        position:relative;
        width:260px;
        height:260px;
        border-radius:18px;
        border:1px solid var(--line);
        background:rgba(15,22,35,.65);
        overflow:hidden;
      }
      .frame.bigRig{width:300px;height:300px}
      .frame.cursed{box-shadow:0 0 0 2px rgba(255,46,85,.22), 0 0 36px rgba(255,46,85,.25) inset}
      .layer{
        position:absolute;
        inset:0;
        width:100%;
        height:100%;
        object-fit:contain;
        pointer-events:none;
      }
      .fx{mix-blend-mode:screen; opacity:.92}
      .fx.on{opacity:1}
      .idle-sway{animation:sway 3.0s ease-in-out infinite}
      .idle-heavy{animation:swayHeavy 3.6s ease-in-out infinite}
      @keyframes sway{0%,100%{transform:translateY(0)}50%{transform:translateY(4px)}}
      @keyframes swayHeavy{0%,100%{transform:translateY(0)}50%{transform:translateY(6px)}}

      .portraitUnlockPulse{animation:pulse .65s ease-out 1}
      @keyframes pulse{
        0%{transform:scale(1); box-shadow:0 0 0 0 rgba(46,229,157,.0)}
        35%{transform:scale(1.02); box-shadow:0 0 0 10px rgba(46,229,157,.12)}
        100%{transform:scale(1); box-shadow:0 0 0 0 rgba(46,229,157,.0)}
      }

      /* Wheel area */
      #wheelBox{display:flex; flex-direction:column; gap:10px}
      #wheelTitle{font-size:16px; font-weight:900}
      #wheelHint{font-size:12px; color:var(--muted)}
      canvas{width:100%; max-width:520px; height:auto; border-radius:16px; border:1px solid var(--line); background:rgba(0,0,0,.15)}
      .btnRow{display:flex; gap:10px; flex-wrap:wrap}

      /* Stats lines */
      .statList{display:grid; gap:8px}
      .statLine{
        display:flex; justify-content:space-between; gap:10px;
        padding:10px 10px;
        border-radius:12px;
        border:1px solid var(--line);
        background:rgba(15,22,35,.55);
      }
      .statKey{color:rgba(232,238,252,.70); font-weight:800}
      .statVal{color:rgba(232,238,252,.95); font-weight:900; text-align:right}

      /* Badges */
      .badgeRow{display:flex; gap:8px; flex-wrap:wrap; margin-top:8px}
      .badge{
        display:inline-flex; gap:8px; align-items:center;
        padding:6px 10px;
        border-radius:999px;
        border:1px solid var(--line);
        background:rgba(15,22,35,.65);
        font-size:12px;
        font-weight:900;
      }
      .badge.cursed{border-color:rgba(255,46,85,.45); background:rgba(255,46,85,.12)}
      .badge .icon{font-size:14px}

      /* Trait slots */
      .slotsGrid{display:grid; grid-template-columns:repeat(2, minmax(0, 1fr)); gap:10px}
      @media (max-width:520px){.slotsGrid{grid-template-columns:1fr}}
      .slotCard{
        border:1px solid var(--line);
        background:rgba(15,22,35,.55);
        border-radius:14px;
        padding:10px;
        position:relative;
        cursor:pointer;
      }
      .slotLocked{opacity:.80}
      .closestSlot{outline:2px solid rgba(122,168,255,.30)}
      .slotTop{display:flex; justify-content:space-between; align-items:center}
      .slotName{font-weight:1000}
      .slotDesc{margin-top:6px; color:rgba(232,238,252,.72); font-size:12px}
      .slotProgressWrap{
        margin-top:10px;
        height:8px;
        background:rgba(255,255,255,.08);
        border-radius:999px;
        overflow:hidden;
      }
      .slotProgressBar{
        height:100%;
        background:linear-gradient(90deg, rgba(122,168,255,.65), rgba(122,168,255,.20));
        width:0%;
      }
      .slotProgressText{margin-top:6px; font-size:12px; color:rgba(232,238,252,.65)}
      .barPulse{animation:barPulse .65s ease-out 1}
      @keyframes barPulse{0%{filter:brightness(1)}45%{filter:brightness(1.6)}100%{filter:brightness(1)}}
      .plusOne{
        position:absolute;
        right:10px;
        bottom:10px;
        font-weight:1000;
        color:var(--good);
        animation:floatUp .65s ease-out 1;
      }
      @keyframes floatUp{0%{transform:translateY(0); opacity:1}100%{transform:translateY(-14px); opacity:0}}

      /* Toast */
      #toast{
        position:fixed;
        left:50%;
        bottom:18px;
        transform:translateX(-50%);
        background:rgba(10,15,25,.92);
        border:1px solid var(--line);
        padding:10px 12px;
        border-radius:999px;
        opacity:0;
        pointer-events:none;
        transition:opacity .18s ease;
        font-weight:900;
        z-index:50;
      }
      #toast.show{opacity:1}

      /* Modals */
      .modal{
        position:fixed; inset:0;
        display:flex; align-items:center; justify-content:center;
        background:rgba(0,0,0,.55);
        z-index:60;
        padding:18px;
      }
      .modal.hidden{display:none}
      .modalCard{
        width:min(520px, 100%);
        border-radius:16px;
        border:1px solid var(--line);
        background:rgba(18,26,40,.95);
        padding:14px;
      }
      .modalTop{display:flex; justify-content:space-between; align-items:center; gap:12px}
      .modalTitle{font-weight:1000; font-size:16px}
      .modalSub{color:rgba(232,238,252,.70); font-size:12px; margin-top:6px}
      .modalBtns{display:flex; gap:10px; margin-top:12px; flex-wrap:wrap}
      input{
        width:100%;
        padding:12px 12px;
        border-radius:14px;
        border:1px solid var(--line);
        background:rgba(15,22,35,.65);
        color:var(--text);
        font-weight:900;
        outline:none;
      }

      /* Loot */
      .lootRow{
        display:flex; justify-content:space-between; gap:12px;
        padding:10px;
        border:1px solid var(--line);
        background:rgba(15,22,35,.55);
        border-radius:12px;
        margin-top:10px;
      }
      .lootLabel{font-weight:1000}
      .lootNote{font-size:12px; color:rgba(232,238,252,.65)}
      .lootValue{font-weight:1000}

      /* Confetti */
      .confetti{position:fixed; inset:0; pointer-events:none; z-index:80;}
      .confettiPiece{
        width:10px;height:10px;border-radius:3px;
        position:absolute; left:50%; top:40%;
        transform:translate(-50%,-50%);
        animation:conf .8s ease-out forwards;
      }
      @keyframes conf{
        to{ transform: translate(calc(-50% + var(--dx)), calc(-50% + var(--dy))) rotate(var(--rot)); opacity:0;}
      }

      /* PvP steal animation */
      #stealAnim{position:fixed; inset:0; pointer-events:none; z-index:90;}
      #stealAnim.hidden{display:none}
      #stealChip{
        position:fixed;
        padding:10px 12px;
        border-radius:999px;
        border:1px solid rgba(255,255,255,.18);
        background:rgba(10,15,25,.92);
        font-weight:1000;
        opacity:0;
        transform:translate(-50%,-50%);
      }
      #stealChip.flyNow{
        opacity:1;
        animation:fly .65s ease-out forwards;
      }
      @keyframes fly{
        to{ left:var(--dx); top:var(--dy); opacity:0; transform:translate(-50%,-50%) scale(.9); }
      }
      #stealPopup{
        position:fixed;
        top:12px;
        left:50%;
        transform:translateX(-50%);
        z-index:95;
        padding:10px 12px;
        border-radius:999px;
        border:1px solid rgba(255,255,255,.18);
        background:rgba(10,15,25,.92);
        font-weight:1000;
      }
      #stealPopup.hidden{display:none}
    </style>
    <!-- âœ… PART 3 / 6 â€” BUILD tab + wheel + build portrait + trait slots + build log -->
    <section id="tab-build" class="grid">
      <div class="card" id="wheelBox">
        <div>
          <div id="wheelTitle">Race</div>
          <div id="wheelHint">Spin the wheel</div>
        </div>

        <canvas id="wheel" width="520" height="520"></canvas>

        <div class="btnRow">
          <button id="spinBtn" class="btn primary">Spin</button>
          <button id="finalizeBtn" class="btn good">Finalize</button>
          <button id="newBuildBtn" class="btn">New Build</button>
          <button id="skipBtn" class="btn ghost">Skip (test)</button>
          <button id="testFastBtn" class="btn ghost">Fast Spin (test)</button>
        </div>

        <div class="muted" id="buildHint">Spin for Race.</div>

        <div class="card" style="padding:12px; background:rgba(15,22,35,.45); border-color:rgba(255,255,255,.08)">
          <h2>Build Log</h2>
          <div id="buildLog" class="muted"></div>
        </div>
      </div>

      <div class="card">
        <h2>Character</h2>
        <div class="portraitWrap">
          <div id="charFrame" class="frame idle-sway">
            <img id="layer_base" class="layer" alt="">
            <img id="layer_body" class="layer" alt="">
            <img id="layer_back" class="layer" alt="">
            <img id="layer_legs" class="layer" alt="">
            <img id="layer_arms" class="layer" alt="">
            <img id="layer_head" class="layer" alt="">
            <img id="layer_armor" class="layer" alt="">
            <img id="layer_weapon" class="layer" alt="">
            <img id="layer_fx" class="layer fx" alt="">
          </div>

          <div style="flex:1; min-width:260px">
            <h2>Build Stats</h2>
            <div id="buildStats" class="statList"></div>
            <div id="buildBadges" class="badgeRow"></div>

            <h2 style="margin-top:12px">Trait Slots</h2>
            <div id="traitSlots" class="slotsGrid"></div>
          </div>
        </div>
      </div>
    </section>
   <!-- =========================
PART 5 / 6 â€” CONTINUED (paste after your current Part 4)
========================= -->
<script>
/* =========================================================
   ADDITIVE STAT MATH + EFFECT SYSTEM (continued)
========================================================= */
const MASTERY_RANK = { "None":0, "Dormant":1, "Awakening":2, "Controlled":3, "Mastered":4, "Planetary":5, "Cosmic":6, "Universal":7, "Omnipotent":8 };

function masteryAtLeast(char, key){
  const cur = MASTERY_RANK[char.powerMastery || "None"] || 0;
  return cur >= (MASTERY_RANK[key] || 0);
}

function parseLuck(char){
  const n = parseInt(char.luckW || "0", 10);
  return Number.isFinite(n) ? Math.max(1, Math.min(10, n)) : 1;
}

function statBaseFromWords(char){
  const strength = statWordToNumber("strength", char.strengthW);
  const speed    = statWordToNumber("speed", char.speedW);
  const dura     = statWordToNumber("durability", char.durabilityW);
  const fight    = statWordToNumber("fight", char.fightW);
  const iq       = statWordToNumber("iq", char.iqW);
  return { strength, speed, durability:dura, fight, iq };
}

/* --- additive mods from lists --- */
function addMods(mods, add){
  for(const k of Object.keys(add)){
    mods[k] = (mods[k] || 0) + add[k];
  }
}

function powerMods(power){
  switch(power){
    case "Adaptation": return { durability:2, fight:1 };
    case "Regeneration": return { durability:3 };
    case "Gravity Manipulation": return { strength:2, fight:1 };
    case "Time Manipulation": return { speed:3, iq:1 };
    case "Telekinesis": return { iq:2, fight:1 };
    case "Teleportation": return { speed:2 };
    case "Fire": return { strength:1 };
    case "Ice Manipulation": return { durability:1 };
    case "Lightning": return { speed:2 };
    case "Weapon Creation": return { fight:2 };
    case "Heavenly Restriction": return { strength:3, speed:2, durability:2, fight:2, iq:-1 };
    case "Immortal": return { durability:4 };
    case "Rinnegan": return { iq:2, fight:2 };
    default: return {};
  }
}

function weaponMods(weapon){
  switch(weapon){
    case "Sword": return { fight:2 };
    case "Scythe": return { fight:2, strength:1 };
    case "Axe": return { strength:2 };
    case "Hammer": return { strength:2, durability:1 };
    case "Spear": return { fight:1, speed:1 };
    case "Brass Knuckles": return { fight:1, strength:1 };
    case "Blades of Chaos": return { fight:2, speed:1 };
    case "Samehada": return { durability:1, fight:2 };
    case "Uzumaki Chains": return { durability:2, fight:1 };
    case "Infinity Gauntlet": return { strength:3, durability:3, iq:2, fight:2 };
    case "Green Lantern Ring": return { iq:3, durability:2 };
    default: return {};
  }
}

function armorMods(armor){
  switch(armor){
    case "Berserk Armor": return { strength:2, durability:2, fight:1 };
    case "Iron Man Suit": return { speed:2, durability:2, iq:1 };
    case "Jauger": return { durability:2 };
    case "Symbiote": return { strength:1, speed:1, durability:1, fight:1 };
    case "Ashborn's Armor": return { durability:3, fight:1 };
    case "Rock Lee Weights": return { speed:-2, strength:2, durability:1 };
    case "Goku's Gi": return { fight:1 };
    default: return {};
  }
}

function trainerMods(trainer){
  switch(trainer){
    case "Master Roshi": return { fight:2, iq:1 };
    case "Jiraiya": return { fight:2, iq:1 };
    case "Hisoka": return { fight:2, iq:1 };
    case "Korro": return { durability:1, fight:1 };
    case "Yuujirou": return { strength:3, fight:2 };
    default: return {};
  }
}

function clanMods(clan){
  switch(clan){
    case "Uchiha": return { fight:2, iq:1 };
    case "Gojo": return { iq:2, speed:1 };
    case "D Clan": return { durability:1, fight:1 };
    case "Kamado": return { fight:2 };
    default: return {};
  }
}

/* Transform multipliers/additions (kept simple but additive-ready) */
function transformMods(char){
  const t = char.transformation;
  const d = char.transformDetail?.value || "None";
  if(!t || t === "None" || d === "None") return { add:{}, mult:{} };

  if(t === "Kaioken"){
    const m = parseInt(String(d).replace("X",""),10);
    const mul = Number.isFinite(m) ? Math.min(100, Math.max(2, m)) : 2;
    return { add:{}, mult:{ strength:1+mul*0.03, speed:1+mul*0.03, durability:1+mul*0.01, fight:1+mul*0.02 } };
  }
  if(t === "Eight Gates"){
    const is8 = String(d).toLowerCase().includes("eighth");
    const gateIndex = Math.max(0, GATES_OPTIONS.indexOf(d));
    const boost = is8 ? 10 : 1 + gateIndex*0.8;
    return { add:{ strength:boost, speed:boost, fight:Math.floor(boost*0.7) }, mult:{} };
  }
  if(t === "Super Saiyan"){
    const idx = Math.max(0, SAIYAN_FORM_OPTIONS.indexOf(d));
    return { add:{ strength:2+idx*2, speed:1+idx, durability:1+idx, fight:1+idx }, mult:{} };
  }
  if(t === "Titan Transformation"){
    const idx = Math.max(0, TITAN_TYPE_OPTIONS.indexOf(d));
    return { add:{ strength:2+idx, durability:3+idx, fight:1+Math.floor(idx/2) }, mult:{} };
  }
  if(t === "Tailed Beast"){
    const idx = Math.max(0, TAILED_BEAST_OPTIONS.indexOf(d));
    return { add:{ strength:idx, durability:idx, speed:Math.floor(idx/2), fight:Math.floor(idx/2) }, mult:{} };
  }
  return { add:{}, mult:{} };
}

/* =========================================================
   FINAL COMPUTED STATS (numbers + label)
========================================================= */
function computeFinalStats(char){
  const base = statBaseFromWords(char);
  const mods = { strength:0, speed:0, durability:0, fight:0, iq:0 };

  // add from powers/weapons/armor
  (char.powers || []).forEach(p => addMods(mods, powerMods(p)));
  (char.weapons || []).forEach(w => addMods(mods, weaponMods(w)));
  (char.armors || []).forEach(a => addMods(mods, armorMods(a)));

  // trainer/clan
  addMods(mods, trainerMods(char.trainer));
  addMods(mods, clanMods(char.clan));

  // mastery bump
  if(masteryAtLeast(char,"Mastered")) addMods(mods, { fight:1, durability:1 });
  if(masteryAtLeast(char,"Cosmic")) addMods(mods, { strength:2, speed:2, iq:1 });
  if(masteryAtLeast(char,"Universal")) addMods(mods, { strength:3, speed:3, durability:3, fight:2, iq:2 });

  // adaptation stacks (permanent)
  if((char.powers || []).includes("Adaptation")){
    addMods(mods, { durability: state.progress.adaptationStacks || 0 });
  }

  // soul bonus (permanent)
  addMods(mods, state.progress.soulBonus || {});

  // transformation
  const tm = transformMods(char);

  // apply
  let out = {
    strength: base.strength + mods.strength + (tm.add.strength||0),
    speed: base.speed + mods.speed + (tm.add.speed||0),
    durability: base.durability + mods.durability + (tm.add.durability||0),
    fight: base.fight + mods.fight + (tm.add.fight||0),
    iq: base.iq + mods.iq + (tm.add.iq||0),
    luck: parseLuck(char)
  };

  // multipliers
  for(const k of ["strength","speed","durability","fight","iq"]){
    const mul = tm.mult[k] || 1;
    out[k] = Math.round(out[k] * mul);
  }

  // labels
  out.labels = {
    strength: labelForStat("strength", out.strength),
    speed: labelForStat("speed", out.speed),
    durability: labelForStat("durability", out.durability),
    fight: labelForStat("fight", out.fight),
    iq: labelForStat("iq", out.iq),
  };

  out.isCursed = computeIsCursed(char);

  return out;
}

/* =========================================================
   STATS TAB RENDER
========================================================= */
function renderStatsTab(){
  const host = $("statsList");
  const host2 = $("finalStatsList");
  if(!host || !host2) return;

  const c = state.character;
  host.innerHTML = "";
  host2.innerHTML = "";

  const lines = buildStatLines();
  for(const [k,v] of lines){
    const div = document.createElement("div");
    div.className = "statLine";
    div.innerHTML = `<div class="statKey">${escapeHtml(k)}</div><div class="statVal">${escapeHtml(v)}</div>`;
    host.appendChild(div);
  }

  const fin = computeFinalStats(c);
  const statOrder = [
    ["strength","Strength"],
    ["speed","Speed"],
    ["durability","Durability"],
    ["fight","Fight"],
    ["iq","IQ"],
    ["luck","Luck"],
  ];

  statOrder.forEach(([key,label])=>{
    const div = document.createElement("div");
    div.className = "statLine";
    if(key === "luck"){
      div.innerHTML = `<div class="statKey">${label}</div><div class="statVal">${fin.luck}</div>`;
    } else {
      const word = fin.labels[key];
      div.innerHTML = `<div class="statKey">${label}</div><div class="statVal">${word} <span class="muted">(${fin[key]})</span></div>`;
    }
    host2.appendChild(div);
  });
}

/* Extend refreshUI to update stats tab content */
const _refreshUI_p5 = refreshUI;
refreshUI = function(){
  _refreshUI_p5();
  renderStatsTab();
};
</script>
    <!-- =========================
PART 6 / 6 â€” PvE/PvP battles + flee + steal/copy + soul stone + loot UI
PASTE SIXTH (last)
========================= -->
<script>
/* =========================================================
   BATTLE HELPERS
========================================================= */
function logPVP(msg){
  const el = $("pvpLog");
  if(!el) return;
  const time = new Date().toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
  el.innerHTML = `<div><span class="muted">[${time}]</span> ${escapeHtml(msg)}</div>` + el.innerHTML;
}
function logPVE(msg){
  const el = $("pveLog");
  if(!el) return;
  const time = new Date().toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
  el.innerHTML = `<div><span class="muted">[${time}]</span> ${escapeHtml(msg)}</div>` + el.innerHTML;
}
function setHP(barId, pct){
  const el = $(barId);
  if(!el) return;
  el.style.width = `${Math.max(0, Math.min(1, pct)) * 100}%`;
}
function clamp(n,a,b){ return Math.max(a, Math.min(b, n)); }

function roll(chance){
  return Math.random() < chance;
}

/* =========================================================
   SIMPLE ENEMY GENERATION (event enemies + pvp opponents)
========================================================= */
function randomFrom(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

function genEnemyBase(){
  // lightweight opponent generator (not a full wheel build)
  const race = randomFrom(RACE_OPTIONS);
  const enemy = {
    name: "Enemy",
    race,
    demi:null, werebeastType:null, demiTraits:[],
    powers:[], weapons:[], armors:[], effects:[],
    powerMastery: randomFrom(POWER_MASTERY_OPTIONS),
    clan: randomFrom(CLAN_OPTIONS),
    trainer: randomFrom(TRAINER_OPTIONS),
    transformation: randomFrom(TRANSFORM_OPTIONS),
    transformDetail:null,

    strengthW: randomFrom(STRENGTH_WORDS),
    speedW: randomFrom(SPEED_WORDS),
    durabilityW: randomFrom(DUR_WORDS),
    fightW: randomFrom(FIGHT_WORDS),
    iqW: randomFrom(IQ_WORDS),
    luckW: String(Math.floor(1+Math.random()*10))
  };

  // small chance to have some gear/power
  if(Math.random() < 0.75) enemy.powers.push(randomFrom(POWER_OPTIONS));
  if(Math.random() < 0.75) enemy.weapons.push(randomFrom(WEAPON_OPTIONS));
  if(Math.random() < 0.65) enemy.armors.push(randomFrom(ARMOR_OPTIONS));

  // transform detail
  if(enemy.transformation === "Kaioken") enemy.transformDetail = {kind:"kaioken", value: randomFrom(KAIOKEN_OPTIONS)};
  if(enemy.transformation === "Eight Gates") enemy.transformDetail = {kind:"gates", value: randomFrom(GATES_OPTIONS)};
  if(enemy.transformation === "Super Saiyan") enemy.transformDetail = {kind:"ssj", value: randomFrom(SAIYAN_FORM_OPTIONS)};
  if(enemy.transformation === "Titan Transformation") enemy.transformDetail = {kind:"titan", value: randomFrom(TITAN_TYPE_OPTIONS)};
  if(enemy.transformation === "Tailed Beast") enemy.transformDetail = {kind:"tailed", value: randomFrom(TAILED_BEAST_OPTIONS)};

  // tame "No Power/Weapon/Armor"
  enemy.powers = enemy.powers.filter(x=>x && x!=="No Power");
  enemy.weapons = enemy.weapons.filter(x=>x && x!=="No Weapon");
  enemy.armors = enemy.armors.filter(x=>x && x!=="No Armor");

  return enemy;
}

/* =========================================================
   FLEE LOGIC (only if speeds close enough, and scales by gap)
========================================================= */
function tryFlee(playerStats, enemyStats, logger){
  const chance = fleeChanceFromSpeedGap(playerStats.speed, enemyStats.speed);
  if(chance <= 0){
    logger(`Flee failed: speed gap too large.`);
    return { fled:false };
  }
  if(roll(chance)){
    logger(`Flee succeeded! (chance ${(chance*100).toFixed(0)}%)`);
    return { fled:true };
  }
  logger(`Flee failed. (chance ${(chance*100).toFixed(0)}%)`);
  return { fled:false };
}

/* =========================================================
   DAMAGE MODEL (simple but additive)
========================================================= */
function computeHP(stats){
  // durability is the biggest HP driver
  return 60 + stats.durability*8 + stats.fight*2;
}
function computeDamage(att, def){
  const atk = att.strength*2 + att.fight*3 + att.speed;
  const mitig = def.durability*2 + def.fight;
  const base = Math.max(8, atk - mitig*0.65);
  // luck small variance
  const varMul = 0.85 + (att.luck-1) * 0.03 + Math.random()*0.18;
  return Math.round(base * varMul);
}

/* =========================================================
   SOUL STONE (Infinity Gauntlet captures souls)
========================================================= */
function hasSoulStone(char){
  return (char.weapons || []).includes("Infinity Gauntlet");
}
async function soulStonePickBonus(){
  const choices = [
    { label:"+1 Strength", value:"strength" },
    { label:"+1 Speed", value:"speed" },
    { label:"+1 Durability", value:"durability" },
    { label:"+1 Fight", value:"fight" },
    { label:"+1 IQ", value:"iq" },
  ];
  const picked = await openChoiceModal({
    title:"Soul Stone",
    sub:"Choose a permanent +1 bonus stat.",
    options: choices
  });
  if(!picked) return;
  state.progress.soulsCaptured = (state.progress.soulsCaptured || 0) + 1;
  state.progress.soulBonus[picked] = (state.progress.soulBonus[picked] || 0) + 1;
  saveState();
  toast(`Soul captured: +1 ${picked.toUpperCase()}`);
}

/* =========================================================
   ADAPTATION (permanent stacks on wins if you have Adaptation)
========================================================= */
function applyAdaptationWin(char){
  if(!(char.powers || []).includes("Adaptation")) return;
  state.progress.adaptationStacks = (state.progress.adaptationStacks || 0) + 1;
  saveState();
}

/* =========================================================
   STEAL / COPY (additive)
========================================================= */
function showStealPopup(text){
  const p = $("stealPopup");
  if(!p) return;
  p.textContent = text;
  p.classList.remove("hidden");
  setTimeout(()=>p.classList.add("hidden"), 1100);
}
function playStealAnim(text){
  const wrap = $("stealAnim");
  const chip = $("stealChip");
  if(!wrap || !chip) return;

  wrap.classList.remove("hidden");
  chip.textContent = text;
  chip.style.left = "50%";
  chip.style.top = "18%";

  chip.classList.remove("flyNow");
  void chip.offsetWidth;
  chip.classList.add("flyNow");

  setTimeout(()=>wrap.classList.add("hidden"), 750);
}

function enemyTraitsPool(enemy){
  const pool = [];
  (enemy.powers||[]).forEach(x => x && x!=="No Power" && pool.push({kind:"power", value:x}));
  (enemy.weapons||[]).forEach(x => x && x!=="No Weapon" && pool.push({kind:"weapon", value:x}));
  (enemy.armors||[]).forEach(x => x && x!=="No Armor" && pool.push({kind:"armor", value:x}));
  if(enemy.clan && enemy.clan!=="No Clan") pool.push({kind:"clan", value:enemy.clan});
  if(enemy.trainer && enemy.trainer!=="No Trainer") pool.push({kind:"trainer", value:enemy.trainer});
  if(enemy.transformation && enemy.transformation!=="None") pool.push({kind:"transform", value:enemy.transformation});
  return pool;
}

function addTraitToPlayer(tr){
  const c = state.character;
  if(tr.kind === "power"){
    c.powers ||= [];
    if(!c.powers.includes(tr.value)) c.powers.push(tr.value);
  }
  if(tr.kind === "weapon"){
    c.weapons ||= [];
    if(!c.weapons.includes(tr.value)) c.weapons.push(tr.value);
  }
  if(tr.kind === "armor"){
    c.armors ||= [];
    if(!c.armors.includes(tr.value)) c.armors.push(tr.value);
  }
  if(tr.kind === "clan"){
    // additive: keep a list instead of swap
    c.fusions ||= [];
    if(!c.fusions.includes(`Clan:${tr.value}`)) c.fusions.push(`Clan:${tr.value}`);
  }
  if(tr.kind === "trainer"){
    c.fusions ||= [];
    if(!c.fusions.includes(`Trainer:${tr.value}`)) c.fusions.push(`Trainer:${tr.value}`);
  }
  if(tr.kind === "transform"){
    c.fusions ||= [];
    if(!c.fusions.includes(`Transform:${tr.value}`)) c.fusions.push(`Transform:${tr.value}`);
  }
}

async function maybeStealTrait(enemy, logger){
  const now = Date.now();
  // small cooldown so it doesn't spam
  if(now - (state.progress.lastStolenAt || 0) < 5000) return;

  const pool = enemyTraitsPool(enemy);
  if(pool.length === 0) return;

  if(!roll(TRAIT_STEAL_CHANCE)) return;

  const pick = randomFrom(pool);
  addTraitToPlayer(pick);
  state.progress.lastStolenAt = now;
  saveState();

  showStealPopup(`Stole ${pick.kind}: ${pick.value}`);
  playStealAnim(`+ ${pick.value}`);
  playStealSound();
  logger(`Stole ${pick.kind}: ${pick.value} (additive).`);
}

/* =========================================================
   PVP BATTLE
========================================================= */
async function startPVP(){
  if(!state.character.finalized){
    toast("Finalize your build first.");
    return;
  }
  $("pvpLog").innerHTML = "";
  const player = state.character;
  const enemy = genEnemyBase();

  // set portraits
  applyRaceBase(player, "p_"); applyRigFraming(player, "p_charFrame"); applyDemiTraits(player, "p_"); applyIdleFx(player, "p_");
  applyRaceBase(enemy, "e_"); applyRigFraming(enemy, "e_charFrame"); applyDemiTraits(enemy, "e_"); applyIdleFx(enemy, "e_");

  $("p_roleTag").textContent = player.name ? player.name : "You";
  $("e_roleTag").textContent = "Opponent";

  const pStats = computeFinalStats(player);
  const eStats = computeFinalStats(enemy);

  let pHP = computeHP(pStats);
  let eHP = computeHP(eStats);
  let pMax = pHP, eMax = eHP;

  setHP("p_hp", 1); setHP("e_hp", 1);

  logPVP(`Match started vs ${enemy.race}.`);
  if(pStats.isCursed) logPVP(`The arena laughsâ€¦ cursed build detected.`);
  if(eStats.isCursed) logPVP(`Opponent is cursed too.`);

  // battle loop
  let turn = 0;
  while(pHP > 0 && eHP > 0 && turn < 60){
    turn++;

    // flee check (only if low HP)
    if(pHP / pMax <= FLEE_HP_THRESHOLD){
      const flee = tryFlee(pStats, eStats, logPVP);
      if(flee.fled){
        logPVP("You fled the match.");
        return;
      }
    }

    // speed decides who hits first
    const playerFirst = (pStats.speed + Math.random()*3) >= (eStats.speed + Math.random()*3);

    const doHit = (attStats, defStats, who, whoHPRef) => {
      const dmg = computeDamage(attStats, defStats);
      if(who === "enemy"){
        eHP -= dmg;
        logPVP(`You hit for ${dmg}.`);
        setHP("e_hp", eHP/eMax);
      } else {
        pHP -= dmg;
        logPVP(`Enemy hit for ${dmg}.`);
        setHP("p_hp", pHP/pMax);
      }
    };

    if(playerFirst){
      doHit(pStats, eStats, "enemy");
      if(eHP > 0) doHit(eStats, pStats, "player");
    } else {
      doHit(eStats, pStats, "player");
      if(pHP > 0) doHit(pStats, eStats, "enemy");
    }

    // steal chance
    await maybeStealTrait(enemy, logPVP);

    // tiny delay so UI feels alive
    await new Promise(r=>setTimeout(r, 80));
  }

  if(pHP <= 0){
    logPVP("Defeat.");
    playBlockSound();
    return;
  }

  logPVP("Victory!");
  state.progress.pvpWins = (state.progress.pvpWins || 0) + 1;
  state.currency.coins = (state.currency.coins || 0) + 20;
  state.currency.xp = (state.currency.xp || 0) + 10;

  saveState();

  // progress UI fun
  showPlusOneOnClosestSlot();
  pulseClosestLockedBar();

  applyAdaptationWin(player);
  checkSlotUnlocks();

  if(hasSoulStone(player)){
    await soulStonePickBonus();
  }

  // show loot modal
  openLootModal({
    title:"PvP Victory",
    sub:`You defeated a ${enemy.race}.`,
    rewards:[
      {label:"Coins", note:"+20", value:`${state.currency.coins}`},
      {label:"XP", note:"+10", value:`${state.currency.xp}`},
    ],
    traitEvents:[
      {label:"Trait Progress", note:"Closest slot +1", value:""},
      {label:"Adaptation", note: (player.powers||[]).includes("Adaptation") ? "+1 stack" : "â€”", value:`${state.progress.adaptationStacks||0}`},
      {label:"Souls", note: hasSoulStone(player) ? "+1 if chosen" : "â€”", value:`${state.progress.soulsCaptured||0}`},
    ],
    progress:[
      {label:"PvP Wins", note:"+1", value:`${state.progress.pvpWins}`},
    ]
  });

  refreshUI();
}

/* =========================================================
   PVE BATTLE
========================================================= */
async function startPVE(){
  if(!state.character.finalized){
    toast("Finalize your build first.");
    return;
  }
  $("pveLog").innerHTML = "";
  const player = state.character;

  // stronger event enemy
  const enemy = genEnemyBase();
  enemy.name = "Event Enemy";
  enemy.powerMastery = randomFrom(["Controlled","Mastered","Cosmic","Universal"]);
  if(Math.random() < 0.9) enemy.powers.push(randomFrom(POWER_OPTIONS));

  applyRaceBase(player, "pve_p_"); applyRigFraming(player, "pve_p_charFrame"); applyDemiTraits(player, "pve_p_"); applyIdleFx(player, "pve_p_");
  applyRaceBase(enemy, "pve_e_"); applyRigFraming(enemy, "pve_e_charFrame"); applyDemiTraits(enemy, "pve_e_"); applyIdleFx(enemy, "pve_e_");

  $("pve_p_roleTag").textContent = player.name ? player.name : "You";
  $("pve_e_roleTag").textContent = enemy.name;

  const pStats = computeFinalStats(player);
  const eStats = computeFinalStats(enemy);

  let pHP = computeHP(pStats);
  let eHP = computeHP(eStats) + 40; // event buff
  let pMax = pHP, eMax = eHP;

  setHP("pve_p_hp", 1); setHP("pve_e_hp", 1);

  logPVE(`PvE started vs ${enemy.race}.`);
  if(pStats.isCursed) logPVE(`The enemy taunts your cursed auraâ€¦`);

  let turn = 0;
  while(pHP > 0 && eHP > 0 && turn < 70){
    turn++;

    // flee check
    if(pHP / pMax <= FLEE_HP_THRESHOLD){
      const flee = tryFlee(pStats, eStats, logPVE);
      if(flee.fled){
        logPVE("You escaped the event.");
        return;
      }
    }

    const playerFirst = (pStats.speed + Math.random()*3) >= (eStats.speed + Math.random()*3);

    const hit = (att, def, target) => {
      const dmg = computeDamage(att, def);
      if(target === "enemy"){
        eHP -= dmg;
        logPVE(`You dealt ${dmg}.`);
        setHP("pve_e_hp", eHP/eMax);
      } else {
        pHP -= dmg;
        logPVE(`Enemy dealt ${dmg}.`);
        setHP("pve_p_hp", pHP/pMax);
      }
    };

    if(playerFirst){
      hit(pStats, eStats, "enemy");
      if(eHP > 0) hit(eStats, pStats, "player");
    } else {
      hit(eStats, pStats, "player");
      if(pHP > 0) hit(pStats, eStats, "enemy");
    }

    await new Promise(r=>setTimeout(r, 80));
  }

  if(pHP <= 0){
    logPVE("Defeat.");
    playBlockSound();
    return;
  }

  logPVE("Victory!");
  state.currency.coins = (state.currency.coins || 0) + 12;
  state.currency.xp = (state.currency.xp || 0) + 8;
  applyAdaptationWin(player);

  if(hasSoulStone(player) && Math.random() < 0.35){
    await soulStonePickBonus();
  }

  saveState();

  openLootModal({
    title:"PvE Victory",
    sub:`You won the event.`,
    rewards:[
      {label:"Coins", note:"+12", value:`${state.currency.coins}`},
      {label:"XP", note:"+8", value:`${state.currency.xp}`},
    ],
    traitEvents:[
      {label:"Adaptation", note: (player.powers||[]).includes("Adaptation") ? "+1 stack" : "â€”", value:`${state.progress.adaptationStacks||0}`},
      {label:"Souls", note: hasSoulStone(player) ? "possible" : "â€”", value:`${state.progress.soulsCaptured||0}`},
    ],
    progress:[]
  });

  refreshUI();
}

/* =========================================================
   LOOT MODAL RENDER
========================================================= */
function openLootModal({title, sub, rewards, traitEvents, progress}){
  const modal = $("lootModal");
  if(!modal) return;

  $("lootTitle").textContent = title || "Victory";
  $("lootSub").textContent = sub || "";

  const makeRow = (x) => {
    const row = document.createElement("div");
    row.className = "lootRow";
    row.innerHTML = `
      <div class="lootLeft">
        <div class="lootLabel">${escapeHtml(x.label||"")}</div>
        <div class="lootNote">${escapeHtml(x.note||"")}</div>
      </div>
      <div class="lootValue">${escapeHtml(x.value||"")}</div>
    `;
    return row;
  };

  const rHost = $("lootRewards");
  const tHost = $("lootTrait");
  const pHost = $("lootProgress");

  rHost.innerHTML = "";
  tHost.innerHTML = "";
  pHost.innerHTML = "";

  (rewards||[]).forEach(x=>rHost.appendChild(makeRow(x)));
  (traitEvents||[]).forEach(x=>tHost.appendChild(makeRow(x)));
  (progress||[]).forEach(x=>pHost.appendChild(makeRow(x)));

  modal.classList.remove("hidden");
}

/* =========================================================
   Hook up buttons
========================================================= */
$("pvpStartBtn")?.addEventListener("click", startPVP);
$("pveStartBtn")?.addEventListener("click", startPVE);

/* Refresh at end */
refreshUI();
</script>

</body>
</html>
