<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Wheel Forge â€” V1</title>

  <style>
    :root{
      --bg:#0b0f17;
      --panel:#121a28;
      --panel2:#0f1623;
      --text:#e8eefc;
      --muted:rgba(232,238,252,.65);
      --good:#2ee59d;
      --bad:#ff4d6d;
      --warn:#ffcc66;
      --line:rgba(255,255,255,.10);
      --accent:#7aa8ff;
      --cursed:#ff2e55;
    }

    *{box-sizing:border-box}

    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
      color:var(--text);
      background:var(--bg);
      overflow-x:hidden;
    }

    /* Background */
    #bgImage{
      position:fixed;
      inset:0;
      background-size:cover;
      background-position:center;
      filter:saturate(1.05) contrast(1.05) brightness(.55);
      transform:scale(1.03);
      z-index:-2;
    }
    #bgShade{
      position:fixed;
      inset:0;
      background:
        radial-gradient(1000px 600px at 30% 10%, rgba(122,168,255,.25), transparent 60%),
        linear-gradient(to bottom, rgba(0,0,0,.25), rgba(0,0,0,.75));
      z-index:-1;
    }

    .app{
      max-width:1120px;
      margin:0 auto;
      padding:18px 14px 88px;
    }

    header{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      padding:10px 12px;
      border:1px solid var(--line);
      background:rgba(18,26,40,.72);
      backdrop-filter:blur(10px);
      border-radius:14px;
    }

    .title{
      display:flex;
      flex-direction:column;
      line-height:1.1;
    }
    .title b{font-size:18px; letter-spacing:.2px}
    .title span{font-size:12px; color:var(--muted)}

    .pillRow{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }

    .pill{
      font-size:12px;
      border:1px solid var(--line);
      padding:6px 10px;
      border-radius:999px;
      background:rgba(15,22,35,.85);
      color:var(--muted);
      white-space:nowrap;
    }
    .pill strong{color:var(--text)}

    .btn{
      border:1px solid var(--line);
      background:rgba(15,22,35,.85);
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      user-select:none;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:8px;
      font-weight:900;
      transition:transform .08s ease, opacity .15s ease;
    }
    .btn:active{transform:scale(.985)}
    .btn.primary{
      background:linear-gradient(135deg, rgba(122,168,255,.25), rgba(122,168,255,.06));
      border-color:rgba(122,168,255,.35);
    }
    .btn.good{
      background:linear-gradient(135deg, rgba(46,229,157,.18), rgba(46,229,157,.06));
      border-color:rgba(46,229,157,.35);
    }
    .btn.bad{
      background:linear-gradient(135deg, rgba(255,77,109,.20), rgba(255,77,109,.06));
      border-color:rgba(255,77,109,.35);
    }
    .btn.ghost{background:transparent}

    .tabs{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top:12px;
      align-items:center;
    }

    .tab{
      padding:9px 12px;
      border-radius:999px;
      border:1px solid var(--line);
      background:rgba(15,22,35,.65);
      cursor:pointer;
      font-weight:1000;
      font-size:12px;
      color:rgba(232,238,252,.72);
    }
    .tab.active{
      color:var(--text);
      border-color:rgba(122,168,255,.45);
      background:rgba(122,168,255,.14);
    }

    .grid{
      display:grid;
      grid-template-columns:1.25fr .9fr;
      gap:12px;
      margin-top:12px;
    }
    @media (max-width:980px){
      .grid{grid-template-columns:1fr}
    }

    .card{
      border:1px solid var(--line);
      background:rgba(18,26,40,.72);
      backdrop-filter:blur(10px);
      border-radius:16px;
      padding:12px;
    }

    .card h2{
      margin:0 0 8px;
      font-size:15px;
      letter-spacing:.2px;
      color:rgba(232,238,252,.92);
    }

    .muted{color:var(--muted)}
    .hidden{display:none !important;}
  </style>
</head>

<body>
  <div id="bgImage"></div>
  <div id="bgShade"></div>

  <div class="app">
    <header>
      <div class="title">
        <b>Wheel Forge</b>
        <span class="muted">Build â€¢ Stats â€¢ PvE â€¢ PvP</span>
      </div>
      <div class="pillRow">
        <div id="phasePill" class="pill">Phase: <strong>â€”</strong></div>
        <button id="soundBtn" class="btn">ðŸ”Š</button>
      </div>
    </header>

    <div class="tabs">
      <div class="tab active" data-tab="build">BUILD</div>
      <div class="tab" data-tab="stats">STATS</div>
      <div class="tab" data-tab="pve">PvE</div>
      <div class="tab" data-tab="pvp">PvP</div>
      <div id="namedTag" class="pill">Name: <strong>â€”</strong></div>
    </div>
        <style>
      /* Portrait frames */
      .portraitWrap{display:flex; gap:12px; align-items:flex-start; flex-wrap:wrap}
      .frame{
        position:relative;
        width:260px;
        height:260px;
        border-radius:18px;
        border:1px solid var(--line);
        background:rgba(15,22,35,.65);
        overflow:hidden;
      }
      .frame.bigRig{width:300px;height:300px}
      .layer{
        position:absolute;
        inset:0;
        width:100%;
        height:100%;
        object-fit:contain;
        pointer-events:none;
      }
      .fx{mix-blend-mode:screen; opacity:.92}

      /* Wheel area */
      #wheelBox{display:flex; flex-direction:column; gap:10px}
      #wheelTitle{font-size:16px; font-weight:1000}
      #wheelHint{font-size:12px; color:var(--muted)}
      canvas{
        width:100%;
        max-width:520px;
        height:auto;
        border-radius:16px;
        border:1px solid var(--line);
        background:rgba(0,0,0,.15)
      }
      .btnRow{display:flex; gap:10px; flex-wrap:wrap}

      /* Stats lines */
      .statList{display:grid; gap:8px}
      .statLine{
        display:flex; justify-content:space-between; gap:10px;
        padding:10px 10px;
        border-radius:12px;
        border:1px solid var(--line);
        background:rgba(15,22,35,.55);
      }
      .statKey{color:rgba(232,238,252,.70); font-weight:900}
      .statVal{color:rgba(232,238,252,.95); font-weight:1000; text-align:right}

      /* Badges */
      .badgeRow{display:flex; gap:8px; flex-wrap:wrap; margin-top:8px}
      .badge{
        display:inline-flex; gap:8px; align-items:center;
        padding:6px 10px;
        border-radius:999px;
        border:1px solid var(--line);
        background:rgba(15,22,35,.65);
        font-size:12px;
        font-weight:1000;
      }
      .badge.cursed{border-color:rgba(255,46,85,.45); background:rgba(255,46,85,.12)}

      /* Trait slots */
      .slotsGrid{display:grid; grid-template-columns:repeat(2, minmax(0, 1fr)); gap:10px}
      @media (max-width:520px){.slotsGrid{grid-template-columns:1fr}}
      .slotCard{
        border:1px solid var(--line);
        background:rgba(15,22,35,.55);
        border-radius:14px;
        padding:10px;
        position:relative;
      }
      .slotTop{display:flex; justify-content:space-between; align-items:center}
      .slotName{font-weight:1100}
      .slotDesc{margin-top:6px; color:rgba(232,238,252,.72); font-size:12px}

      /* Toast */
      #toast{
        position:fixed;
        left:50%;
        bottom:18px;
        transform:translateX(-50%);
        background:rgba(10,15,25,.92);
        border:1px solid var(--line);
        padding:10px 12px;
        border-radius:999px;
        opacity:0;
        pointer-events:none;
        transition:opacity .18s ease;
        font-weight:1000;
        z-index:50;
      }
      #toast.show{opacity:1}
    </style>

    <!-- âœ… BUILD TAB -->
    <section id="tab-build" class="grid">
      <div class="card" id="wheelBox">
        <div>
          <div id="wheelTitle">Wheel</div>
          <div id="wheelHint">Spin to begin</div>
        </div>

        <canvas id="wheel" width="520" height="520"></canvas>

        <div class="btnRow">
          <button id="spinBtn" class="btn primary">Spin</button>
          <button id="nameBtn" class="btn">Set Name</button>
          <button id="newCharBtn" class="btn good">New Character</button>
        </div>

        <div class="muted" id="buildHint">
          Spins happen once per wheel for this character (no redo). New Character creates a new person (does not erase the old one).
        </div>

        <div class="card" style="padding:12px; background:rgba(15,22,35,.45); border-color:rgba(255,255,255,.08)">
          <h2>Build Log</h2>
          <div id="buildLog" class="muted"></div>
        </div>
      </div>

      <div class="card">
        <h2>Character</h2>

        <div class="portraitWrap">
          <div id="charFrame" class="frame">
            <img id="layer_base" class="layer" alt="">
            <img id="layer_body" class="layer" alt="">
            <img id="layer_back" class="layer" alt="">
            <img id="layer_legs" class="layer" alt="">
            <img id="layer_arms" class="layer" alt="">
            <img id="layer_head" class="layer" alt="">
            <img id="layer_armor" class="layer" alt="">
            <img id="layer_weapon" class="layer" alt="">
            <img id="layer_fx" class="layer fx" alt="">
          </div>

          <div style="flex:1; min-width:260px">
            <h2>Build Summary</h2>
            <div id="buildStats" class="statList"></div>

            <div id="buildBadges" class="badgeRow"></div>

            <h2 style="margin-top:12px">Trait Slots</h2>
            <div id="traitSlots" class="slotsGrid"></div>
          </div>
        </div>
      </div>
    </section>

    <!-- âœ… STATS TAB (placeholder in Part 2; filled fully later) -->
    <section id="tab-stats" class="grid hidden">
      <div class="card">
        <h2>Stats</h2>
        <div class="muted">Stats tab will be fully finalized later in this build.</div>
      </div>
    </section>

    <!-- âœ… PvE TAB (locked until build complete) -->
    <section id="tab-pve" class="grid hidden">
      <div class="card">
        <h2>PvE</h2>
        <div class="muted">Unlocks after Build Complete.</div>
      </div>
    </section>

    <!-- âœ… PvP TAB (dev-only for now / future real upload PvP) -->
    <section id="tab-pvp" class="grid hidden">
      <div class="card">
        <h2>PvP</h2>
        <div class="muted">Dev-only for now. Real upload PvP comes later.</div>
      </div>
    </section>

    <div id="toast"></div>
    <!-- =========================
PART 3 / 12 â€” Modals + Core JS shell (FIXED)
========================= -->

<!-- Name Modal -->
<div id="nameModal" class="modal hidden">
  <div class="modalCard">
    <div class="modalTop">
      <div>
        <div class="modalTitle">Set Character Name</div>
        <div class="modalSub">No renaming later. Max 12 chars. Must be appropriate.</div>
      </div>
      <button class="btn ghost" id="nameCloseBtn">âœ–</button>
    </div>

    <div style="margin-top:12px">
      <input id="nameInput" maxlength="12" placeholder="Name (max 12 chars)" />
      <div class="muted" style="margin-top:8px; font-size:12px" id="nameWarn"></div>
    </div>

    <div class="modalBtns">
      <button class="btn good" id="nameSaveBtn">Save</button>
    </div>
  </div>
</div>

<style>
  .modal{
    position:fixed; inset:0;
    display:flex; align-items:center; justify-content:center;
    background:rgba(0,0,0,.55);
    z-index:60;
    padding:18px;
  }
  .modal.hidden{display:none}
  .modalCard{
    width:min(520px, 100%);
    border-radius:16px;
    border:1px solid var(--line);
    background:rgba(18,26,40,.95);
    padding:14px;
  }
  .modalTop{display:flex; justify-content:space-between; align-items:center; gap:12px}
  .modalTitle{font-weight:1100; font-size:16px}
  .modalSub{color:rgba(232,238,252,.70); font-size:12px; margin-top:6px}
  .modalBtns{display:flex; gap:10px; margin-top:12px; flex-wrap:wrap}
  input{
    width:100%;
    padding:12px 12px;
    border-radius:14px;
    border:1px solid var(--line);
    background:rgba(15,22,35,.65);
    color:var(--text);
    font-weight:1000;
    outline:none;
  }
</style>

<script>
/* =========================================================
   CORE HELPERS
========================================================= */
const $ = (id)=>document.getElementById(id);
function escapeHtml(s){
  return String(s ?? "").replace(/[&<>"']/g, m=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[m]));
}
let _toastTimer=null;
function toast(msg){
  const t = $("toast");
  if(!t) return;
  t.textContent = msg;
  t.classList.add("show");
  clearTimeout(_toastTimer);
  _toastTimer=setTimeout(()=>t.classList.remove("show"), 1400);
}
function clamp(n,a,b){ return Math.max(a, Math.min(b, n)); }

/* =========================================================
   SAVE / LOAD
========================================================= */
const STORAGE_KEY = "wheel_forge_v1_save";
const defaultSave = ()=>({
  settings:{ sound:true },
  roster:[],              // list of characters
  activeId:null,          // current character id
  ui:{ activeTab:"build" }
});
let save = defaultSave();

function saveNow(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(save)); }

function repairChar(c){
  if(!c || typeof c !== "object") return;

  c.alive = (c.alive !== false);
  c.buildComplete = !!c.buildComplete;

  // FIX: wheelStep can become NaN/undefined in older saves
  const ws = Number(c.wheelStep);
  c.wheelStep = (Number.isFinite(ws) && ws >= 0) ? Math.floor(ws) : 0;

  // strikes (your rules)
  c.strikesPVE = Number.isFinite(Number(c.strikesPVE)) ? Number(c.strikesPVE) : 0; // 1 strike = death
  c.strikesPVP = Number.isFinite(Number(c.strikesPVP)) ? Number(c.strikesPVP) : 0; // 2 strikes = death

  // results fields
  c.race ??= null;
  c.raceSub ??= null;
  c.height ??= null;
  c.strength ??= null;
  c.durability ??= null;
  c.speed ??= null;
  c.iq ??= null;
  c.fight ??= null;
  c.power ??= null;
  c.weapon ??= null;
  c.trainer ??= null;
  c.powerMastery ??= null;
  c.weaponMastery ??= null;
  c.extraForm ??= null;

  // inventory must always exist
  c.inventory ||= {};
  c.inventory.races ||= [];
  c.inventory.powers ||= [];
  c.inventory.weapons ||= [];
  c.inventory.trainers ||= [];
  c.inventory.effects ||= [];
  c.inventory.curses ||= [];

  // OPTIONAL: bump wheelStep forward if fields already filled
  let step = 0;
  if(c.race) step = 1;
  if(c.raceSub) step = 2;
  if(c.height) step = 3;
  if(c.strength) step = 4;
  if(c.durability) step = 5;
  if(c.speed) step = 6;
  if(c.iq) step = 7;
  if(c.fight) step = 8;
  if(c.power) step = 9;
  if(c.weapon) step = 10;
  if(c.trainer) step = 11;
  if(c.powerMastery) step = 12;
  if(c.weaponMastery) step = 13;
  if(c.extraForm) step = 14;
  if(c.buildComplete) step = 14;

  if(step > c.wheelStep) c.wheelStep = step;
}

function load(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(!raw) return;
    const parsed = JSON.parse(raw);
    save = { ...defaultSave(), ...parsed };
    save.settings = { ...defaultSave().settings, ...(parsed.settings||{}) };
    save.ui = { ...defaultSave().ui, ...(parsed.ui||{}) };
    save.roster = Array.isArray(parsed.roster) ? parsed.roster : [];

    save.roster.forEach(repairChar);
    saveNow();
  }catch(e){}
}
load();

/* =========================================================
   CHARACTER MODEL
   - New Character creates new (does NOT delete old)
   - Only dies via loss rules
========================================================= */
function makeNewCharacter(){
  const id = "c_" + Math.random().toString(16).slice(2) + Date.now().toString(16);

  const char = {
    id,
    createdAt: Date.now(),
    alive:true,
    name:"",

    strikesPVE:0,  // 1 strike -> death
    strikesPVP:0,  // 2 strikes -> death

    buildComplete:false,
    wheelStep:0,

    race:null,
    raceSub:null,
    height:null,
    strength:null,
    durability:null,
    speed:null,
    iq:null,
    fight:null,
    power:null,
    weapon:null,
    trainer:null,
    powerMastery:null,
    weaponMastery:null,
    extraForm:null,

    inventory:{
      races:[],
      powers:[],
      weapons:[],
      trainers:[],
      effects:[],
      curses:[]
    }
  };

  save.roster.push(char);
  save.activeId = id;
  saveNow();
  return char;
}

function getActiveCharRaw(){
  return save.roster.find(x=>x.id===save.activeId) || null;
}

function ensureActiveChar(){
  let c = getActiveCharRaw();
  if(!c){
    c = makeNewCharacter();
  }
  repairChar(c);
  return c;
}

function killCharacter(char, reason){
  char.alive = false;
  char.buildComplete = false;
  logBuild(`â˜ ï¸ ${char.name || "Character"} died. (${reason})`);
  toast("Character died.");
  saveNow();

  // switch to newest alive, else create new
  const alive = save.roster.filter(x=>x.alive);
  if(alive.length){
    save.activeId = alive[alive.length-1].id;
  }else{
    makeNewCharacter();
  }
  saveNow();
  refreshUI();
}

/* =========================================================
   TABS
========================================================= */
function showTab(key){
  ["build","stats","pve","pvp"].forEach(k=>{
    $("tab-"+k)?.classList.toggle("hidden", k!==key);
    document.querySelector(`.tab[data-tab="${k}"]`)?.classList.toggle("active", k===key);
  });
  save.ui.activeTab = key;
  saveNow();
}
document.querySelectorAll(".tab[data-tab]").forEach(btn=>{
  btn.addEventListener("click", ()=>showTab(btn.dataset.tab));
});

/* =========================================================
   BUILD LOG
========================================================= */
function logBuild(msg){
  const el = $("buildLog");
  if(!el) return;
  const time = new Date().toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
  el.innerHTML = `<div><span class="muted">[${time}]</span> ${escapeHtml(msg)}</div>` + el.innerHTML;
}

/* =========================================================
   NAME SAFETY (simple local filter)
========================================================= */
const BANNED_PATTERNS = [
  /nigg/i, /fagg/i, /cunt/i, /bitch/i, /whore/i, /slut/i,
  /hitler/i, /kkk/i,
  /fuck/i, /shit/i, /asshole/i, /dick/i, /pussy/i
];
function isNameAllowed(name){
  const n = String(name||"").trim();
  if(n.length < 1) return { ok:false, reason:"Name canâ€™t be empty." };
  if(n.length > 12) return { ok:false, reason:"Max 12 characters." };
  if(!/^[a-z0-9 ._-]+$/i.test(n)) return { ok:false, reason:"Only letters/numbers/spaces/._- allowed." };
  for(const rx of BANNED_PATTERNS){
    if(rx.test(n)) return { ok:false, reason:"That name isnâ€™t allowed." };
  }
  return { ok:true, reason:"" };
}

/* =========================================================
   NAME MODAL (no renaming later)
========================================================= */
function openNameModal(){
  const c = ensureActiveChar();
  if(c.name){
    toast("No renaming allowed.");
    return;
  }
  $("nameInput").value = "";
  $("nameWarn").textContent = "";
  $("nameModal").classList.remove("hidden");
}
$("nameBtn")?.addEventListener("click", openNameModal);
$("nameCloseBtn")?.addEventListener("click", ()=>$("nameModal")?.classList.add("hidden"));
$("nameSaveBtn")?.addEventListener("click", ()=>{
  const c = ensureActiveChar();
  if(c.name){
    toast("No renaming allowed.");
    $("nameModal").classList.add("hidden");
    return;
  }
  const name = $("nameInput").value;
  const chk = isNameAllowed(name);
  if(!chk.ok){
    $("nameWarn").textContent = chk.reason;
    toast(chk.reason);
    return;
  }
  c.name = name.trim();
  logBuild(`Name set â†’ ${c.name}`);
  $("nameModal").classList.add("hidden");
  saveNow();
  refreshUI();
});

/* =========================================================
   UI RENDER (basic)
========================================================= */
function renderBuildSummary(){
  const c = ensureActiveChar();
  const host = $("buildStats");
  if(!host) return;

  const lines = [
    ["Name", c.name || "â€”"],
    ["Alive", c.alive ? "Yes" : "No"],
    ["Step", String(c.wheelStep)],
    ["Race", c.race || "â€”"],
    ["Race Wheel", c.raceSub || "â€”"],
    ["Height", c.height || "â€”"],
    ["Strength", c.strength || "â€”"],
    ["Durability", c.durability || "â€”"],
    ["Speed", c.speed || "â€”"],
    ["IQ", c.iq || "â€”"],
    ["Fight", c.fight || "â€”"],
    ["Power", c.power || "â€”"],
    ["Weapon", c.weapon || "â€”"],
    ["Trainer", c.trainer || "â€”"],
    ["Power Mastery", c.powerMastery || "â€”"],
    ["Weapon Mastery", c.weaponMastery || "â€”"],
    ["Extra Wheel", c.extraForm || "â€”"],
    ["Build Complete", c.buildComplete ? "YES" : "No"]
  ];

  host.innerHTML = "";
  lines.forEach(([k,v])=>{
    const div=document.createElement("div");
    div.className="statLine";
    div.innerHTML = `<div class="statKey">${escapeHtml(k)}</div><div class="statVal">${escapeHtml(v)}</div>`;
    host.appendChild(div);
  });

  $("phaseTag").textContent = c.buildComplete ? "Phase: Complete" : "Phase: Build";
  $("namedTag").textContent = c.name ? `Name: ${c.name}` : "Tap Name";
}

function renderTraitSlots(){
  const host = $("traitSlots");
  if(!host) return;
  host.innerHTML = "";

  const slots = [
    {title:"Fusion Slot 1", desc:"Unlock later in V1."},
    {title:"Fusion Slot 2", desc:"Unlock later in V1."},
    {title:"Curse Slot", desc:"Unlock later in V1."},
    {title:"Effect Slot", desc:"Unlock later in V1."}
  ];

  slots.forEach(s=>{
    const div=document.createElement("div");
    div.className="slotCard slotLocked";
    div.innerHTML = `
      <div class="slotTop">
        <div class="slotName">${escapeHtml(s.title)}</div>
        <div class="muted" style="font-size:12px">Locked</div>
      </div>
      <div class="slotDesc">${escapeHtml(s.desc)}</div>
    `;
    host.appendChild(div);
  });
}

function refreshUI(){
  ensureActiveChar();
  renderBuildSummary();
  renderTraitSlots();
  showTab(save.ui.activeTab || "build");
}

/* =========================================================
   BUTTONS
========================================================= */
$("newCharBtn")?.addEventListener("click", ()=>{
  makeNewCharacter();
  $("buildLog").innerHTML = "";
  logBuild("ðŸ†• New character created.");
  toast("New character created.");
  refreshUI();
});

/* Init */
refreshUI();
</script>
    <!-- =========================
PART 4 / 12 â€” Tabs + Wheel Engine + Wheel Flow (FIXED)
========================= -->

<!-- STATS TAB -->
<section id="tab-stats" class="grid hidden">
  <div class="card">
    <h2>Character Summary</h2>
    <div id="statsSummary" class="statList"></div>

    <h2 style="margin-top:12px">Inventory (All-Time)</h2>
    <div class="muted" style="margin-bottom:8px">
      Shows everything this character has ever obtained (not just from spins).
    </div>
    <div id="statsInventory" class="statList"></div>
  </div>

  <div class="card">
    <h2>Final Stats</h2>
    <div class="muted" style="margin-bottom:8px">
      Final stats are calculated after the full build is complete.
    </div>
    <div id="finalStatsList" class="statList"></div>
  </div>
</section>

<!-- PVE TAB (dev-only for now; locked until build complete) -->
<section id="tab-pve" class="grid hidden">
  <div class="card">
    <h2>PvE</h2>
    <div class="muted" style="margin-bottom:10px">PvE unlocks after Build Complete. (Dev-only in V1.)</div>
    <button id="pveStartBtn" class="btn primary">Start PvE</button>
    <div class="card" style="margin-top:12px; padding:12px; background:rgba(15,22,35,.45); border-color:rgba(255,255,255,.08)">
      <h2>Combat Log</h2>
      <div id="pveLog" class="muted"></div>
    </div>
  </div>
  <div class="card">
    <h2>Status</h2>
    <div id="pveStatus" class="muted">â€”</div>
  </div>
</section>

<!-- PVP TAB (dev-only for now; locked until build complete) -->
<section id="tab-pvp" class="grid hidden">
  <div class="card">
    <h2>PvP</h2>
    <div class="muted" style="margin-bottom:10px">Real PvP upload/fight is planned later. (Dev-only in V1.)</div>
    <button id="pvpStartBtn" class="btn primary">Start PvP (Dev)</button>
    <div class="card" style="margin-top:12px; padding:12px; background:rgba(15,22,35,.45); border-color:rgba(255,255,255,.08)">
      <h2>Combat Log</h2>
      <div id="pvpLog" class="muted"></div>
    </div>
  </div>
  <div class="card">
    <h2>Status</h2>
    <div id="pvpStatus" class="muted">â€”</div>
  </div>
</section>

<script>
/* =========================================================
   LISTS
========================================================= */
const RACE_LIST = [
  "Gnome","Goblin","Zombie","Skeleton","Human","Orc","Cyborg","Giant","Demi human","Golem",
  "Dragon","Vampire","Hivemind","Shinigami","Soul eater","Demon","Alien","God","Hybrid"
];

const POWER_LIST = [
  "No Power",
  "Adaptation","Regeneration","Gravity Manipulation","Time Manipulation","Telekinesis",
  "Teleportation","Fire","Ice Manipulation","Lightning","Weapon Creation","Heavenly Restriction",
  "Immortal","Rinnegan",
  "Super saiyen"
];

const WEAPON_LIST = [
  "No Weapon","Sword","Scythe","Axe","Hammer","Spear","Brass Knuckles","Blades of Chaos",
  "Samehada","Uzumaki Chains","Infinity Gauntlet","Green Lantern Ring"
];

const TRAINER_LIST = ["No Trainer","Master Roshi","Jiraiya","Hisoka","Korro","Yuujirou"];
const POWER_MASTERY_LIST = ["None","Dormant","Awakening","Controlled","Mastered","Planetary","Cosmic","Universal","Omnipotent"];
const WEAPON_MASTERY_LIST = ["None","Basic","Skilled","Expert","Master","Legendary","Mythic"];

const GOD_TIERS = ["Halfling","Demigod","Lesser diety","Deity","Greater diety","Roman","Norse","Greek"];
const DEMON_RANKS = ["Jelly","Knight","Earl","Marquis","Prince","Duke","King"];
const KAIJU_LIST = ["King Kong","Rodan","Ghidorah","Destoroyah","Gezora","Cloverfield","Mothra","Kumanga","Kaiju No 8","Godzilla"];
const KAIJU_NO8_NUMS = ["1","2","4","6","8","9","10","11","12","13","14","15"];
const SUPER_SAIYAN_FORMS = ["Super saiyen","Super saiyen 4","Super saiyen god","Super saiyen blue","Ultra instinct"];

const STRENGTH_WHEEL = ["Weak","Average","Strong","City","Mountain","Country","Planet","Star","Galaxy","Universal","???"];
const DURABILITY_WHEEL = ["Fragile","Average","Tough","Steel","City","Mountain","Country","Planet","Star","Universal","???"];
const SPEED_WHEEL = ["Slow","Average","Fast","Mach","Lightning","Light","FTL","Galaxy","Universal","???"];
const IQ_WHEEL = ["Low","Average","Smart","Genius","Supergenius","Cosmic","Universal","???"];
const FIGHT_WHEEL = ["Clumsy","Average","Trained","Elite","Master","Legendary","Mythic","Universal","???"];

/* Height wheels */
const HEIGHT_SMALL = ["Small","Short","Average"];
const HEIGHT_HUMAN = ["Short","Average","Tall"];
const HEIGHT_GIANT = ["Giant","Colossal","Titanic"];

function heightWheelForRace(race){
  const giantRaces = new Set(["Giant","Golem","Dragon"]);
  const smallRaces = new Set(["Gnome","Goblin"]);
  if(giantRaces.has(race)) return HEIGHT_GIANT;
  if(smallRaces.has(race)) return HEIGHT_SMALL;
  return HEIGHT_HUMAN;
}

/* Race-subwheel placeholders (must NEVER be undefined/empty) */
function raceSubwheelForRace(race){
  switch(race){
    case "Demi human": return ["Wolf","Cat","Bear","Fox","Snake"];
    case "Golem": return ["Stone","Iron","Crystal","Magma"];
    case "Dragon": return ["Fire Dragon","Ice Dragon","Storm Dragon","Shadow Dragon"];
    case "Vampire": return ["Pureblood","Turned","Ancient"];
    case "Hivemind": return ["Swarm","Queen","Parasite"];
    case "Shinigami": return ["Reaper","Captain","Royal Guard"];
    case "Soul eater": return ["Weapon User","Demon Weapon","Meister"];
    case "Cyborg": return ["Arm Cannon","Titan Frame","Nano Core"];
    case "Alien": return ["Grey","Martian","Starborn"];
    case "God": return ["Minor","Major","Prime"];
    default: return ["None"];
  }
}

/* =========================================================
   WHEEL ENGINE (single canvas, multi-phase)
========================================================= */
let wheelAngle = 0;
let wheelSpinning = false;
let currentWheel = { title:"Race", key:"race", options:[...RACE_LIST] };

function safeOptions(options){
  return (Array.isArray(options) && options.length) ? options : ["None"];
}

function setWheel(title, key, options){
  currentWheel = { title, key, options: safeOptions(options) };
  $("wheelTitle").textContent = title;
  $("wheelHint").textContent = "Spin";
  drawWheel();
}

function drawWheel(){
  const canvas = $("wheel");
  if(!canvas) return;
  const ctx = canvas.getContext("2d");
  if(!ctx) return;

  const w = canvas.width, h = canvas.height;
  ctx.clearRect(0,0,w,h);

  const cx=w/2, cy=h/2;
  const r=Math.min(cx,cy)-8;
  const n=currentWheel.options.length;

  ctx.beginPath();
  ctx.arc(cx,cy,r+4,0,Math.PI*2);
  ctx.strokeStyle="rgba(255,255,255,.15)";
  ctx.lineWidth=10;
  ctx.stroke();

  for(let i=0;i<n;i++){
    const a0 = wheelAngle + (i * (Math.PI*2/n));
    const a1 = wheelAngle + ((i+1) * (Math.PI*2/n));

    ctx.beginPath();
    ctx.moveTo(cx,cy);
    ctx.arc(cx,cy,r,a0,a1);
    ctx.closePath();
    ctx.fillStyle = i%2===0 ? "rgba(122,168,255,.14)" : "rgba(255,255,255,.06)";
    ctx.fill();

    const mid=(a0+a1)/2;
    ctx.save();
    ctx.translate(cx,cy);
    ctx.rotate(mid);
    ctx.textAlign="right";
    ctx.fillStyle="rgba(232,238,252,.92)";
    ctx.font="900 14px system-ui";
    ctx.fillText(currentWheel.options[i], r-14, 6);
    ctx.restore();
  }

  // pointer at TOP
  ctx.beginPath();
  ctx.moveTo(cx, 10);
  ctx.lineTo(cx-12, 34);
  ctx.lineTo(cx+12, 34);
  ctx.closePath();
  ctx.fillStyle="rgba(255,204,102,.95)";
  ctx.fill();
}

/* Pointer is TOP: -PI/2 in canvas coords */
function pickFromWheel(){
  const n = currentWheel.options.length;
  const slice = (Math.PI*2)/n;
  const pointer = -Math.PI/2;

  let rel = (pointer - wheelAngle) % (Math.PI*2);
  if(rel < 0) rel += Math.PI*2;

  const idx = Math.floor(rel / slice) % n;
  return currentWheel.options[idx];
}

async function spinWheel(){
  const c = ensureActiveChar();
  if(!c.alive){ toast("Character is dead."); return; }
  if(c.buildComplete){ toast("Build already complete."); return; }
  if(wheelSpinning) return;

  wheelSpinning = true;

  let v = 0.35 + Math.random()*0.35;
  const friction = 0.985 - Math.random()*0.006;
  const minTicks = 60 + Math.floor(Math.random()*40);
  let ticks=0;

  function step(){
    ticks++;
    wheelAngle += v;
    v *= friction;
    drawWheel();

    if(ticks > minTicks && v < 0.01){
      wheelSpinning = false;
      const result = pickFromWheel();
      onSpinResult(result);
      return;
    }
    requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
}

/* =========================================================
   BUILD FLOW / AUTO-ADVANCE (FIXED)
========================================================= */
function applyResultToChar(char, key, value){
  // no redo: only set once
  if(key === "race" && !char.race){
    char.race = value;
    char.inventory.races ||= [];
    if(!char.inventory.races.includes(value)) char.inventory.races.push(value);
    return true;
  }
  if(key === "raceSub" && !char.raceSub){ char.raceSub = value; return true; }
  if(key === "height" && !char.height){ char.height = value; return true; }

  if(key === "strength" && !char.strength){ char.strength = value; return true; }
  if(key === "durability" && !char.durability){ char.durability = value; return true; }
  if(key === "speed" && !char.speed){ char.speed = value; return true; }
  if(key === "iq" && !char.iq){ char.iq = value; return true; }
  if(key === "fight" && !char.fight){ char.fight = value; return true; }

  if(key === "power" && !char.power){
    char.power = value;
    char.inventory.powers ||= [];
    if(value && value!=="No Power" && !char.inventory.powers.includes(value)) char.inventory.powers.push(value);
    return true;
  }
  if(key === "weapon" && !char.weapon){
    char.weapon = value;
    char.inventory.weapons ||= [];
    if(value && value!=="No Weapon" && !char.inventory.weapons.includes(value)) char.inventory.weapons.push(value);
    return true;
  }
  if(key === "trainer" && !char.trainer){
    char.trainer = value;
    char.inventory.trainers ||= [];
    if(value && value!=="No Trainer" && !char.inventory.trainers.includes(value)) char.inventory.trainers.push(value);
    return true;
  }

  if(key === "powerMastery" && !char.powerMastery){ char.powerMastery = value; return true; }
  if(key === "weaponMastery" && !char.weaponMastery){ char.weaponMastery = value; return true; }

  if(key === "extraForm" && !char.extraForm){ char.extraForm = value; return true; }

  return false;
}

/* single source of truth: sets next wheel based on wheelStep */
function autoAdvanceWheel(){
  const c = ensureActiveChar();
  repairChar(c);
  if(c.buildComplete) return;

  // 0 Race
  if(c.wheelStep === 0){
    setWheel("Race", "race", RACE_LIST);
    $("buildHint").textContent = "Spin: Race";
    return;
  }

  // 1 Race-based wheel
  if(c.wheelStep === 1){
    setWheel("Race Wheel", "raceSub", raceSubwheelForRace(c.race));
    $("buildHint").textContent = "Spin: wheel based on your race";
    return;
  }

  // 2 Height
  if(c.wheelStep === 2){
    setWheel("Height", "height", heightWheelForRace(c.race));
    $("buildHint").textContent = "Spin: Height (race-based)";
    return;
  }

  // 3â€“7 stats
  if(c.wheelStep === 3){ setWheel("Strength","strength",STRENGTH_WHEEL); $("buildHint").textContent="Spin: Strength"; return; }
  if(c.wheelStep === 4){ setWheel("Durability","durability",DURABILITY_WHEEL); $("buildHint").textContent="Spin: Durability"; return; }
  if(c.wheelStep === 5){ setWheel("Speed","speed",SPEED_WHEEL); $("buildHint").textContent="Spin: Speed"; return; }
  if(c.wheelStep === 6){ setWheel("IQ","iq",IQ_WHEEL); $("buildHint").textContent="Spin: IQ"; return; }
  if(c.wheelStep === 7){ setWheel("Fight","fight",FIGHT_WHEEL); $("buildHint").textContent="Spin: Fight"; return; }

  // 8â€“12 gear/mastery
  if(c.wheelStep === 8){ setWheel("Power","power",POWER_LIST); $("buildHint").textContent="Spin: Power"; return; }
  if(c.wheelStep === 9){ setWheel("Weapon","weapon",WEAPON_LIST); $("buildHint").textContent="Spin: Weapon"; return; }
  if(c.wheelStep === 10){ setWheel("Trainer","trainer",TRAINER_LIST); $("buildHint").textContent="Spin: Trainer"; return; }
  if(c.wheelStep === 11){ setWheel("Power Mastery","powerMastery",POWER_MASTERY_LIST); $("buildHint").textContent="Spin: Power Mastery"; return; }
  if(c.wheelStep === 12){ setWheel("Weapon Mastery","weaponMastery",WEAPON_MASTERY_LIST); $("buildHint").textContent="Spin: Weapon Mastery"; return; }

  // 13 Extra wheel (race/power based)
  if(c.wheelStep === 13){
    // Alien chain: Kaiju -> if Kaiju No 8 => then next spin should be number
    if(c.race === "Alien" && c.extraForm === "Kaiju No 8"){
      // NOTE: we store the Kaiju choice first, then overwrite with number.
      setWheel("Kaiju No 8", "extraForm", KAIJU_NO8_NUMS);
      $("buildHint").textContent = "Spin: Kaiju No 8 (number)";
      return;
    }

    if(c.race === "God" && !c.extraForm){
      setWheel("God Tiers", "extraForm", GOD_TIERS);
      $("buildHint").textContent = "Spin: God Tier";
      return;
    }
    if(c.race === "Demon" && !c.extraForm){
      setWheel("Demon Ranks", "extraForm", DEMON_RANKS);
      $("buildHint").textContent = "Spin: Demon Rank";
      return;
    }
    if(c.race === "Alien" && !c.extraForm){
      setWheel("Kaiju", "extraForm", KAIJU_LIST);
      $("buildHint").textContent = "Spin: Kaiju";
      return;
    }
    if(c.power === "Super saiyen" && !c.extraForm){
      setWheel("Super Saiyen", "extraForm", SUPER_SAIYAN_FORMS);
      $("buildHint").textContent = "Spin: Super Saiyen form";
      return;
    }

    // No extra needed -> complete
    c.wheelStep = 14;
    saveNow();
  }

  // 14 Complete
  if(c.wheelStep >= 14){
    c.buildComplete = true;
    $("buildHint").textContent = "Build Complete â†’ Stats / PvE unlocked (dev-only) / PvP (dev-only)";
    toast("Build Complete!");
    saveNow();
    refreshUI();
    return;
  }
}

function onSpinResult(result){
  const c = ensureActiveChar();
  repairChar(c);

  // FIX: wheelStep must be numeric
  const step = Number.isFinite(Number(c.wheelStep)) ? Number(c.wheelStep) : 0;

  const wrote = applyResultToChar(c, currentWheel.key, result);
  logBuild(`${currentWheel.title} â†’ ${result}`);

  // if it was already set, DO NOT advance (prevents breaking saves)
  if(!wrote){
    toast("No redo. That step is already locked.");
    autoAdvanceWheel();
    drawWheel();
    refreshUI();
    return;
  }

  // advance
  c.wheelStep = step + 1;

  // SPECIAL: Alien Kaiju chain
  if(currentWheel.title === "Kaiju" && currentWheel.key === "extraForm"){
    if(result === "Kaiju No 8"){
      // keep at 13 so next wheel becomes Kaiju No 8 number
      c.wheelStep = 13;
      // keep memory that we selected Kaiju No 8
      c.extraForm = "Kaiju No 8";
    }else{
      // skip to complete
      c.wheelStep = 14;
    }
  }

  saveNow();
  autoAdvanceWheel();
  drawWheel();
  refreshUI();
}

/* =========================================================
   STATS TAB RENDER
========================================================= */
function renderStatsTab(){
  const c = ensureActiveChar();

  // Summary
  const sumHost = $("statsSummary");
  if(sumHost){
    sumHost.innerHTML = "";
    const summary = [
      ["Name", c.name || "â€”"],
      ["Alive", c.alive ? "Yes" : "No"],
      ["Race", c.race || "â€”"],
      ["Race Wheel", c.raceSub || "â€”"],
      ["Height", c.height || "â€”"],
      ["Strength", c.strength || "â€”"],
      ["Durability", c.durability || "â€”"],
      ["Speed", c.speed || "â€”"],
      ["IQ", c.iq || "â€”"],
      ["Fight", c.fight || "â€”"],
      ["Power", c.power || "â€”"],
      ["Weapon", c.weapon || "â€”"],
      ["Trainer", c.trainer || "â€”"],
      ["Power Mastery", c.powerMastery || "â€”"],
      ["Weapon Mastery", c.weaponMastery || "â€”"],
      ["Extra", c.extraForm || "â€”"],
      ["Build Complete", c.buildComplete ? "YES" : "No"]
    ];
    summary.forEach(([k,v])=>{
      const div=document.createElement("div");
      div.className="statLine";
      div.innerHTML = `<div class="statKey">${escapeHtml(k)}</div><div class="statVal">${escapeHtml(v)}</div>`;
      sumHost.appendChild(div);
    });
  }

  // Inventory
  const invHost = $("statsInventory");
  if(invHost){
    invHost.innerHTML = "";
    const inv = c.inventory || {};
    const rows = [
      ["Races", (inv.races||[]).join(", ") || "â€”"],
      ["Powers", (inv.powers||[]).join(", ") || "â€”"],
      ["Weapons", (inv.weapons||[]).join(", ") || "â€”"],
      ["Trainers", (inv.trainers||[]).join(", ") || "â€”"],
      ["Curses", (inv.curses||[]).join(", ") || "â€”"],
      ["Effects", (inv.effects||[]).join(", ") || "â€”"]
    ];
    rows.forEach(([k,v])=>{
      const div=document.createElement("div");
      div.className="statLine";
      div.innerHTML = `<div class="statKey">${escapeHtml(k)}</div><div class="statVal">${escapeHtml(v)}</div>`;
      invHost.appendChild(div);
    });
  }

  // Final stats placeholder (Part 5 makes real math)
  const finHost = $("finalStatsList");
  if(finHost){
    finHost.innerHTML = "";
    const locked = !c.buildComplete;
    const rows = locked ? [
      ["Locked", "Complete the build to calculate final stats."]
    ] : [
      ["(Math)", "Real stat math loads in Part 5."]
    ];
    rows.forEach(([k,v])=>{
      const div=document.createElement("div");
      div.className="statLine";
      div.innerHTML = `<div class="statKey">${escapeHtml(k)}</div><div class="statVal">${escapeHtml(v)}</div>`;
      finHost.appendChild(div);
    });
  }
}

/* Extend refreshUI */
const _refreshUI_p4 = refreshUI;
refreshUI = function(){
  _refreshUI_p4();
  renderStatsTab();

  const c = ensureActiveChar();
  autoAdvanceWheel();
  drawWheel();

  const locked = !c.buildComplete;
  if($("pveStartBtn")) $("pveStartBtn").disabled = locked;
  if($("pvpStartBtn")) $("pvpStartBtn").disabled = locked;
  if($("pveStatus")) $("pveStatus").textContent = locked ? "Locked until Build Complete." : "Unlocked (dev-only).";
  if($("pvpStatus")) $("pvpStatus").textContent = locked ? "Locked until Build Complete." : "Unlocked (dev-only).";
};

/* Buttons */
$("spinBtn")?.addEventListener("click", spinWheel);
$("finalizeBtn")?.addEventListener("click", ()=>toast("No finalize needed. Just keep spinning."));
$("skipBtn")?.addEventListener("click", ()=>toast("Skip is dev-only."));
$("testFastBtn")?.addEventListener("click", ()=>toast("Fast spin is dev-only."));

/* Dev-only PvE/PvP placeholders */
$("pveStartBtn")?.addEventListener("click", ()=>{
  const c = ensureActiveChar();
  if(!c.buildComplete){ toast("Locked."); return; }
  const el = $("pveLog");
  if(el) el.innerHTML = `<div>${escapeHtml("PvE (dev-only) will be expanded in later parts.")}</div>` + el.innerHTML;
});
$("pvpStartBtn")?.addEventListener("click", ()=>{
  const c = ensureActiveChar();
  if(!c.buildComplete){ toast("Locked."); return; }
  const el = $("pvpLog");
  if(el) el.innerHTML = `<div>${escapeHtml("PvP upload/fight is planned later.")}</div>` + el.innerHTML;
});

/* Init */
(function initP4(){
  ensureActiveChar();
  autoAdvanceWheel();
  drawWheel();
  refreshUI();
})();
</script>
    <!-- =========================
PART 5 / 12 â€” Stat Math + Stability + Death (FIXED)
========================= -->
<script>
/* =========================================================
   STAT WORD â†’ NUMBER MAPPING
========================================================= */
const STAT_NUMBER_MAP = {
  strength: {
    "Weak":1,"Average":2,"Strong":3,"City":5,"Mountain":7,"Country":9,
    "Planet":12,"Star":15,"Galaxy":18,"Universal":22,"???":30
  },
  durability: {
    "Fragile":1,"Average":2,"Tough":3,"Steel":5,"City":7,"Mountain":9,
    "Country":11,"Planet":14,"Star":17,"Universal":22,"???":30
  },
  speed: {
    "Slow":1,"Average":2,"Fast":3,"Mach":5,"Lightning":7,"Light":10,
    "FTL":14,"Galaxy":18,"Universal":22,"???":30
  },
  iq: {
    "Low":1,"Average":2,"Smart":3,"Genius":5,"Supergenius":7,
    "Cosmic":12,"Universal":18,"???":25
  },
  fight: {
    "Clumsy":1,"Average":2,"Trained":3,"Elite":5,"Master":7,
    "Legendary":10,"Mythic":14,"Universal":20,"???":30
  }
};
function statWordToNumber(type, word){
  return STAT_NUMBER_MAP[type]?.[word] ?? 0;
}
function labelForStat(type, value){
  const map = STAT_NUMBER_MAP[type] || {};
  let best = "???";
  for(const [label,num] of Object.entries(map)){
    if(value >= num) best = label;
  }
  return best;
}

/* =========================================================
   MODIFIERS (ADDITIVE)
========================================================= */
function powerMods(p){
  switch(p){
    case "Adaptation": return { durability:+2, stability:-1 };
    case "Regeneration": return { durability:+3, stability:-2, regen:true };
    case "Immortal": return { durability:+4, stability:-3, immortal:true };
    case "Gravity Manipulation": return { strength:+2, fight:+1 };
    case "Time Manipulation": return { speed:+3, iq:+1, stability:-2 };
    case "Lightning": return { speed:+2 };
    case "Super saiyen": return { strength:+3, speed:+2, stability:-2 };
    default: return {};
  }
}
function weaponMods(w){
  switch(w){
    case "Sword": return { fight:+2 };
    case "Axe": return { strength:+2 };
    case "Hammer": return { strength:+2, durability:+1 };
    case "Infinity Gauntlet": return { strength:+4, durability:+4, iq:+2, stability:-4 };
    default: return {};
  }
}
function trainerMods(t){
  switch(t){
    case "Master Roshi": return { fight:+2, iq:+1 };
    case "Yuujirou": return { strength:+3, fight:+2, stability:-1 };
    default: return {};
  }
}

/* =========================================================
   STABILITY
========================================================= */
const MAX_STABILITY = 5;
const MIN_STABILITY = -10;

function computeStability(char){
  let s = MAX_STABILITY;

  if(char.power){
    const pm = powerMods(char.power);
    if(typeof pm.stability === "number") s += pm.stability;
  }
  if(char.weapon){
    const wm = weaponMods(char.weapon);
    if(typeof wm.stability === "number") s += wm.stability;
  }
  if(char.trainer){
    const tm = trainerMods(char.trainer);
    if(typeof tm.stability === "number") s += tm.stability;
  }

  return Math.max(MIN_STABILITY, s);
}
function isUnstable(char){
  return computeStability(char) < 0;
}

/* =========================================================
   FINAL STATS (REAL)
========================================================= */
function computeFinalStats(char){
  let out = {
    strength: statWordToNumber("strength", char.strength),
    durability: statWordToNumber("durability", char.durability),
    speed: statWordToNumber("speed", char.speed),
    iq: statWordToNumber("iq", char.iq),
    fight: statWordToNumber("fight", char.fight),
    stability: computeStability(char),
    immortal:false,
    regen:false
  };

  if(char.power){
    const p = powerMods(char.power);
    for(const k of Object.keys(p)){
      if(typeof p[k] === "number") out[k] = (out[k] || 0) + p[k];
      if(k==="immortal") out.immortal = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen" || k==="regen") out.regen = true;
      if(k==="regen" || k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
      if(k==="regen") out.regen = true;
    }
  }

  if(char.weapon){
    const w = weaponMods(char.weapon);
    for(const k of Object.keys(w)){
      if(typeof w[k] === "number") out[k] = (out[k] || 0) + w[k];
    }
  }

  if(char.trainer){
    const t = trainerMods(char.trainer);
    for(const k of Object.keys(t)){
      if(typeof t[k] === "number") out[k] = (out[k] || 0) + t[k];
    }
  }

  // simple mastery scaling
  if(char.powerMastery === "Cosmic") out.strength += 2;
  if(char.powerMastery === "Universal") out.strength += 4;
  if(char.powerMastery === "Omnipotent") out.strength += 6;

  out.labels = {
    strength: labelForStat("strength", out.strength),
    durability: labelForStat("durability", out.durability),
    speed: labelForStat("speed", out.speed),
    iq: labelForStat("iq", out.iq),
    fight: labelForStat("fight", out.fight),
  };

  return out;
}

/* =========================================================
   DEATH SYSTEM (your rules)
   - PvE: 1 strike = death
   - PvP: 2 strikes = death
========================================================= */
function applyPvELoss(char){
  char.strikesPVE = (char.strikesPVE || 0) + 1;
  if(char.strikesPVE >= 1) killCharacter(char, "PvE loss");
  saveNow();
}
function applyPvPLoss(char){
  char.strikesPVP = (char.strikesPVP || 0) + 1;
  if(char.strikesPVP >= 2) killCharacter(char, "PvP strikes (2/2)");
  saveNow();
}

/* Immortal or Regeneration blocks instant-death */
function canDieInstantly(char){
  const fin = computeFinalStats(char);
  if(fin.immortal) return false;
  if(fin.regen) return false;
  return true;
}

/* =========================================================
   STATS TAB FINAL OUTPUT
========================================================= */
const _renderStatsTab_p5 = renderStatsTab;
renderStatsTab = function(){
  _renderStatsTab_p5();

  const c = ensureActiveChar();
  const host = $("finalStatsList");
  if(!host) return;

  host.innerHTML = "";

  if(!c.buildComplete){
    const d=document.createElement("div");
    d.className="statLine";
    d.innerHTML = `<div class="statKey">Locked</div><div class="statVal">Complete build first.</div>`;
    host.appendChild(d);
    return;
  }

  const fin = computeFinalStats(c);

  [
    ["Strength", `${fin.labels.strength} (${fin.strength})`],
    ["Durability", `${fin.labels.durability} (${fin.durability})`],
    ["Speed", `${fin.labels.speed} (${fin.speed})`],
    ["IQ", `${fin.labels.iq} (${fin.iq})`],
    ["Fight", `${fin.labels.fight} (${fin.fight})`],
    ["Stability", String(fin.stability)],
    ["Immortal", fin.immortal ? "Yes" : "No"],
    ["Regeneration", fin.regen ? "Yes" : "No"]
  ].forEach(([k,v])=>{
    const d=document.createElement("div");
    d.className="statLine";
    d.innerHTML=`<div class="statKey">${escapeHtml(k)}</div><div class="statVal">${escapeHtml(v)}</div>`;
    host.appendChild(d);
  });

  if(isUnstable(c)){
    const warn=document.createElement("div");
    warn.className="statLine";
    warn.innerHTML=`<div class="statKey">âš  Unstable</div><div class="statVal">Power overload</div>`;
    host.appendChild(warn);
  }
};

/* =========================================================
   DEV-ONLY COMBAT HOOKS (TEMP)
========================================================= */
$("pveStartBtn")?.addEventListener("click", ()=>{
  const c = ensureActiveChar();
  if(!c.buildComplete || !c.alive) return;

  if(canDieInstantly(c)){
    applyPvELoss(c);
  }else{
    toast("You survived due to regeneration/immortality.");
  }
  refreshUI();
});

$("pvpStartBtn")?.addEventListener("click", ()=>{
  const c = ensureActiveChar();
  if(!c.buildComplete || !c.alive) return;

  if(canDieInstantly(c)){
    applyPvPLoss(c);
  }else{
    toast("You survived due to regeneration/immortality.");
  }
  refreshUI();
});
</script>
    <!-- =========================
PART 6 / 12 â€” Sound + Name UX + Portrait Placeholder + Hybrid Patch (FIXED)
========================= -->
<script>
/* =========================================================
   SAFE GUARDS
========================================================= */
window.saveNow = window.saveNow || function(){};
window.toast = window.toast || function(){};
window.escapeHtml = window.escapeHtml || function(x){ return String(x ?? ""); };
window.ensureActiveChar = window.ensureActiveChar || function(){ return null; };

/* =========================================================
   SOUND SYSTEM (WebAudio, no external files)
========================================================= */
const Sound = (function(){
  let ctx=null;

  function getCtx(){
    if(!ctx){
      ctx = new (window.AudioContext || window.webkitAudioContext)();
    }
    return ctx;
  }

  function beep(freq=440, dur=0.07, type="sine", gain=0.05){
    try{
      const c = ensureActiveChar();
      if(window.save?.settings?.sound === false) return;

      const ac = getCtx();
      const o = ac.createOscillator();
      const g = ac.createGain();
      o.type = type;
      o.frequency.value = freq;
      g.gain.value = gain;
      o.connect(g);
      g.connect(ac.destination);
      o.start();
      o.stop(ac.currentTime + dur);
    }catch(e){}
  }

  function chord(seq){
    seq.forEach((x,i)=>setTimeout(()=>beep(x.f,x.d,x.t,x.g), i*35));
  }

  return {
    click(){ beep(520,0.05,"square",0.035); },
    spin(){ chord([{f:220,d:.06,t:"sine",g:.05},{f:330,d:.06,t:"sine",g:.05},{f:440,d:.06,t:"sine",g:.05}]); },
    win(){ chord([{f:523,d:.08,t:"sine",g:.06},{f:659,d:.10,t:"sine",g:.06},{f:784,d:.12,t:"sine",g:.06}]); },
    warn(){ chord([{f:392,d:.06,t:"square",g:.05},{f:311,d:.08,t:"square",g:.05}]); },
    toggle(){
      try{
        if(!window.save) return true;
        window.save.settings ||= {};
        window.save.settings.sound = !(window.save.settings.sound === true);
        saveNow();
        if(ctx && window.save.settings.sound) ctx.resume();
        return window.save.settings.sound;
      }catch(e){ return true; }
    }
  };
})();

/* Volume button wiring */
(function(){
  const v = document.getElementById("volBtn");
  if(!v) return;

  // ensure default if missing
  if(window.save){
    save.settings ||= {};
    if(typeof save.settings.sound !== "boolean") save.settings.sound = true;
  }

  function paint(){
    const on = (window.save?.settings?.sound !== false);
    v.textContent = on ? "ðŸ”Š" : "ðŸ”‡";
  }
  paint();

  v.addEventListener("click", ()=>{
    const on = Sound.toggle();
    paint();
    toast(on ? "Sound on" : "Sound off");
  });
})();

/* =========================================================
   NAME UX
   - Clicking the namedTag pill opens the name modal (if not named)
========================================================= */
(function(){
  const named = document.getElementById("namedTag");
  if(!named) return;

  named.style.cursor = "pointer";
  named.title = "Tap to set name";

  named.addEventListener("click", ()=>{
    Sound.click();
    const c = ensureActiveChar();
    if(!c) return;

    // No renaming later
    if(c.name){
      toast("No renaming allowed.");
      Sound.warn();
      return;
    }

    // Use Part 3 modal if present
    if(typeof openNameModal === "function"){
      openNameModal();
    }else{
      toast("Name system missing (Part 3).");
      Sound.warn();
    }
  });
})();

/* =========================================================
   PORTRAIT PLACEHOLDER
   - Always shows something in the portrait area.
========================================================= */
function svgDataURI(svg){
  return "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svg);
}

function displayRacePretty(c){
  if(!c) return "â€”";
  if(c.race !== "Hybrid") return c.race || "â€”";
  const a = c.hybridRaces?.[0] || "â€”";
  const b = c.hybridRaces?.[1] || "â€”";
  return `Hybrid (${a} + ${b})`;
}

function setPortrait(prefix, char){
  const img = document.getElementById(prefix + "layer_base");
  if(!img) return;

  const name = (char?.name || "Unknown").slice(0,12);
  const race = displayRacePretty(char);

  const svg = `
  <svg xmlns="http://www.w3.org/2000/svg" width="600" height="600">
    <defs>
      <linearGradient id="g" x1="0" y1="0" x2="1" y2="1">
        <stop offset="0" stop-color="#1b2a45"/>
        <stop offset="1" stop-color="#0b0f17"/>
      </linearGradient>
    </defs>
    <rect width="600" height="600" fill="url(#g)"/>
    <circle cx="300" cy="250" r="120" fill="rgba(122,168,255,.18)" stroke="rgba(255,255,255,.12)" stroke-width="6"/>
    <text x="300" y="268" text-anchor="middle" font-size="46" fill="rgba(232,238,252,.92)" font-family="system-ui" font-weight="900">${escapeHtml(name)}</text>
    <text x="300" y="328" text-anchor="middle" font-size="26" fill="rgba(232,238,252,.65)" font-family="system-ui" font-weight="800">${escapeHtml(race)}</text>
    <text x="300" y="520" text-anchor="middle" font-size="18" fill="rgba(232,238,252,.50)" font-family="system-ui" font-weight="700">Portrait placeholder</text>
  </svg>`;
  img.src = svgDataURI(svg);
}

/* Patch refreshUI to update portrait every time */
(function(){
  if(typeof window.refreshUI !== "function") return;

  const _rui = window.refreshUI;
  window.refreshUI = function(){
    _rui();
    try{
      const c = ensureActiveChar();
      setPortrait("", c);
    }catch(e){}
  };
})();

/* =========================================================
   HYBRID RULE (2 extra race spins)
   - If Race = Hybrid, immediately forces 2 more race spins.
   - Stores: c.race="Hybrid" AND c.hybridRaces=[A,B]
========================================================= */
function ensureHybridFields(c){
  c.hybridRaces ||= [];
  c._hybridPending ||= 0;
}

function applyHybridRace(c, pickedRace){
  ensureHybridFields(c);

  // If they rolled Hybrid at race step:
  if(pickedRace === "Hybrid"){
    c.race = "Hybrid";
    c.hybridRaces = [];
    c._hybridPending = 2;
    toast("Hybrid! Spin 2 more races.");
    Sound.win();
    return true;
  }

  // If Hybrid is collecting sub-races:
  if(c.race === "Hybrid" && c._hybridPending > 0){
    c.hybridRaces.push(pickedRace);
    c._hybridPending -= 1;

    if(c._hybridPending > 0){
      toast(`Hybrid needs ${c._hybridPending} more race spin(s).`);
      Sound.click();
    }else{
      toast(`Hybrid complete: ${c.hybridRaces.join(" + ")}`);
      Sound.win();
    }
    return true;
  }

  return false;
}

/* Wrap applyResultToChar from Part 4 */
(function(){
  if(typeof window.applyResultToChar !== "function") return;

  const _apply = window.applyResultToChar;

  window.applyResultToChar = function(char, key, value){
    // Hybrid logic only on race wheel outcomes:
    if(key === "race"){
      // If race already set to Hybrid and pending, we treat extra spins as hybrid sub-races
      ensureHybridFields(char);

      // If the race slot isn't set yet, we allow it
      if(!char.race){
        const handled = applyHybridRace(char, value);
        // Always count â€œHybridâ€ itself as the race result
        // Inventory still needs to track it
        char.inventory.races ||= [];
        if(!char.inventory.races.includes(value)) char.inventory.races.push(value);

        // If Hybrid was rolled, we DO want Part 4 to consider â€œrace is setâ€
        // and move forward, BUT we will force wheelStep back to 0 until hybrid done.
        if(handled && value === "Hybrid"){
          // we return true so Part 4 advances, then we correct step in onSpinResult wrap below
          return true;
        }

        // If not hybrid, set normal race using original behavior
        return _apply(char, key, value);
      }

      // If Hybrid pending, accept extra race spins even though race already set
      if(char.race === "Hybrid" && char._hybridPending > 0){
        applyHybridRace(char, value);
        // Record in inventory
        char.inventory.races ||= [];
        if(!char.inventory.races.includes(value)) char.inventory.races.push(value);
        return true; // allow â€œwriteâ€ so spin advances; we will control step
      }
    }

    return _apply(char, key, value);
  };
})();

/* Wrap onSpinResult so Hybrid extra spins donâ€™t advance into next wheel until done */
(function(){
  if(typeof window.onSpinResult !== "function") return;

  const _on = window.onSpinResult;
  window.onSpinResult = function(result){
    const c = ensureActiveChar();
    const key = window.currentWheel?.key;

    // Let Part 4 do its normal write+advance first
    _on(result);

    // Then fix wheelStep if Hybrid is still pending:
    try{
      ensureHybridFields(c);

      if(key === "race" && c.race === "Hybrid" && c._hybridPending > 0){
        // Force them to keep spinning race until hybrid done:
        c.wheelStep = 0; // stay on Race wheel
        saveNow();
        if(typeof autoAdvanceWheel === "function") autoAdvanceWheel();
        if(document.getElementById("wheelHint")){
          document.getElementById("wheelHint").textContent = `Hybrid: spin ${c._hybridPending} more race(s)`;
        }
      }

      // After hybrid is complete, jump forward to raceSub step:
      if(c.race === "Hybrid" && c._hybridPending === 0){
        // continue to race-based wheel next
        if(c.wheelStep === 0) c.wheelStep = 1;
        saveNow();
        if(typeof autoAdvanceWheel === "function") autoAdvanceWheel();
      }
    }catch(e){}

    try{ if(typeof refreshUI==="function") refreshUI(); }catch(e){}
  };
})();

/* =========================================================
   DISPLAY HYBRID NICELY IN BUILD SUMMARY + STATS SUMMARY
========================================================= */
(function(){
  if(typeof window.renderBuildSummary === "function"){
    const _rbs = window.renderBuildSummary;
    window.renderBuildSummary = function(){
      _rbs();
      try{
        const c = ensureActiveChar();
        // portrait will update via refreshUI patch
        // update the Race line displayed in build summary:
        // (renderBuildSummary uses the values already, so we only need to update namedTag)
        const named = document.getElementById("namedTag");
        if(named && !c.name) named.textContent = "Tap Name";
      }catch(e){}
    };
  }

  if(typeof window.renderStatsTab === "function"){
    const _rst = window.renderStatsTab;
    window.renderStatsTab = function(){
      _rst();
      try{
        const c = ensureActiveChar();
        const sum = document.getElementById("statsSummary");
        if(!sum) return;

        // Replace the displayed "Race" row if present
        [...sum.querySelectorAll(".statLine")].forEach(line=>{
          const k = line.querySelector(".statKey")?.textContent?.trim();
          if(k === "Race"){
            const v = line.querySelector(".statVal");
            if(v) v.textContent = displayRacePretty(c);
          }
        });
      }catch(e){}
    };
  }
})();

/* =========================================================
   SPIN SOUND
========================================================= */
(function(){
  const spin = document.getElementById("spinBtn");
  if(!spin) return;
  spin.addEventListener("click", ()=>Sound.spin());
})();

/* Run once */
try{ if(typeof refreshUI==="function") refreshUI(); }catch(e){}
</script>
<!-- =========================
PART 7 / 12 â€” Wheel Engine + Auto-Advance Phases + Conditional Wheels
========================= -->
<script>
/* =========================================================
   SECTION 1/6 â€” State migration: single character -> roster
========================================================= */
(function(){
  if(!window.state) return;

  // Hide reset button (you said you don't want it in the actual game)
  const rb = document.getElementById("resetBtn");
  if(rb) rb.style.display = "none";

  state.roster ||= [];
  state.ui ||= {};

  // migrate old state.character into roster once
  if(state.character && !state.activeId){
    const id = "c_" + Math.random().toString(16).slice(2) + Date.now().toString(16);
    state.activeId = id;
    state.roster.push({ id, ...state.character });
    delete state.character; // from now on we use roster
  }

  // if roster empty, create one
  if(!state.roster.length){
    const id = "c_" + Math.random().toString(16).slice(2) + Date.now().toString(16);
    state.activeId = id;
    state.roster.push({
      id,
      alive:true,
      buildComplete:false,
      name:"",
      // wheels:
      race:null,
      raceDetail:null,       // e.g. Kaiju, Demon rank, God tier
      height:null,
      strengthW:null,
      durabilityW:null,
      speedW:null,
      iqW:null,
      fightW:null,
      powers:[],
      powerDetail:null,      // e.g. Super Saiyan form
      weapons:[],
      trainer:"No Trainer",
      powerMastery:"None",
      weaponMastery:"Novice"
    });
  }

  window.getActiveChar = function(){
    const c = state.roster.find(x=>x.id===state.activeId) || state.roster[0];
    if(c) state.activeId = c.id;
    return c;
  };

  // keep Part 6 helper working
  window.ensureActiveChar = window.ensureActiveChar || window.getActiveChar;

  // Save once
  try{ saveNow(); }catch(e){}
})();

/* =========================================================
   SECTION 2/6 â€” Your wheel lists (includes your provided text)
========================================================= */
// Races
const RACE_LIST = [
  "Gnome","Goblin","Zombie","Skeleton","Human","Orc","Cyborg","Giant","Demi human","Golem",
  "Dragon","Vampire","Hivemind","Shinigami","Soul eater","Demon","Alien","God","Hybrid"
];

// Stat words (these are the wheel options for the stat wheels)
const STRENGTH_WORDS = ["Weak","Average","Strong","City","Mountain","Country","Planet","Star","Galaxy","Universal","???"];
const DUR_WORDS      = ["Fragile","Average","Tough","Steel","City","Mountain","Country","Planet","Star","Universal","???"];
const SPEED_WORDS    = ["Slow","Average","Fast","Mach","Lightning","Light","FTL","Galaxy","Universal","???"];
const IQ_WORDS       = ["Low","Average","Smart","Genius","Supergenius","Cosmic","Universal","???"];
const FIGHT_WORDS    = ["Clumsy","Average","Trained","Elite","Master","Legendary","Mythic","Universal","???"];

// Power/Weapon/Trainer/Mastery wheels
const POWER_LIST = [
  "No Power","Adaptation","Regeneration","Gravity Manipulation","Time Manipulation","Telekinesis",
  "Teleportation","Fire","Ice Manipulation","Lightning","Weapon Creation","Heavenly Restriction",
  "Immortal","Rinnegan","Super saiyen"
];
const WEAPON_LIST = [
  "No Weapon","Sword","Scythe","Axe","Hammer","Spear","Brass Knuckles","Blades of Chaos","Samehada",
  "Uzumaki Chains","Infinity Gauntlet","Green Lantern Ring"
];
const TRAINER_LIST = ["No Trainer","Master Roshi","Jiraiya","Hisoka","Korro","Yuujirou"];
const POWER_MASTERY_LIST = ["None","Dormant","Awakening","Controlled","Mastered","Planetary","Cosmic","Universal","Omnipotent"];
const WEAPON_MASTERY_LIST = ["Novice","Skilled","Expert","Master","Grandmaster"]; // 5 levels (you requested)

// Race-based â€œspecial wheelsâ€
const GOD_TIERS = ["Halfling","Demigod","Lesser diety","Deity","Greater diety","Roman","Norse","Greek"];
const DEMON_RANKS = ["Jelly","Knight","Earl","Marquis","Prince","Duke","King"];
const KAIJU_LIST = ["King Kong","Rodan","Ghidorah","Destoroyah","Gezora","Cloverfield","Mothra","Kumanga","Kaiju No 8","Godzilla"];
const KAIJU_NO8_LIST = ["1","2","4","6","8","9","10","11","12","13","14","15"];

// Power-based â€œspecial wheelâ€
const SUPER_SAIYAN_FORMS = ["Super saiyen","Super saiyen 4","Super saiyen god","Super saiyen blue","Ultra instinct"];

// Height wheels (placeholders you can rename anytime)
// Rule you gave: Golem + Dragon should be on Giant height wheel.
// If Hybrid: use the wheel of the *largest* race.
const HEIGHT_WHEELS = {
  tiny:   ["Tiny","Small","Short","Average"],
  small:  ["Small","Short","Average","Tall"],
  medium: ["Short","Average","Tall","Huge"],
  large:  ["Average","Tall","Huge","Massive"],
  giant:  ["Tall","Huge","Massive","Titanic"]
};

// Which height wheel each race uses
const RACE_TO_HEIGHT = {
  "Gnome":"tiny",
  "Goblin":"small",
  "Zombie":"medium",
  "Skeleton":"medium",
  "Human":"medium",
  "Orc":"large",
  "Cyborg":"medium",
  "Giant":"giant",
  "Demi human":"medium",
  "Golem":"giant",
  "Dragon":"giant",
  "Vampire":"medium",
  "Hivemind":"large",
  "Shinigami":"large",
  "Soul eater":"large",
  "Demon":"large",
  "Alien":"large",
  "God":"large",
  "Hybrid":"medium"
};

// Used to decide â€œlargest raceâ€ for Hybrid height wheel
const RACE_SIZE = {
  "Gnome":1,"Goblin":2,"Zombie":3,"Skeleton":3,"Human":3,"Cyborg":3,"Demi human":3,"Vampire":3,
  "Orc":4,"Hivemind":4,"Shinigami":4,"Soul eater":4,"Demon":4,"Alien":4,"God":4,
  "Giant":5,"Golem":5,"Dragon":5,"Hybrid":0
};

/* =========================================================
   SECTION 3/6 â€” Wheel renderer (pointer at TOP is correct)
========================================================= */
const wheelCanvas = document.getElementById("wheel");
const wheelCtx = wheelCanvas?.getContext("2d");

let WHEEL = {
  key:"race",
  title:"Race",
  hint:"Spin to begin",
  options:[...RACE_LIST],
  angle:0,
  spinning:false
};

function setWheel(key, title, hint, options){
  WHEEL.key = key;
  WHEEL.title = title;
  WHEEL.hint = hint;
  WHEEL.options = options.slice();
  const t = document.getElementById("wheelTitle");
  const h = document.getElementById("wheelHint");
  if(t) t.textContent = title;
  if(h) h.textContent = hint;
  drawWheel2();
}

function drawWheel2(){
  if(!wheelCtx || !wheelCanvas) return;
  const ctx = wheelCtx;
  const w = wheelCanvas.width, h = wheelCanvas.height;
  const cx=w/2, cy=h/2;
  const r=Math.min(cx,cy)-10;

  ctx.clearRect(0,0,w,h);

  // ring
  ctx.beginPath();
  ctx.arc(cx,cy,r+5,0,Math.PI*2);
  ctx.strokeStyle="rgba(255,255,255,.15)";
  ctx.lineWidth=10;
  ctx.stroke();

  const n = Math.max(1, WHEEL.options.length);
  const slice = (Math.PI*2)/n;

  for(let i=0;i<n;i++){
    const a0 = WHEEL.angle + i*slice;
    const a1 = WHEEL.angle + (i+1)*slice;

    ctx.beginPath();
    ctx.moveTo(cx,cy);
    ctx.arc(cx,cy,r,a0,a1);
    ctx.closePath();
    ctx.fillStyle = i%2===0 ? "rgba(122,168,255,.14)" : "rgba(255,255,255,.06)";
    ctx.fill();

    // label
    const mid = (a0+a1)/2;
    ctx.save();
    ctx.translate(cx,cy);
    ctx.rotate(mid);
    ctx.textAlign="right";
    ctx.fillStyle="rgba(232,238,252,.92)";
    ctx.font="900 14px system-ui";
    ctx.fillText(String(WHEEL.options[i]), r-14, 6);
    ctx.restore();
  }

  // pointer at TOP (fixed)
  ctx.beginPath();
  ctx.moveTo(cx, 10);
  ctx.lineTo(cx-12, 34);
  ctx.lineTo(cx+12, 34);
  ctx.closePath();
  ctx.fillStyle="rgba(255,204,102,.95)";
  ctx.fill();
}

// Pointer angle is -90deg (top). We convert that to which slice is under it.
function pickFromWheelTopPointer(){
  const n = Math.max(1, WHEEL.options.length);
  const slice = (Math.PI*2)/n;

  // pointer points at -PI/2 (top)
  const pointerAngle = -Math.PI/2;

  // Find where pointer lands in wheel space.
  // We want the index i where angle interval [angle+i*slice, angle+(i+1)*slice) contains pointerAngle.
  let rel = pointerAngle - WHEEL.angle;
  rel = ((rel % (Math.PI*2)) + (Math.PI*2)) % (Math.PI*2); // normalize 0..2pi
  const idx = Math.floor(rel / slice);
  return WHEEL.options[idx];
}

async function spinCurrentWheel(){
  const c = getActiveChar?.() || ensureActiveChar?.();
  if(!c) return;

  // no spinning after build complete / dead
  if(c.buildComplete || c.alive === false){
    Sound.warn();
    if(typeof toast==="function") toast("This character canâ€™t spin anymore.");
    return;
  }

  if(WHEEL.spinning) return;
  if(!WHEEL.options || !WHEEL.options.length){
    Sound.warn();
    if(typeof toast==="function") toast("Wheel has no options.");
    return;
  }

  WHEEL.spinning = true;
  Sound.spin();

  let v = 0.34 + Math.random()*0.36;
  const friction = 0.985 - Math.random()*0.006;
  const minTicks = 60 + Math.floor(Math.random()*40);
  let ticks=0;

  function step(){
    ticks++;
    WHEEL.angle += v;
    v *= friction;
    drawWheel2();

    if(ticks > minTicks && v < 0.01){
      WHEEL.spinning = false;
      const result = pickFromWheelTopPointer();
      applySpinResult(WHEEL.key, result);
      return;
    }
    requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
}

/* =========================================================
   SECTION 4/6 â€” Phase system (your exact order + conditionals)
========================================================= */
const PHASE_ORDER = [
  "race",
  "raceSpecial",   // conditional (God/Demon/Alien->Kaiju, Alien->Kaiju No 8)
  "height",        // based on race (or biggest race for Hybrid)
  "strength",
  "durability",
  "speed",
  "iq",
  "fight",
  "power",
  "powerSpecial",  // conditional (Super saiyen forms)
  "weapon",
  "trainer",
  "powerMastery",
  "weaponMastery",
  "complete"
];

function getCurrentPhase(c){
  return c.phase || "race";
}
function setPhase(c, phase){
  c.phase = phase;
  const pill = document.getElementById("phaseTag");
  if(pill) pill.textContent = "Phase: " + phase;
}

function wheelForPhase(c, phase){
  // If Hybrid and collecting extra races (Part 6), keep spinning race until done:
  if(c.race === "Hybrid" && c._hybridPending > 0){
    return { key:"race", title:"Race", hint:`Hybrid: spin ${c._hybridPending} more race(s)`, options:[...RACE_LIST] };
  }

  if(phase === "race"){
    return { key:"race", title:"Race", hint:"Spin for Race", options:[...RACE_LIST] };
  }

  if(phase === "raceSpecial"){
    if(c.race === "God"){
      return { key:"raceSpecial", title:"God Tiers", hint:"Spin for God Tier", options:[...GOD_TIERS] };
    }
    if(c.race === "Demon"){
      return { key:"raceSpecial", title:"Demon Ranks", hint:"Spin for Demon Rank", options:[...DEMON_RANKS] };
    }
    if(c.race === "Alien"){
      return { key:"raceSpecial", title:"Kaiju", hint:"Spin for Kaiju", options:[...KAIJU_LIST] };
    }
    // no special wheel needed
    return null;
  }

  if(phase === "height"){
    // choose height wheel by race (hybrid = largest)
    let key = RACE_TO_HEIGHT[c.race] || "medium";
    if(c.race === "Hybrid"){
      // largest among the two hybrid races
      const a = c.hybridRaces?.[0];
      const b = c.hybridRaces?.[1];
      const sa = RACE_SIZE[a] || 0;
      const sb = RACE_SIZE[b] || 0;
      const biggest = (sa >= sb) ? a : b;
      key = RACE_TO_HEIGHT[biggest] || "medium";
    }
    return { key:"height", title:"Height", hint:"Spin for Height", options:[...(HEIGHT_WHEELS[key] || HEIGHT_WHEELS.medium)] };
  }

  if(phase === "strength")   return { key:"strength",   title:"Strength",   hint:"Spin for Strength",   options:[...STRENGTH_WORDS] };
  if(phase === "durability") return { key:"durability", title:"Durability", hint:"Spin for Durability", options:[...DUR_WORDS] };
  if(phase === "speed")      return { key:"speed",      title:"Speed",      hint:"Spin for Speed",      options:[...SPEED_WORDS] };
  if(phase === "iq")         return { key:"iq",         title:"IQ",         hint:"Spin for IQ",         options:[...IQ_WORDS] };
  if(phase === "fight")      return { key:"fight",      title:"Fight",      hint:"Spin for Fight",      options:[...FIGHT_WORDS] };

  if(phase === "power")      return { key:"power",      title:"Power",      hint:"Spin for Power",      options:[...POWER_LIST] };

  if(phase === "powerSpecial"){
    if((c.powers||[]).includes("Super saiyen")){
      return { key:"powerSpecial", title:"Super Saiyan", hint:"Spin for Saiyan Form", options:[...SUPER_SAIYAN_FORMS] };
    }
    return null;
  }

  if(phase === "weapon")     return { key:"weapon",     title:"Weapon",     hint:"Spin for Weapon",     options:[...WEAPON_LIST] };
  if(phase === "trainer")    return { key:"trainer",    title:"Trainer",    hint:"Spin for Trainer",    options:[...TRAINER_LIST] };

  if(phase === "powerMastery")  return { key:"powerMastery",  title:"Power Mastery",  hint:"Spin for Power Mastery",  options:[...POWER_MASTERY_LIST] };
  if(phase === "weaponMastery") return { key:"weaponMastery", title:"Weapon Mastery", hint:"Spin for Weapon Mastery", options:[...WEAPON_MASTERY_LIST] };

  if(phase === "complete") return null;
  return null;
}

function advancePhaseIfNeeded(c){
  // if hybrid pending, do not advance away from race
  if(c.race === "Hybrid" && c._hybridPending > 0){
    setPhase(c, "race");
    const wf = wheelForPhase(c, "race");
    setWheel(wf.key, wf.title, wf.hint, wf.options);
    return;
  }

  // walk PHASE_ORDER until we find a phase that needs a wheel
  let idx = PHASE_ORDER.indexOf(getCurrentPhase(c));
  if(idx < 0) idx = 0;

  // If current phase is complete, nothing
  if(PHASE_ORDER[idx] === "complete"){
    return;
  }

  // move forward until wheel exists
  for(let j=idx;j<PHASE_ORDER.length;j++){
    const phase = PHASE_ORDER[j];

    // if a conditional wheel is not needed, skip it
    const wf = wheelForPhase(c, phase);
    if(wf){
      setPhase(c, phase);
      setWheel(wf.key, wf.title, wf.hint, wf.options);
      return;
    }
  }

  // if none found, complete
  setPhase(c, "complete");
  c.buildComplete = true;
  Sound.win();
  if(typeof toast==="function") toast("Build complete!");
  saveNow();
  if(typeof refreshUI==="function") refreshUI();
}

/* =========================================================
   SECTION 5/6 â€” Apply wheel results + log + auto-advance
========================================================= */
function logBuildSafe(msg){
  if(typeof logBuild === "function") logBuild(msg);
}

function applySpinResult(key, result){
  const c = getActiveChar?.() || ensureActiveChar?.();
  if(!c) return;

  // If Hybrid extra spins are active, treat race spins specially:
  if(key === "race"){
    c.race = result;
    logBuildSafe(`Race â†’ ${result}`);

    // Hybrid handling (from Part 6)
    if(typeof onRaceResultApplied === "function") onRaceResultApplied(c, result);

    saveNow();
    if(typeof refreshUI==="function") refreshUI();

    // If hybrid pending, keep phase at race
    if(c.race === "Hybrid" && c._hybridPending > 0){
      advancePhaseIfNeeded(c);
      return;
    }

    // after race is fully determined, auto-advance
    advancePhaseIfNeeded(c);
    return;
  }

  if(key === "raceSpecial"){
    c.raceDetail = result;
    logBuildSafe(`${document.getElementById("wheelTitle")?.textContent || "Race Special"} â†’ ${result}`);

    // Alien -> Kaiju No 8 wheel rule:
    if(c.race === "Alien" && result === "Kaiju No 8"){
      // Immediately spin/choose Kaiju No 8 tier next by forcing a special â€œsubwheelâ€
      // We do it by setting a temporary flag and reusing raceSpecial one more time.
      c._needsKaijuNo8 = true;
    } else {
      c._needsKaijuNo8 = false;
    }

    saveNow();
    if(typeof refreshUI==="function") refreshUI();

    // If Kaiju No 8 selected, immediately run the Kaiju No 8 wheel before advancing.
    if(c._needsKaijuNo8){
      c._needsKaijuNo8 = false;
      setPhase(c, "raceSpecial");
      setWheel("raceSpecial2", "Kaiju No 8", "Spin for Kaiju No 8 Tier", [...KAIJU_NO8_LIST]);
      return;
    }

    advancePhaseIfNeeded(c);
    return;
  }

  if(key === "raceSpecial2"){
    c.raceDetail2 = result; // Kaiju No 8 tier
    logBuildSafe(`Kaiju No 8 Tier â†’ ${result}`);
    saveNow();
    if(typeof refreshUI==="function") refreshUI();
    advancePhaseIfNeeded(c);
    return;
  }

  if(key === "height"){
    c.height = result;
    logBuildSafe(`Height â†’ ${result}`);
    saveNow(); if(typeof refreshUI==="function") refreshUI();
    advancePhaseIfNeeded(c); return;
  }

  if(key === "strength"){ c.strengthW = result; logBuildSafe(`Strength â†’ ${result}`); saveNow(); if(typeof refreshUI==="function") refreshUI(); advancePhaseIfNeeded(c); return; }
  if(key === "durability"){ c.durabilityW = result; logBuildSafe(`Durability â†’ ${result}`); saveNow(); if(typeof refreshUI==="function") refreshUI(); advancePhaseIfNeeded(c); return; }
  if(key === "speed"){ c.speedW = result; logBuildSafe(`Speed â†’ ${result}`); saveNow(); if(typeof refreshUI==="function") refreshUI(); advancePhaseIfNeeded(c); return; }
  if(key === "iq"){ c.iqW = result; logBuildSafe(`IQ â†’ ${result}`); saveNow(); if(typeof refreshUI==="function") refreshUI(); advancePhaseIfNeeded(c); return; }
  if(key === "fight"){ c.fightW = result; logBuildSafe(`Fight â†’ ${result}`); saveNow(); if(typeof refreshUI==="function") refreshUI(); advancePhaseIfNeeded(c); return; }

  if(key === "power"){
    c.powers ||= [];
    if(result !== "No Power" && !c.powers.includes(result)) c.powers.push(result);
    logBuildSafe(`Power â†’ ${result}`);
    saveNow(); if(typeof refreshUI==="function") refreshUI();
    advancePhaseIfNeeded(c); return;
  }

  if(key === "powerSpecial"){
    c.powerDetail = result; // Super Saiyan form
    logBuildSafe(`Super Saiyan Form â†’ ${result}`);
    saveNow(); if(typeof refreshUI==="function") refreshUI();
    advancePhaseIfNeeded(c); return;
  }

  if(key === "weapon"){
    c.weapons ||= [];
    if(result !== "No Weapon" && !c.weapons.includes(result)) c.weapons.push(result);
    logBuildSafe(`Weapon â†’ ${result}`);
    saveNow(); if(typeof refreshUI==="function") refreshUI();
    advancePhaseIfNeeded(c); return;
  }

  if(key === "trainer"){
    c.trainer = result;
    logBuildSafe(`Trainer â†’ ${result}`);
    saveNow(); if(typeof refreshUI==="function") refreshUI();
    advancePhaseIfNeeded(c); return;
  }

  if(key === "powerMastery"){
    c.powerMastery = result;
    logBuildSafe(`Power Mastery â†’ ${result}`);
    saveNow(); if(typeof refreshUI==="function") refreshUI();
    advancePhaseIfNeeded(c); return;
  }

  if(key === "weaponMastery"){
    c.weaponMastery = result;
    logBuildSafe(`Weapon Mastery â†’ ${result}`);
    saveNow(); if(typeof refreshUI==="function") refreshUI();
    advancePhaseIfNeeded(c); return;
  }

  // fallback
  logBuildSafe(`${key} â†’ ${result}`);
  saveNow();
  if(typeof refreshUI==="function") refreshUI();
  advancePhaseIfNeeded(c);
}

/* =========================================================
   SECTION 6/6 â€” Wire buttons: Spin / New Character
========================================================= */
// Replace spin handler with our engine (prevents â€œundefined wheelâ€ issue)
document.getElementById("spinBtn")?.addEventListener("click", ()=>{
  Sound.click();
  spinCurrentWheel();
});

// â€œNew Buildâ€ now creates a NEW character (does not overwrite current)
document.getElementById("newBuildBtn")?.addEventListener("click", ()=>{
  Sound.click();
  const id = "c_" + Math.random().toString(16).slice(2) + Date.now().toString(16);
  const c = {
    id,
    alive:true,
    buildComplete:false,
    name:"",
    phase:"race",
    race:null,
    raceDetail:null,
    raceDetail2:null,
    height:null,
    strengthW:null,
    durabilityW:null,
    speedW:null,
    iqW:null,
    fightW:null,
    powers:[],
    powerDetail:null,
    weapons:[],
    trainer:"No Trainer",
    powerMastery:"None",
    weaponMastery:"Novice",
    deaths:{pve:0,pvp:0}
  };
  state.roster.push(c);
  state.activeId = id;

  // reset wheel to Race for this new character
  document.getElementById("buildLog").innerHTML = "";
  if(typeof logBuild==="function") logBuild("New character created.");
  setPhase(c, "race");
  setWheel("race","Race","Spin for Race",[...RACE_LIST]);
  drawWheel2();
  saveNow();
  if(typeof refreshUI==="function") refreshUI();
});

// Remove finalize usage (your new rules: wheels decide the character)
const fin = document.getElementById("finalizeBtn");
if(fin){
  fin.style.display = "none";
}

// Start with correct wheel for active character
(function initWheelEngine(){
  const c = getActiveChar?.() || ensureActiveChar?.();
  if(!c) return;

  // if already complete, lock wheel
  if(c.buildComplete){
    setPhase(c, "complete");
    setWheel("complete","Build Complete","No more spinning for this character.",["Build Complete"]);
  }else{
    // ensure phase exists
    c.phase ||= "race";
    advancePhaseIfNeeded(c);
  }

  drawWheel2();
  saveNow();
  if(typeof refreshUI==="function") refreshUI();
})();
</script>
<!-- =========================
PART 8 / 12 â€” Save + Sound + Name Safety + Tabs + Stats Rendering
========================= -->
<script>
/* =========================================================
   1/6 â€” SAVE / LOAD (hardening so refresh doesn't reset)
========================================================= */
const STORAGE_KEY_V1 = "wheel_forge_v1_state";

window.saveNow = function(){
  try{ localStorage.setItem(STORAGE_KEY_V1, JSON.stringify(state)); }catch(e){}
};
window.loadNow = function(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY_V1);
    if(!raw) return;
    const parsed = JSON.parse(raw);
    if(parsed && typeof parsed === "object"){
      window.state = Object.assign(window.state || {}, parsed);
    }
  }catch(e){}
};

// Load once (wonâ€™t overwrite if already loaded earlier)
try{ loadNow(); }catch(e){}

/* =========================================================
   2/6 â€” SOUND ENGINE (simple but reliable)
========================================================= */
(function(){
  const AC = window.AudioContext || window.webkitAudioContext;
  let ctx = null;

  function getCtx(){
    if(!ctx){
      try{ ctx = new AC(); }catch(e){ ctx = null; }
    }
    return ctx;
  }

  function beep(freq, dur=0.08, type="sine", gain=0.06){
    if(!(state.settings)) state.settings = { sound:true, vol:0.7 };
    if(state.settings.sound === false) return;

    const c = getCtx();
    if(!c) return;

    // iOS needs resume on gesture; call resume safely
    c.resume?.().catch(()=>{});

    const o = c.createOscillator();
    const g = c.createGain();
    o.type = type;
    o.frequency.value = freq;

    const vol = (state.settings.vol ?? 0.7);
    g.gain.value = gain * vol;

    o.connect(g);
    g.connect(c.destination);
    o.start();
    o.stop(c.currentTime + dur);
  }

  window.Sound = {
    click(){ beep(520, 0.05, "square", 0.045); },
    spin(){  beep(220, 0.08, "sawtooth", 0.035); },
    win(){   beep(660, 0.08, "triangle", 0.07); setTimeout(()=>beep(880,0.09,"triangle",0.06), 80); },
    warn(){  beep(140, 0.10, "square", 0.05); },
    block(){ beep(180, 0.08, "square", 0.06); },
  };

  // Volume / mute button
  const vb = document.getElementById("volBtn");
  if(vb){
    vb.addEventListener("click", ()=>{
      state.settings ||= { sound:true, vol:0.7 };
      state.settings.sound = !state.settings.sound;
      vb.textContent = state.settings.sound ? "ðŸ”Š" : "ðŸ”‡";
      saveNow();
      if(state.settings.sound) Sound.click();
    });
    state.settings ||= { sound:true, vol:0.7 };
    vb.textContent = state.settings.sound ? "ðŸ”Š" : "ðŸ”‡";
  }
})();

/* =========================================================
   3/6 â€” NAME SAFETY (max 12, no rename, profanity blocker)
========================================================= */
const NAME_MAX = 12;

// IMPORTANT: Iâ€™m not going to paste slurs.
// This is a small â€œobvious profanityâ€ filter + pattern checks.
// You can expand the banned list yourself anytime.
const BANNED_SUBSTRINGS = [
  "fuck","shit","bitch","asshole","cunt","dick","pussy","nigger","faggot"
];

function normalizeName(s){
  return String(s ?? "")
    .trim()
    .replace(/\s+/g, " ")      // collapse spaces
    .replace(/[^\w \-]/g, ""); // remove symbols (keeps letters/numbers/_ space -)
}

function isNameAllowed(name){
  const n = String(name).toLowerCase();
  if(!n) return false;
  if(n.length > NAME_MAX) return false;

  // block obvious profanity substrings
  for(const bad of BANNED_SUBSTRINGS){
    if(n.includes(bad)) return false;
  }

  // block repetitive spam
  if(/(.)\1\1\1/.test(n)) return false;

  return true;
}

async function ensureNameOnce(){
  const c = getActiveChar?.();
  if(!c) return;

  if(c.nameLocked) return;         // already locked
  if(c.name && c.name.length) {
    c.nameLocked = true;
    saveNow();
    return;
  }

  // Ask for name once, must be valid
  let tries = 0;
  while(tries < 4){
    tries++;
    const raw = prompt(`Name your character (max ${NAME_MAX} chars). No renaming later.`);
    if(raw === null) {
      // user cancelled: default safe name
      c.name = "Unnamed";
      c.nameLocked = true;
      saveNow();
      return;
    }
    const cleaned = normalizeName(raw).slice(0, NAME_MAX);
    if(isNameAllowed(cleaned)){
      c.name = cleaned;
      c.nameLocked = true;
      saveNow();
      Sound.click();
      if(typeof toast==="function") toast(`Name set: ${c.name}`);
      return;
    }
    Sound.warn();
    if(typeof toast==="function") toast("Name not allowed. Try again.");
  }

  c.name = "Unnamed";
  c.nameLocked = true;
  saveNow();
}

// Run name prompt when a new character is created (hook into your Part 7 button)
document.getElementById("newBuildBtn")?.addEventListener("click", ()=>{
  setTimeout(()=>ensureNameOnce(), 50);
});

// Also ensure current character gets a name if missing
setTimeout(()=>ensureNameOnce(), 50);

/* =========================================================
   4/6 â€” TAB GATING (Stats/PvE locked until buildComplete)
========================================================= */
function setTabEnabled(tabKey, enabled){
  const el = document.querySelector(`.tab[data-tab="${tabKey}"]`);
  if(!el) return;
  el.style.opacity = enabled ? "1" : "0.45";
  el.style.pointerEvents = "auto";
  el.dataset.locked = enabled ? "0" : "1";
}
function gateTabs(){
  const c = getActiveChar?.();
  const ok = !!(c && c.buildComplete && c.alive !== false);

  setTabEnabled("stats", ok);
  setTabEnabled("pve", ok);
  setTabEnabled("pvp", false); // you said real PvP later
}
document.querySelectorAll(".tab[data-tab]").forEach(btn=>{
  btn.addEventListener("click", (e)=>{
    const key = btn.dataset.tab;
    const locked = btn.dataset.locked === "1";
    if(locked){
      e.preventDefault();
      Sound.warn();
      if(typeof toast==="function") toast("Locked until Build Complete.");
      return;
    }
    Sound.click();
  });
});

/* =========================================================
   5/6 â€” FINAL STATS (additive numbers under the hood + labels)
========================================================= */
function statWordToNumber(kind, word){
  const map = {
    strength: STRENGTH_WORDS,
    durability: DUR_WORDS,
    speed: SPEED_WORDS,
    iq: IQ_WORDS,
    fight: FIGHT_WORDS
  };
  const arr = map[kind] || [];
  const idx = Math.max(0, arr.indexOf(word));
  // Use index as base number, but allow growth later (effects can push beyond)
  return idx;
}

function labelForStat(kind, num){
  const map = {
    strength: STRENGTH_WORDS,
    durability: DUR_WORDS,
    speed: SPEED_WORDS,
    iq: IQ_WORDS,
    fight: FIGHT_WORDS
  };
  const arr = map[kind] || [];
  if(num < arr.length) return arr[num];
  return "???";
}

// Simple additive mods (weâ€™ll expand later)
function addMods(mods, add){
  for(const k in add) mods[k] = (mods[k] || 0) + add[k];
}

function powerMods(p){
  switch(p){
    case "Immortal": return { durability:4 };
    case "Regeneration": return { durability:3 };
    case "Adaptation": return { durability:2, fight:1 };
    case "Time Manipulation": return { speed:3, iq:1 };
    case "Gravity Manipulation": return { strength:2, fight:1 };
    case "Telekinesis": return { iq:2, fight:1 };
    case "Teleportation": return { speed:2 };
    case "Heavenly Restriction": return { strength:3, speed:2, durability:2, fight:2, iq:-1 };
    case "Rinnegan": return { iq:2, fight:2 };
    case "Super saiyen": return { strength:2, speed:1, durability:1, fight:1 }; // base; form adds more
    default: return {};
  }
}
function ssjFormMods(form){
  switch(form){
    case "Super saiyen": return { strength:2, speed:1, durability:1, fight:1 };
    case "Super saiyen 4": return { strength:4, speed:2, durability:2, fight:2 };
    case "Super saiyen god": return { strength:5, speed:3, durability:2, fight:2, iq:1 };
    case "Super saiyen blue": return { strength:6, speed:4, durability:3, fight:3, iq:1 };
    case "Ultra instinct": return { strength:7, speed:6, durability:3, fight:5, iq:2 };
    default: return {};
  }
}
function weaponMods(w){
  switch(w){
    case "Sword": return { fight:2 };
    case "Scythe": return { fight:2, strength:1 };
    case "Axe": return { strength:2 };
    case "Hammer": return { strength:2, durability:1 };
    case "Spear": return { fight:1, speed:1 };
    case "Infinity Gauntlet": return { strength:3, durability:3, iq:2, fight:2 };
    case "Green Lantern Ring": return { iq:3, durability:2 };
    default: return {};
  }
}
function masteryMods(pm){
  switch(pm){
    case "Mastered": return { fight:1, durability:1 };
    case "Cosmic": return { strength:2, speed:2, iq:1 };
    case "Universal": return { strength:3, speed:3, durability:3, fight:2, iq:2 };
    case "Omnipotent": return { strength:5, speed:5, durability:5, fight:4, iq:4 };
    default: return {};
  }
}
function weaponMasteryMods(wm){
  switch(wm){
    case "Skilled": return { fight:1 };
    case "Expert": return { fight:2, speed:1 };
    case "Master": return { fight:3, speed:1, iq:1 };
    case "Grandmaster": return { fight:4, speed:2, iq:1 };
    default: return {};
  }
}
function trainerMods(t){
  switch(t){
    case "Master Roshi": return { fight:2, iq:1 };
    case "Jiraiya": return { fight:2, iq:1 };
    case "Hisoka": return { fight:2, iq:1 };
    case "Korro": return { durability:1, fight:1 };
    case "Yuujirou": return { strength:3, fight:2 };
    default: return {};
  }
}

// NOTE: race special wheels are â€œflavorâ€ here; weâ€™ll hook them into bonuses later.
function computeFinalStatsForChar(c){
  const base = {
    strength: statWordToNumber("strength", c.strengthW || "Average"),
    durability: statWordToNumber("durability", c.durabilityW || "Average"),
    speed: statWordToNumber("speed", c.speedW || "Average"),
    iq: statWordToNumber("iq", c.iqW || "Average"),
    fight: statWordToNumber("fight", c.fightW || "Average"),
  };

  const mods = { strength:0, durability:0, speed:0, iq:0, fight:0 };

  (c.powers||[]).forEach(p=> addMods(mods, powerMods(p)));
  if((c.powers||[]).includes("Super saiyen")){
    addMods(mods, ssjFormMods(c.powerDetail));
  }

  (c.weapons||[]).forEach(w=> addMods(mods, weaponMods(w)));
  addMods(mods, trainerMods(c.trainer));
  addMods(mods, masteryMods(c.powerMastery));
  addMods(mods, weaponMasteryMods(c.weaponMastery));

  // permanent bonuses (soul/adaptation stacks from earlier parts if present)
  if(state.progress?.soulBonus) addMods(mods, state.progress.soulBonus);
  if(state.progress?.adaptationStacks && (c.powers||[]).includes("Adaptation")){
    addMods(mods, { durability: state.progress.adaptationStacks });
  }

  const out = {
    strength: base.strength + mods.strength,
    durability: base.durability + mods.durability,
    speed: base.speed + mods.speed,
    iq: base.iq + mods.iq,
    fight: base.fight + mods.fight
  };

  out.labels = {
    strength: labelForStat("strength", out.strength),
    durability: labelForStat("durability", out.durability),
    speed: labelForStat("speed", out.speed),
    iq: labelForStat("iq", out.iq),
    fight: labelForStat("fight", out.fight)
  };

  return out;
}

/* =========================================================
   6/6 â€” RENDER: Build panel + Stats tab (Raw + Final + Inventory)
========================================================= */
function renderBuildPanel(){
  const c = getActiveChar?.();
  if(!c) return;

  // namedTag
  const nt = document.getElementById("namedTag");
  if(nt){
    const dead = (c.alive === false);
    nt.textContent = dead ? `DEAD: ${c.name || "Unnamed"}` : (c.name ? c.name : "Unnamed");
  }

  // build stats list
  const host = document.getElementById("buildStats");
  if(host){
    const rows = [];
    rows.push(["Race", c.race || "â€”"]);
    if(c.raceDetail) rows.push(["Race Wheel", c.raceDetail]);
    if(c.raceDetail2) rows.push(["Race Wheel 2", c.raceDetail2]);
    rows.push(["Height", c.height || "â€”"]);
    rows.push(["Strength", c.strengthW || "â€”"]);
    rows.push(["Durability", c.durabilityW || "â€”"]);
    rows.push(["Speed", c.speedW || "â€”"]);
    rows.push(["IQ", c.iqW || "â€”"]);
    rows.push(["Fight", c.fightW || "â€”"]);
    rows.push(["Power(s)", (c.powers||[]).length ? c.powers.join(", ") : "â€”"]);
    if(c.powerDetail) rows.push(["Power Wheel", c.powerDetail]);
    rows.push(["Weapon(s)", (c.weapons||[]).length ? c.weapons.join(", ") : "â€”"]);
    rows.push(["Trainer", c.trainer || "â€”"]);
    rows.push(["Power Mastery", c.powerMastery || "â€”"]);
    rows.push(["Weapon Mastery", c.weaponMastery || "â€”"]);

    host.innerHTML = "";
    rows.forEach(([k,v])=>{
      const div = document.createElement("div");
      div.className="statLine";
      div.innerHTML = `<div class="statKey">${escapeHtml(k)}</div><div class="statVal">${escapeHtml(v)}</div>`;
      host.appendChild(div);
    });
  }

  // badges
  const b = document.getElementById("buildBadges");
  if(b){
    b.innerHTML = "";
    const mk = (icon, text)=>{
      const d=document.createElement("div");
      d.className="badge";
      d.innerHTML=`<span class="icon">${icon}</span><span>${escapeHtml(text)}</span>`;
      return d;
    };
    b.appendChild(mk(c.buildComplete ? "âœ…" : "ðŸ§ª", c.buildComplete ? "Build Complete" : "Building"));
    b.appendChild(mk("ðŸ§", `Alive: ${c.alive===false ? "No" : "Yes"}`));
  }

  gateTabs();
}

function renderStatsTab(){
  const c = getActiveChar?.();
  if(!c) return;

  const rawHost = document.getElementById("statsList");
  const finHost = document.getElementById("finalStatsList");
  if(!rawHost || !finHost) return;

  // Raw build (what you spun)
  const raw = [];
  raw.push(["Race", c.race || "â€”"]);
  if(c.raceDetail) raw.push(["Race Wheel", c.raceDetail]);
  if(c.raceDetail2) raw.push(["Race Wheel 2", c.raceDetail2]);
  raw.push(["Height", c.height || "â€”"]);
  raw.push(["Strength", c.strengthW || "â€”"]);
  raw.push(["Durability", c.durabilityW || "â€”"]);
  raw.push(["Speed", c.speedW || "â€”"]);
  raw.push(["IQ", c.iqW || "â€”"]);
  raw.push(["Fight", c.fightW || "â€”"]);
  raw.push(["Powers Owned", (c.powers||[]).length ? c.powers.join(", ") : "â€”"]);
  if(c.powerDetail) raw.push(["Power Wheel", c.powerDetail]);
  raw.push(["Weapons Owned", (c.weapons||[]).length ? c.weapons.join(", ") : "â€”"]);
  raw.push(["Trainer", c.trainer || "â€”"]);
  raw.push(["Power Mastery", c.powerMastery || "â€”"]);
  raw.push(["Weapon Mastery", c.weaponMastery || "â€”"]);

  rawHost.innerHTML = "";
  raw.forEach(([k,v])=>{
    const div = document.createElement("div");
    div.className="statLine";
    div.innerHTML = `<div class="statKey">${escapeHtml(k)}</div><div class="statVal">${escapeHtml(v)}</div>`;
    rawHost.appendChild(div);
  });

  // Final (additive)
  const fin = computeFinalStatsForChar(c);
  const finalRows = [
    ["Strength", `${fin.labels.strength} (${fin.strength})`],
    ["Durability", `${fin.labels.durability} (${fin.durability})`],
    ["Speed", `${fin.labels.speed} (${fin.speed})`],
    ["IQ", `${fin.labels.iq} (${fin.iq})`],
    ["Fight", `${fin.labels.fight} (${fin.fight})`]
  ];

  finHost.innerHTML = "";
  finalRows.forEach(([k,v])=>{
    const div = document.createElement("div");
    div.className="statLine";
    div.innerHTML = `<div class="statKey">${escapeHtml(k)}</div><div class="statVal">${escapeHtml(v)}</div>`;
    finHost.appendChild(div);
  });
}

// Extend refreshUI safely (wonâ€™t break if earlier parts defined it)
const __oldRefresh = window.refreshUI;
window.refreshUI = function(){
  try{ __oldRefresh?.(); }catch(e){}
  renderBuildPanel();
  renderStatsTab();
  saveNow();
};

// Initial render
refreshUI();
</script>
<!-- =========================
PART 9 / 12 â€” PvE + Death + Permanent Characters
========================= -->
<script>
/* =========================================================
   1/7 â€” CHARACTER SLOTS (NO OVERWRITES)
========================================================= */
state.characters ||= [];
state.activeIndex ??= 0;

function getActiveChar(){
  return state.characters[state.activeIndex];
}

function createNewCharacter(){
  const c = {
    id: crypto.randomUUID(),
    alive: true,
    deaths: 0,
    pvpStrikes: 0,
    buildComplete: false,

    name: "",
    nameLocked:false,

    race:null,
    raceDetail:null,
    raceDetail2:null,
    height:null,

    strengthW:null,
    durabilityW:null,
    speedW:null,
    iqW:null,
    fightW:null,

    powers:[],
    powerDetail:null,

    weapons:[],
    trainer:null,

    powerMastery:null,
    weaponMastery:null,
  };

  state.characters.push(c);
  state.activeIndex = state.characters.length - 1;
  saveNow();
  refreshUI();
}

// Override old New Build behavior
document.getElementById("newBuildBtn")?.addEventListener("click", ()=>{
  Sound.click();
  createNewCharacter();
  setTimeout(()=>ensureNameOnce(), 40);
});

/* =========================================================
   2/7 â€” BUILD LOCK (NO REDO AFTER COMPLETE)
========================================================= */
function isBuildLocked(){
  const c = getActiveChar();
  return !!(c && c.buildComplete);
}

// Disable spin button once complete
(function(){
  const spin = document.getElementById("spinBtn");
  if(!spin) return;
  const orig = spin.onclick;
  spin.addEventListener("click",(e)=>{
    const c = getActiveChar();
    if(!c || c.alive === false) return;
    if(c.buildComplete){
      Sound.block();
      toast("Build is locked. No re-spins.");
      e.stopImmediatePropagation();
      return;
    }
  }, true);
})();

/* =========================================================
   3/7 â€” FIX: UNDEFINED WHEEL SPIN
========================================================= */
function safeSpinResult(arr){
  if(!Array.isArray(arr) || arr.length === 0){
    console.warn("Wheel array empty");
    return null;
  }
  return arr[Math.floor(Math.random()*arr.length)];
}

/* =========================================================
   4/7 â€” FINALIZE BUILD (AUTO)
========================================================= */
function tryFinalizeBuild(){
  const c = getActiveChar();
  if(!c) return;

  const required = [
    c.race, c.height,
    c.strengthW, c.durabilityW,
    c.speedW, c.iqW, c.fightW,
    c.trainer, c.powerMastery, c.weaponMastery
  ];

  if(required.every(v=>v)){
    c.buildComplete = true;
    Sound.win();
    toast("Build Complete. PvE Unlocked.");
    saveNow();
    refreshUI();
  }
}

/* =========================================================
   5/7 â€” PVE COMBAT ENGINE (REAL)
========================================================= */
function computeHPFromStats(fin){
  return 50 + fin.durability * 8 + fin.fight * 4;
}
function computeDamage(att, def){
  const base = att.strength * 2 + att.fight * 3;
  const mit = def.durability * 1.5;
  return Math.max(6, Math.floor((base - mit) * (0.85 + Math.random()*0.3)));
}
function hasDeathProtection(c){
  return c.powers.includes("Immortal") || c.powers.includes("Regeneration");
}

async function startPvE(){
  const c = getActiveChar();
  if(!c || !c.buildComplete || c.alive===false){
    Sound.warn();
    toast("PvE locked.");
    return;
  }

  const pStats = computeFinalStatsForChar(c);

  const enemy = {
    strength: pStats.strength + Math.floor(Math.random()*3),
    durability: pStats.durability,
    speed: pStats.speed,
    iq: pStats.iq,
    fight: pStats.fight,
  };

  let pHP = computeHPFromStats(pStats);
  let eHP = computeHPFromStats(enemy);

  toast("PvE Battle Started");
  Sound.spin();

  while(pHP>0 && eHP>0){
    await new Promise(r=>setTimeout(r,90));
    eHP -= computeDamage(pStats, enemy);
    if(eHP<=0) break;
    pHP -= computeDamage(enemy, pStats);
  }

  if(pHP>0){
    Sound.win();
    toast("Victory!");
    saveNow();
    return;
  }

  // Player lost
  if(hasDeathProtection(c)){
    Sound.warn();
    toast("You survived due to regeneration/immortality.");
    return;
  }

  // PERMA DEATH (PvE = 1 strike)
  c.alive = false;
  c.deaths += 1;
  Sound.block();
  toast(`${c.name || "Character"} has died.`);
  saveNow();
  refreshUI();
}

/* =========================================================
   6/7 â€” HOOK PvE BUTTON
========================================================= */
document.getElementById("pveStartBtn")?.addEventListener("click", startPvE);

/* =========================================================
   7/7 â€” IMAGE PLACEHOLDERS (NO BLANK CHARACTER)
========================================================= */
function renderCharacterImage(){
  const frame = document.getElementById("charFrame");
  if(!frame) return;

  const c = getActiveChar();
  if(!c) return;

  frame.style.background =
    c.alive===false
      ? "linear-gradient(135deg, #400, #100)"
      : "linear-gradient(135deg, #1a2235, #0b0f17)";
}

// extend refresh
const _oldRefresh9 = refreshUI;
refreshUI = function(){
  _oldRefresh9?.();
  renderCharacterImage();
};
refreshUI();
</script>
<!-- =========================
PART 10 / 12 â€” Full Wheel Sequence + Race Wheels + Height + Hybrid
========================= -->
<script>
/* =========================================================
   1/8 â€” SAFE SAVE ALIAS + DEV-ONLY RESET
========================================================= */
window.saveNow ||= (window.saveState || function(){});
(function devOnlyReset(){
  const btn = document.getElementById("resetBtn");
  if(!btn) return;
  // dev-only: hide by default
  btn.style.display = (state?.settings?.devMode) ? "" : "none";
})();

/* =========================================================
   2/8 â€” LISTS (AUTHORITATIVE)
========================================================= */
// RACES (exact set you gave)
const RACES = [
  "Gnome","Goblin","Zombie","Skeleton","Human","Orc","Cyborg","Giant","Demi human","Golem",
  "Dragon","Vampire","Hivemind","Shinigami","Soul eater","Demon","Alien","God","Hybrid"
];

// God tiers (race-based wheel)
const GOD_TIERS = [
  "Halfling","Demigod","Lesser diety","Deity","Greater diety","Roman","Norse","Greek"
];

// Demon ranks (race-based wheel)
const DEMON_RANKS = [
  "Jelly","Knight","Earl","Marquis","Prince","Duke","King"
];

// Alien â†’ Kaiju system
const ALIEN_TYPE = ["Kaiju","Non-Kaiju"];
const KAIJU_LIST = [
  "King Kong","Rodan","Ghidorah","Destoroyah","Gezora","Cloverfield","Mothra","Kumanga","Kaiju No 8","Godzilla"
];
const KAIJU_NO8_LEVELS = ["1","2","4","6","8","9","10","11","12","13","14","15"];

// Stats words (wheel options)
const STRENGTH_WORDS = ["Weak","Average","Strong","City","Mountain","Country","Planet","Star","Galaxy","Universal","???"];
const DURABILITY_WORDS = ["Fragile","Average","Tough","Steel","City","Mountain","Country","Planet","Star","Universal","???"];
const SPEED_WORDS = ["Slow","Average","Fast","Mach","Lightning","Light","FTL","Galaxy","Universal","???"];
const IQ_WORDS = ["Low","Average","Smart","Genius","Supergenius","Cosmic","Universal","???"];
const FIGHT_WORDS = ["Clumsy","Average","Trained","Elite","Master","Legendary","Mythic","Universal","???"];

// Power / weapon / trainer / mastery
// NOTE: Kaioken / Eight Gates / Titan Transformation are POWERS (as you said).
const POWERS = [
  "No Power",
  "Adaptation","Regeneration","Immortal",
  "Gravity Manipulation","Time Manipulation","Telekinesis","Teleportation",
  "Fire","Ice Manipulation","Lightning","Weapon Creation",
  "Heavenly Restriction","Rinnegan",
  "Kaioken","Eight Gates","Titan Transformation",
  "Super saiyen"
];

const SUPER_SAIYEN_FORMS = [
  "Super saiyen","Super saiyen 4","Super saiyen god","Super saiyen blue","Ultra instinct"
];

const WEAPONS = [
  "No Weapon","Sword","Scythe","Axe","Hammer","Spear","Brass Knuckles","Blades of Chaos","Samehada",
  "Uzumaki Chains","Infinity Gauntlet","Green Lantern Ring"
];

const TRAINERS = ["No Trainer","Master Roshi","Jiraiya","Hisoka","Korro","Yuujirou"];

const POWER_MASTERY = ["None","Dormant","Awakening","Controlled","Mastered","Planetary","Cosmic","Universal","Omnipotent"];
const WEAPON_MASTERY = ["None","Novice","Skilled","Expert","Master","Legendary","Mythic","Universal","Omnipotent"];

/* =========================================================
   3/8 â€” HEIGHT WHEELS (RACE-BASED)
   (Golem + Dragon use GIANT height wheel)
========================================================= */
const HEIGHT_WHEELS = {
  small: ["2'0","2'6","3'0","3'6","4'0","4'6"],
  human: ["4'8","5'0","5'4","5'8","6'0","6'4","6'8"],
  tall: ["6'0","6'6","7'0","7'6","8'0","8'6","9'0"],
  giant: ["10'0","12'0","15'0","20'0","30'0","40'0","50'0","60'0"]
};

// size rank (for Hybrid â€œlargest race decides height wheelâ€)
const SIZE_RANK = {
  "Gnome":1,"Goblin":1,
  "Zombie":2,"Skeleton":2,"Human":2,"Orc":2,"Cyborg":2,"Demi human":2,"Vampire":2,"Shinigami":2,"Soul eater":2,"Demon":2,"Alien":2,"God":2,"Hivemind":2,
  "Giant":4,"Golem":4,"Dragon":4,
  "Hybrid":3
};

function heightWheelForRace(race){
  if(["Gnome","Goblin"].includes(race)) return HEIGHT_WHEELS.small;
  if(["Giant","Golem","Dragon"].includes(race)) return HEIGHT_WHEELS.giant;
  if(["Orc"].includes(race)) return HEIGHT_WHEELS.tall;
  return HEIGHT_WHEELS.human;
}

/* =========================================================
   4/8 â€” WHEEL ENGINE (FIXED POINTER @ TOP)
========================================================= */
const wheelCanvas = document.getElementById("wheel");
const wheelCtx = wheelCanvas?.getContext("2d");
let wheelItems = ["(loading)"];
let wheelAngle = 0;
let spinning = false;

const TAU = Math.PI * 2;

// pointer is fixed at TOP (-90Â°)
const POINTER_ANGLE = -Math.PI / 2;

function setWheel(items, title, hint){
  wheelItems = (Array.isArray(items) && items.length) ? items.slice() : ["(empty)"];
  document.getElementById("wheelTitle").textContent = title || "Wheel";
  document.getElementById("wheelHint").textContent = hint || "Spin";
  drawWheelFixed();
}

function drawWheelFixed(){
  if(!wheelCtx || !wheelCanvas) return;

  const w = wheelCanvas.width, h = wheelCanvas.height;
  const cx = w/2, cy = h/2;
  const r = Math.min(cx, cy) - 10;

  wheelCtx.clearRect(0,0,w,h);

  // ring
  wheelCtx.beginPath();
  wheelCtx.arc(cx, cy, r+5, 0, TAU);
  wheelCtx.strokeStyle = "rgba(255,255,255,.14)";
  wheelCtx.lineWidth = 10;
  wheelCtx.stroke();

  const n = wheelItems.length;
  const slice = TAU / n;

  for(let i=0;i<n;i++){
    const a0 = wheelAngle + i*slice;
    const a1 = wheelAngle + (i+1)*slice;

    wheelCtx.beginPath();
    wheelCtx.moveTo(cx,cy);
    wheelCtx.arc(cx,cy,r,a0,a1);
    wheelCtx.closePath();
    wheelCtx.fillStyle = (i%2===0) ? "rgba(122,168,255,.14)" : "rgba(255,255,255,.06)";
    wheelCtx.fill();

    const mid = (a0+a1)/2;
    wheelCtx.save();
    wheelCtx.translate(cx,cy);
    wheelCtx.rotate(mid);
    wheelCtx.textAlign="right";
    wheelCtx.fillStyle="rgba(232,238,252,.92)";
    wheelCtx.font="900 14px system-ui";
    wheelCtx.fillText(String(wheelItems[i]), r-14, 6);
    wheelCtx.restore();
  }

  // TOP pointer
  wheelCtx.save();
  wheelCtx.translate(cx, cy);
  wheelCtx.rotate(0);
  wheelCtx.restore();

  wheelCtx.beginPath();
  wheelCtx.moveTo(cx, 10);
  wheelCtx.lineTo(cx-12, 34);
  wheelCtx.lineTo(cx+12, 34);
  wheelCtx.closePath();
  wheelCtx.fillStyle="rgba(255,204,102,.95)";
  wheelCtx.fill();
}

function pickIndexAtPointer(){
  const n = wheelItems.length;
  const slice = TAU / n;

  // We want the slice under POINTER_ANGLE.
  // Convert to "pointer space":
  let a = (POINTER_ANGLE - wheelAngle) % TAU;
  if(a < 0) a += TAU;

  const idx = Math.floor(a / slice);
  return Math.max(0, Math.min(n-1, idx));
}

function spinWheelFixed(onDone){
  if(spinning) return;
  spinning = true;

  let v = 0.38 + Math.random()*0.32;
  const friction = 0.985 - Math.random()*0.006;
  const minTicks = 65 + Math.floor(Math.random()*35);
  let t = 0;

  Sound.spin();

  function step(){
    t++;
    wheelAngle += v;
    v *= friction;
    drawWheelFixed();

    if(t > minTicks && v < 0.01){
      spinning = false;
      const idx = pickIndexAtPointer();
      const result = wheelItems[idx];
      onDone?.(result, idx);
      return;
    }
    requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
}

/* =========================================================
   5/8 â€” WHEEL SEQUENCE (15 steps)
========================================================= */
function ensureCharactersInit(){
  if(!state.characters || !state.characters.length){
    createNewCharacter(); // from Part 9
  }
}
ensureCharactersInit();

function getPhase(){
  state.wheelFlow ||= {};
  state.wheelFlow.phase ||= 1;
  return state.wheelFlow.phase;
}
function setPhase(n){
  state.wheelFlow ||= {};
  state.wheelFlow.phase = n;
  saveNow();
}

function activeCharOrToast(){
  const c = getActiveChar();
  if(!c){ toast("No character."); return null; }
  if(c.alive === false){ Sound.block(); toast("Character is dead."); return null; }
  return c;
}

function logBuild(msg){
  const el = document.getElementById("buildLog");
  if(!el) return;
  const time = new Date().toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
  el.innerHTML = `<div><span class="muted">[${time}]</span> ${escapeHtml(msg)}</div>` + el.innerHTML;
}

function startFlowFromScratch(){
  setPhase(1);
  const c = getActiveChar();
  if(c){
    c.race = null; c.raceDetail = null; c.raceDetail2 = null;
    c.hybridRaces = null; c.hybridBase = null;
    c.height = null;
    c.strengthW=null; c.durabilityW=null; c.speedW=null; c.iqW=null; c.fightW=null;
    c.powers=[]; c.powerDetail=null;
    c.weapons=[]; c.trainer=null;
    c.powerMastery=null; c.weaponMastery=null;
    c.buildComplete=false;
    saveNow();
  }
}

function wheelOptionsForPhase(c, phase){
  // phase map based on your exact order
  switch(phase){
    case 1: return { title:"Race", hint:"Spin for your race", items:RACES };

    // 2: wheel based on race
    case 2:{
      // Hybrid special (2 more races)
      if(c.race === "Hybrid"){
        // race wheel for hybrid picks one hybrid race at a time
        return { title:"Hybrid Race", hint:"Spin 1 of 2 hybrid races", items: RACES.filter(r=>r!=="Hybrid") };
      }

      // God â†’ tiers
      if(c.race === "God"){
        return { title:"God Tiers", hint:"Spin for your god tier", items:GOD_TIERS };
      }

      // Demon â†’ ranks
      if(c.race === "Demon"){
        return { title:"Demon Ranks", hint:"Spin for your demon rank", items:DEMON_RANKS };
      }

      // Alien â†’ choose Kaiju vs Non-Kaiju
      if(c.race === "Alien"){
        return { title:"Alien Type", hint:"Kaiju or not?", items:ALIEN_TYPE };
      }

      // others: no race wheel
      return null;
    }

    // 2b: Alien Kaiju list if Alien Type == Kaiju
    case 2.1:{
      if(c.race === "Alien" && c.raceDetail === "Kaiju"){
        return { title:"Kaiju", hint:"Spin your Kaiju", items:KAIJU_LIST };
      }
      return null;
    }

    // 2c: Kaiju No 8 levels if Kaiju result == Kaiju No 8
    case 2.2:{
      if(c.race === "Alien" && c.raceDetail === "Kaiju" && c.raceDetail2 === "Kaiju No 8"){
        return { title:"Kaiju No 8", hint:"Spin your Kaiju No 8 level", items:KAIJU_NO8_LEVELS };
      }
      return null;
    }

    // 3: Height (race-based)
    case 3:{
      // If Hybrid: use the largest race
      let baseRace = c.race;
      if(c.race === "Hybrid" && c.hybridBase) baseRace = c.hybridBase;
      const items = heightWheelForRace(baseRace);
      return { title:"Height", hint:`Spin height (${baseRace})`, items };
    }

    case 4: return { title:"Strength", hint:"Spin strength", items:STRENGTH_WORDS };
    case 5: return { title:"Durability", hint:"Spin durability", items:DURABILITY_WORDS };
    case 6: return { title:"Speed", hint:"Spin speed", items:SPEED_WORDS };
    case 7: return { title:"IQ", hint:"Spin IQ", items:IQ_WORDS };
    case 8: return { title:"Fight", hint:"Spin fight", items:FIGHT_WORDS };

    case 9: return { title:"Power", hint:"Spin power", items:POWERS };

    // 10: wheel based on power (only for Super saiyen right now)
    case 10:{
      if((c.powers||[]).includes("Super saiyen")){
        return { title:"Super Saiyen", hint:"Spin your form", items:SUPER_SAIYEN_FORMS };
      }
      return null;
    }

    case 11: return { title:"Weapon", hint:"Spin weapon", items:WEAPONS };
    case 12: return { title:"Trainer", hint:"Spin trainer", items:TRAINERS };
    case 13: return { title:"Power Mastery", hint:"Spin power mastery", items:POWER_MASTERY };
    case 14: return { title:"Weapon Mastery", hint:"Spin weapon mastery", items:WEAPON_MASTERY };

    default: return null;
  }
}

function advancePhaseSkippingNulls(c){
  // step through phases, auto-skip race-based wheels that don't apply
  let p = getPhase();

  // convert float phases (2.1 / 2.2) into a controlled path
  const path = [1,2,2.1,2.2,3,4,5,6,7,8,9,10,11,12,13,14,15];

  let idx = path.indexOf(p);
  if(idx < 0) idx = 0;

  while(true){
    idx++;
    const next = path[idx] ?? 15;
    if(next === 15) return 15;

    // if phase exists and has options, stop
    const o = wheelOptionsForPhase(c, next);
    if(o && o.items && o.items.length){
      return next;
    }
    // otherwise keep skipping
  }
}

/* =========================================================
   6/8 â€” APPLY RESULTS PER PHASE
========================================================= */
function applySpinResult(c, phase, result){
  // normalize
  result = (result === "(empty)" || result == null) ? null : String(result);

  switch(phase){
    case 1:{
      c.race = result;
      logBuild(`Race â†’ ${result}`);

      // If Hybrid: we must collect 2 extra races on phase 2, so prepare fields
      if(c.race === "Hybrid"){
        c.hybridRaces = [];
        c.hybridBase = null;
      }
      break;
    }

    case 2:{
      if(c.race === "Hybrid"){
        // collect 2 races
        c.hybridRaces ||= [];
        if(c.hybridRaces.length < 2){
          // disallow duplicates in hybrid picks
          if(!c.hybridRaces.includes(result)){
            c.hybridRaces.push(result);
            logBuild(`Hybrid race ${c.hybridRaces.length}/2 â†’ ${result}`);
          }else{
            Sound.warn();
            toast("No duplicates. Spin again.");
            return { stay:true };
          }
        }

        // once we have 2, set hybridBase = largest for height wheel
        if(c.hybridRaces.length === 2){
          const [a,b] = c.hybridRaces;
          const ra = SIZE_RANK[a] || 2;
          const rb = SIZE_RANK[b] || 2;
          c.hybridBase = (ra >= rb) ? a : b;
          logBuild(`Hybrid base (largest) â†’ ${c.hybridBase}`);
        }
        break;
      }

      if(c.race === "God"){
        c.raceDetail = result;
        logBuild(`God tier â†’ ${result}`);
        break;
      }

      if(c.race === "Demon"){
        c.raceDetail = result;
        logBuild(`Demon rank â†’ ${result}`);
        break;
      }

      if(c.race === "Alien"){
        c.raceDetail = result; // Kaiju / Non-Kaiju
        logBuild(`Alien type â†’ ${result}`);
        break;
      }
      break;
    }

    case 2.1:{
      // alien kaiju list
      c.raceDetail2 = result; // Kaiju name
      logBuild(`Kaiju â†’ ${result}`);
      break;
    }

    case 2.2:{
      // kaiju no 8 levels
      c.raceDetail3 = result;
      logBuild(`Kaiju No 8 level â†’ ${result}`);
      break;
    }

    case 3: c.height = result; logBuild(`Height â†’ ${result}`); break;

    case 4: c.strengthW = result; logBuild(`Strength â†’ ${result}`); break;
    case 5: c.durabilityW = result; logBuild(`Durability â†’ ${result}`); break;
    case 6: c.speedW = result; logBuild(`Speed â†’ ${result}`); break;
    case 7: c.iqW = result; logBuild(`IQ â†’ ${result}`); break;
    case 8: c.fightW = result; logBuild(`Fight â†’ ${result}`); break;

    case 9:{
      if(result && result !== "No Power"){
        c.powers ||= [];
        c.powers.push(result);
        logBuild(`Power â†’ ${result}`);
      }else{
        logBuild(`Power â†’ None`);
      }
      break;
    }

    case 10:{
      // power detail wheel (only Super saiyen for now)
      c.powerDetail = result;
      logBuild(`Super saiyen form â†’ ${result}`);
      break;
    }

    case 11:{
      if(result && result !== "No Weapon"){
        c.weapons ||= [];
        c.weapons.push(result);
        logBuild(`Weapon â†’ ${result}`);
      }else{
        logBuild(`Weapon â†’ None`);
      }
      break;
    }

    case 12: c.trainer = result; logBuild(`Trainer â†’ ${result}`); break;
    case 13: c.powerMastery = result; logBuild(`Power mastery â†’ ${result}`); break;
    case 14: c.weaponMastery = result; logBuild(`Weapon mastery â†’ ${result}`); break;
  }

  saveNow();
  return { stay:false };
}

/* =========================================================
   7/8 â€” SPIN BUTTON: ENFORCE SEQUENCE + AUTO ADVANCE
========================================================= */
function updateWheelForCurrentPhase(){
  const c = activeCharOrToast();
  if(!c) return;

  if(c.buildComplete){
    setWheel(["LOCKED"], "Build Complete", "No re-spins");
    return;
  }

  // If phase is 2 and race has no race wheel, auto skip forward
  let phase = getPhase();
  const opt = wheelOptionsForPhase(c, phase);

  if(!opt){
    phase = advancePhaseSkippingNulls(c);
    setPhase(phase);
  }

  // If we hit 15, finalize
  if(phase === 15){
    tryFinalizeBuild(); // from Part 9
    return;
  }

  const o = wheelOptionsForPhase(c, phase);
  if(!o){
    // safety
    setWheel(["(error)"], "Wheel", "No options");
    return;
  }
  setWheel(o.items, o.title, o.hint);
}

function doSpin(){
  const c = activeCharOrToast();
  if(!c) return;

  if(c.buildComplete){
    Sound.block();
    toast("Build is locked.");
    return;
  }

  const phase = getPhase();
  const o = wheelOptionsForPhase(c, phase);
  if(!o || !o.items || !o.items.length){
    Sound.warn();
    toast("No wheel here. Auto-fixingâ€¦");
    updateWheelForCurrentPhase();
    return;
  }

  spinWheelFixed((result)=>{
    const res = applySpinResult(c, phase, result);
    if(res?.stay) return;

    // Special Hybrid rule: phase 2 repeats until we get 2 races
    if(c.race === "Hybrid" && phase === 2 && (c.hybridRaces||[]).length < 2){
      // stay on phase 2
      setPhase(2);
      updateWheelForCurrentPhase();
      return;
    }

    // Special Alien: if alien type Kaiju => go to 2.1
    if(c.race === "Alien" && phase === 2 && c.raceDetail === "Kaiju"){
      setPhase(2.1);
      updateWheelForCurrentPhase();
      return;
    }

    // If Kaiju result is Kaiju No 8 => go to 2.2
    if(c.race === "Alien" && phase === 2.1 && c.raceDetail2 === "Kaiju No 8"){
      setPhase(2.2);
      updateWheelForCurrentPhase();
      return;
    }

    // Otherwise advance to next logical phase
    const next = advancePhaseSkippingNulls(c);
    setPhase(next);

    if(next === 15){
      tryFinalizeBuild();
      updateWheelForCurrentPhase();
      return;
    }

    updateWheelForCurrentPhase();
    refreshUI();
  });
}

// Override old spin click handler cleanly
document.getElementById("spinBtn")?.addEventListener("click", (e)=>{
  e.preventDefault();
  Sound.click();
  doSpin();
}, { passive:false });

/* =========================================================
   8/8 â€” UI/RENDER HOOKS
========================================================= */
const _refresh10 = refreshUI;
refreshUI = function(){
  _refresh10?.();

  const c = getActiveChar();
  if(!c) return;

  // phase tag
  const ptag = document.getElementById("phaseTag");
  if(ptag){
    ptag.textContent = c.buildComplete ? "Phase: Complete" : `Phase: ${getPhase()}`;
  }

  // show a better â€œnamedâ€ tag
  const ntag = document.getElementById("namedTag");
  if(ntag){
    ntag.textContent = c.buildComplete ? "Build Complete" : "Buildingâ€¦";
  }

  // keep wheel updated
  updateWheelForCurrentPhase();
};

// Ensure wheel starts on phase 1 for a fresh character
(function bootPhase(){
  const c = getActiveChar();
  if(!c) return;

  // If brand new and nothing spun, start phase 1
  if(!c.race && !c.buildComplete){
    setPhase(1);
  }else if(c.buildComplete){
    setPhase(15);
  }

  updateWheelForCurrentPhase();
  refreshUI();
})();
</script>
<!-- =========================
PART 11 / 12 â€” Stats Layout + Name Safety + Sounds
========================= -->
<script>
/* =========================================================
   1/6 â€” SOUND ENGINE (real, lightweight WebAudio)
========================================================= */
const Sound = (function(){
  let ctx = null;

  function getCtx(){
    if(!ctx){
      const A = window.AudioContext || window.webkitAudioContext;
      if(!A) return null;
      ctx = new A();
    }
    return ctx;
  }

  function beep(freq=440, dur=0.06, type="sine", gain=0.05){
    try{
      if(!state.settings) state.settings = {};
      if(state.settings.sound === false) return;

      const c = getCtx();
      if(!c) return;

      if(c.state === "suspended") c.resume?.();

      const o = c.createOscillator();
      const g = c.createGain();
      o.type = type;
      o.frequency.value = freq;
      g.gain.value = gain;

      o.connect(g);
      g.connect(c.destination);

      o.start();
      o.stop(c.currentTime + dur);
    }catch(e){}
  }

  return {
    click(){ beep(520, 0.03, "square", 0.035); },
    spin(){ beep(240, 0.06, "sawtooth", 0.030); },
    win(){ beep(660, 0.06, "triangle", 0.05); setTimeout(()=>beep(880,0.07,"triangle",0.05), 70); },
    block(){ beep(160, 0.09, "square", 0.05); },
    warn(){ beep(220, 0.07, "square", 0.045); },
    steal(){ beep(740, 0.05, "triangle", 0.05); setTimeout(()=>beep(920,0.05,"triangle",0.05), 55); }
  };
})();

// Volume button (ðŸ”Š / ðŸ”‡)
(function hookVol(){
  const b = document.getElementById("volBtn");
  if(!b) return;
  if(!state.settings) state.settings = {};
  if(typeof state.settings.sound !== "boolean") state.settings.sound = true;

  function sync(){
    b.textContent = state.settings.sound ? "ðŸ”Š" : "ðŸ”‡";
  }
  sync();

  b.addEventListener("click", ()=>{
    state.settings.sound = !state.settings.sound;
    saveNow();
    sync();
    Sound.click();
    toast(state.settings.sound ? "Sound ON" : "Sound OFF");
  });
})();

/* =========================================================
   2/6 â€” NAME SAFETY + SET ONCE (NO RENAMING)
   - max 12 chars
   - letters/numbers/spaces only
   - blocks profanity/inappropriate (no slur list shown)
========================================================= */
function normalizeName(s){
  return String(s ?? "").trim().replace(/\s+/g, " ");
}

function isNameAllowed(name){
  const n = normalizeName(name);

  if(!n) return { ok:false, reason:"Name is empty." };
  if(n.length > 12) return { ok:false, reason:"Max 12 characters." };
  if(!/^[a-zA-Z0-9 ]+$/.test(n)) return { ok:false, reason:"Only letters, numbers, spaces." };

  // Basic profanity/inappropriate filter (no slur list)
  const lower = n.toLowerCase();
  const banned = [
    "fuck","shit","bitch","asshole","dick","pussy","cunt","nigger","faggot" // NOTE: covers common unsafe inputs
  ];
  // We won't display these words; they are only used internally.
  if(banned.some(w => lower.includes(w))){
    return { ok:false, reason:"Inappropriate name." };
  }

  // Also block excessive repeats like "aaaaaa"
  if(/(.)\1\1\1/.test(lower)) return { ok:false, reason:"Name looks spammy." };

  return { ok:true, reason:"" };
}

// Set name ONCE only
function setCharacterNameOnce(name){
  const c = getActiveChar();
  if(!c) return false;

  if(c.nameLocked){
    Sound.block();
    toast("Renaming is not allowed.");
    return false;
  }

  const check = isNameAllowed(name);
  if(!check.ok){
    Sound.warn();
    toast(check.reason);
    return false;
  }

  c.name = normalizeName(name);
  c.nameLocked = true;
  saveNow();
  Sound.click();
  toast(`Name set: ${c.name}`);
  refreshUI();
  return true;
}

/* =========================================================
   3/6 â€” STAT NUMBER MAPPING (WORDS -> NUMBERS)
========================================================= */
function wordIndex(arr, w){
  const i = (arr || []).indexOf(w);
  return (i >= 0) ? i : Math.max(0, Math.min(arr.length-1, 1)); // default "Average-ish"
}
function statWordToNumber(kind, w){
  // Numbers can scale beyond these later via bonuses; this is just the wheel base.
  const maps = {
    strength: STRENGTH_WORDS,
    durability: DURABILITY_WORDS,
    speed: SPEED_WORDS,
    iq: IQ_WORDS,
    fight: FIGHT_WORDS
  };
  const arr = maps[kind] || [];
  const idx = wordIndex(arr, w);

  // Give a simple base curve (0..10-ish)
  // "???" should still be a very high base.
  if(String(w) === "???") return 18;
  return idx; // 0..10 (or 0..8/9 depending)
}

// Turn large numbers into labels; if beyond known -> "???"
function numberToLabel(kind, n){
  const maps = {
    strength: STRENGTH_WORDS,
    durability: DURABILITY_WORDS,
    speed: SPEED_WORDS,
    iq: IQ_WORDS,
    fight: FIGHT_WORDS
  };
  const arr = maps[kind] || [];
  if(n >= 11) return "???";
  return arr[Math.max(0, Math.min(arr.length-1, n))] || "???";
}

/* =========================================================
   4/6 â€” ADDITIVE MODS (preview v1)
========================================================= */
const POWER_MODS = {
  "Adaptation": { durability:+2, fight:+1 },
  "Regeneration": { durability:+3 },
  "Immortal": { durability:+4 },
  "Gravity Manipulation": { strength:+2, fight:+1 },
  "Time Manipulation": { speed:+3, iq:+1 },
  "Telekinesis": { iq:+2, fight:+1 },
  "Teleportation": { speed:+2 },
  "Fire": { strength:+1 },
  "Ice Manipulation": { durability:+1 },
  "Lightning": { speed:+2 },
  "Weapon Creation": { fight:+2 },
  "Heavenly Restriction": { strength:+3, speed:+2, durability:+2, fight:+2, iq:-1 },
  "Rinnegan": { iq:+2, fight:+2 },
  "Kaioken": { strength:+2, speed:+2, fight:+1 },      // powers (not transformation wheel)
  "Eight Gates": { strength:+3, speed:+3, fight:+2 },  // powers
  "Titan Transformation": { strength:+3, durability:+3, fight:+1 }, // powers
  "Super saiyen": { strength:+2, speed:+1, durability:+1, fight:+1 } // base; form adds below
};

const SSJ_FORM_MODS = {
  "Super saiyen": { strength:+1, speed:+1 },
  "Super saiyen 4": { strength:+2, speed:+1, durability:+1 },
  "Super saiyen god": { speed:+2, iq:+1 },
  "Super saiyen blue": { strength:+2, speed:+2, fight:+1 },
  "Ultra instinct": { speed:+3, fight:+3, iq:+1 }
};

const WEAPON_MODS = {
  "Sword": { fight:+2 },
  "Scythe": { fight:+2, strength:+1 },
  "Axe": { strength:+2 },
  "Hammer": { strength:+2, durability:+1 },
  "Spear": { fight:+1, speed:+1 },
  "Brass Knuckles": { fight:+1, strength:+1 },
  "Blades of Chaos": { fight:+2, speed:+1 },
  "Samehada": { durability:+1, fight:+2 },
  "Uzumaki Chains": { durability:+2, fight:+1 },
  "Infinity Gauntlet": { strength:+3, durability:+3, iq:+2, fight:+2 },
  "Green Lantern Ring": { iq:+3, durability:+2 }
};

const MASTERY_RANK = { "None":0, "Dormant":1, "Awakening":2, "Controlled":3, "Mastered":4, "Planetary":5, "Cosmic":6, "Universal":7, "Omnipotent":8 };
function addTo(out, mods){
  for(const k in mods){
    out[k] = (out[k] || 0) + mods[k];
  }
}

function computeStatsPreview(c){
  const base = {
    strength: statWordToNumber("strength", c.strengthW),
    durability: statWordToNumber("durability", c.durabilityW),
    speed: statWordToNumber("speed", c.speedW),
    iq: statWordToNumber("iq", c.iqW),
    fight: statWordToNumber("fight", c.fightW)
  };

  const add = { strength:0, durability:0, speed:0, iq:0, fight:0 };

  // powers (owned)
  (c.powers || []).forEach(p => { if(POWER_MODS[p]) addTo(add, POWER_MODS[p]); });
  // SSJ form detail
  if((c.powers||[]).includes("Super saiyen") && c.powerDetail && SSJ_FORM_MODS[c.powerDetail]){
    addTo(add, SSJ_FORM_MODS[c.powerDetail]);
  }
  // weapons (owned)
  (c.weapons || []).forEach(w => { if(WEAPON_MODS[w]) addTo(add, WEAPON_MODS[w]); });

  // mastery bump
  const pr = MASTERY_RANK[c.powerMastery || "None"] || 0;
  if(pr >= 4) addTo(add, { fight:+1, durability:+1 });     // Mastered+
  if(pr >= 6) addTo(add, { strength:+2, speed:+2, iq:+1 }); // Cosmic+
  if(pr >= 7) addTo(add, { strength:+3, speed:+3, durability:+3, fight:+2, iq:+2 }); // Universal+

  // permanent bonuses (souls/adaptation etc. later)
  const prog = state.progress || {};
  if(prog.soulBonus){
    addTo(add, prog.soulBonus);
  }
  if(typeof prog.adaptationStacks === "number" && (c.powers||[]).includes("Adaptation")){
    addTo(add, { durability: prog.adaptationStacks });
  }

  const total = {
    strength: base.strength + add.strength,
    durability: base.durability + add.durability,
    speed: base.speed + add.speed,
    iq: base.iq + add.iq,
    fight: base.fight + add.fight
  };

  return {
    base, add, total,
    labels: {
      strength: numberToLabel("strength", total.strength),
      durability: numberToLabel("durability", total.durability),
      speed: numberToLabel("speed", total.speed),
      iq: numberToLabel("iq", total.iq),
      fight: numberToLabel("fight", total.fight)
    }
  };
}

/* =========================================================
   5/6 â€” STATS TAB FINAL LAYOUT (SHOW EVERYTHING OWNED)
========================================================= */
function renderStatsTabFinal(){
  const tab = document.getElementById("tab-stats");
  if(!tab) return;

  const listRaw = document.getElementById("statsList");
  const listFinal = document.getElementById("finalStatsList");
  if(!listRaw || !listFinal) return;

  const c = getActiveChar();
  if(!c){
    listRaw.innerHTML = "";
    listFinal.innerHTML = "";
    return;
  }

  // Build â€œidentityâ€ strings
  const raceLine = (()=>{
    if(c.race !== "Hybrid") return c.race || "â€”";
    const a = (c.hybridRaces && c.hybridRaces[0]) ? c.hybridRaces[0] : "â€”";
    const b = (c.hybridRaces && c.hybridRaces[1]) ? c.hybridRaces[1] : "â€”";
    return `Hybrid (${a} + ${b})`;
  })();

  const raceDetailLine = (()=>{
    if(c.race === "God") return c.raceDetail || "â€”";
    if(c.race === "Demon") return c.raceDetail || "â€”";
    if(c.race === "Alien"){
      if(c.raceDetail === "Kaiju"){
        const kaiju = c.raceDetail2 || "â€”";
        const no8 = (kaiju === "Kaiju No 8") ? (c.raceDetail3 || "â€”") : "";
        return no8 ? `Kaiju â†’ ${kaiju} (No 8: ${no8})` : `Kaiju â†’ ${kaiju}`;
      }
      return c.raceDetail || "â€”";
    }
    return "â€”";
  })();

  // RAW section (everything the character currently has)
  const rawLines = [];
  rawLines.push(["Name", c.name ? c.name : "â€”"]);
  rawLines.push(["Race", raceLine]);
  rawLines.push(["Race Detail", raceDetailLine]);
  rawLines.push(["Height", c.height || "â€”"]);
  rawLines.push(["Strength (wheel)", c.strengthW || "â€”"]);
  rawLines.push(["Durability (wheel)", c.durabilityW || "â€”"]);
  rawLines.push(["Speed (wheel)", c.speedW || "â€”"]);
  rawLines.push(["IQ (wheel)", c.iqW || "â€”"]);
  rawLines.push(["Fight (wheel)", c.fightW || "â€”"]);

  rawLines.push(["Powers (owned)", (c.powers||[]).length ? c.powers.join(", ") : "â€”"]);
  rawLines.push(["Power Detail", c.powerDetail || "â€”"]);
  rawLines.push(["Weapons (owned)", (c.weapons||[]).length ? c.weapons.join(", ") : "â€”"]);
  rawLines.push(["Trainer", c.trainer || "â€”"]);
  rawLines.push(["Power Mastery", c.powerMastery || "â€”"]);
  rawLines.push(["Weapon Mastery", c.weaponMastery || "â€”"]);

  rawLines.push(["Build Complete", c.buildComplete ? "Yes" : "No"]);
  rawLines.push(["Alive", (c.alive === false) ? "No" : "Yes"]);
  rawLines.push(["PvE Strikes", String(c.pveStrikes||0)]);
  rawLines.push(["PvP Strikes", String(c.pvpStrikes||0)]);

  // Render RAW
  listRaw.innerHTML = "";
  rawLines.forEach(([k,v])=>{
    const div = document.createElement("div");
    div.className = "statLine";
    div.innerHTML = `<div class="statKey">${escapeHtml(k)}</div><div class="statVal">${escapeHtml(v)}</div>`;
    listRaw.appendChild(div);
  });

  // FINAL/COMPUTED preview (additive)
  const calc = computeStatsPreview(c);

  const finalLines = [];
  finalLines.push(["Strength", `${calc.labels.strength} (${calc.total.strength})`]);
  finalLines.push(["Durability", `${calc.labels.durability} (${calc.total.durability})`]);
  finalLines.push(["Speed", `${calc.labels.speed} (${calc.total.speed})`]);
  finalLines.push(["IQ", `${calc.labels.iq} (${calc.total.iq})`]);
  finalLines.push(["Fight", `${calc.labels.fight} (${calc.total.fight})`]);

  // Show the additive breakdown so itâ€™s obvious itâ€™s stacking
  finalLines.push(["Additive Notes", `Base (wheel) + Owned traits + Mastery + Permanent bonuses`]);

  listFinal.innerHTML = "";
  finalLines.forEach(([k,v])=>{
    const div = document.createElement("div");
    div.className = "statLine";
    div.innerHTML = `<div class="statKey">${escapeHtml(k)}</div><div class="statVal">${escapeHtml(v)}</div>`;
    listFinal.appendChild(div);
  });
}

/* =========================================================
   6/6 â€” HOOKS: refreshUI + click sounds + â€œNew Characterâ€ safety
========================================================= */
const _refresh11 = refreshUI;
refreshUI = function(){
  _refresh11?.();
  renderStatsTabFinal();
};

// Make sure â€œNew Buildâ€ truly creates a NEW character (not replace)
// (in case older handler exists)
(function hardenNewBuild(){
  const b = document.getElementById("newBuildBtn");
  if(!b) return;

  // Add a second listener that safely prevents undefined wheel loops by resetting phase for the new active character
  b.addEventListener("click", ()=>{
    Sound.click();
    // createNewCharacter() is from Part 9
    createNewCharacter?.();
    setPhase?.(1);
    updateWheelForCurrentPhase?.();
    refreshUI();
  });
})();

// Global click sound for main buttons (safe)
["spinBtn","finalizeBtn","pvpStartBtn","pveStartBtn","lootOkBtn","lootCloseBtn"].forEach(id=>{
  document.getElementById(id)?.addEventListener("click", ()=>Sound.click());
});
</script>
<!-- =========================
PART 12 / 12 â€” PvE + Strikes/Permadeath + Unlocks + Spin Lock
========================= -->
<script>
/* =========================================================
   1/6 â€” SAFETY HELPERS
========================================================= */
function nowTime(){
  return new Date().toLocaleTimeString([], {hour:"2-digit", minute:"2-digit"});
}
function clamp01(x){ return Math.max(0, Math.min(1, x)); }
function safeArr(x){ return Array.isArray(x) ? x : []; }

function logPVE(msg){
  const el = document.getElementById("pveLog");
  if(!el) return;
  el.innerHTML = `<div><span class="muted">[${nowTime()}]</span> ${escapeHtml(msg)}</div>` + el.innerHTML;
}
function setBar(id, pct){
  const el = document.getElementById(id);
  if(!el) return;
  el.style.width = `${clamp01(pct) * 100}%`;
}

/* =========================================================
   2/6 â€” BUILD COMPLETE + SPIN LOCK (no redo for that character)
   - finalizeBtn becomes "Build Complete"
========================================================= */
(function lockSpinAfterComplete(){
  const finBtn = document.getElementById("finalizeBtn");
  if(!finBtn) return;

  finBtn.textContent = "Build Complete";

  finBtn.addEventListener("click", ()=>{
    const c = getActiveChar();
    if(!c) return;

    if(c.buildComplete){
      Sound.block();
      toast("Already complete.");
      return;
    }

    // Name must be set once before completion (if you want this required)
    if(!c.nameLocked || !c.name){
      Sound.warn();
      toast("Set your name first.");
      return;
    }

    // Must have finished the wheel sequence (phase 15)
    if(typeof c.phase === "number" && c.phase < 15){
      Sound.warn();
      toast("Finish all wheels first.");
      return;
    }

    c.buildComplete = true;

    // strikes
    c.pveStrikes = 0;
    c.pvpStrikes = 0;
    c.alive = true;

    saveNow();
    Sound.win();
    toast("Build Complete! PvE unlocked.");
    refreshUI();
  });

  // Hard stop spinning if build complete
  const spinBtn = document.getElementById("spinBtn");
  if(spinBtn){
    spinBtn.addEventListener("click", ()=>{
      const c = getActiveChar();
      if(c?.buildComplete){
        Sound.block();
        toast("This character is complete. No re-spins.");
      }
    }, true);
  }
})();

/* =========================================================
   3/6 â€” UNLOCK RULES (PvE unlocks only after buildComplete)
========================================================= */
function isPVEUnlocked(){
  const c = getActiveChar();
  return !!(c && c.buildComplete && c.alive !== false);
}
function isCharAlive(){
  const c = getActiveChar();
  return !!(c && c.alive !== false);
}

(function gatePVEButton(){
  const btn = document.getElementById("pveStartBtn");
  if(!btn) return;

  function sync(){
    btn.disabled = !isPVEUnlocked();
    btn.style.opacity = btn.disabled ? "0.55" : "1";
  }
  sync();

  const _refreshGate = refreshUI;
  refreshUI = function(){
    _refreshGate?.();
    sync();
  };
})();

/* =========================================================
   4/6 â€” STRIKES + PERMADEATH
   PvE: 1 strike = death
   PvP: 2 strikes = death (PvP battles are later real uploads)
========================================================= */
function applyLoss(mode){
  const c = getActiveChar();
  if(!c) return;

  if(mode === "pve"){
    c.pveStrikes = (c.pveStrikes || 0) + 1;
    if(c.pveStrikes >= 1){
      c.alive = false;
      Sound.block();
      toast("Your character died (PvE).");
    }else{
      Sound.warn();
      toast("PvE strike!");
    }
  }

  if(mode === "pvp"){
    c.pvpStrikes = (c.pvpStrikes || 0) + 1;
    if(c.pvpStrikes >= 2){
      c.alive = false;
      Sound.block();
      toast("Your character died (PvP).");
    }else{
      Sound.warn();
      toast(`PvP strike ${c.pvpStrikes}/2`);
    }
  }

  saveNow();
  refreshUI();
}

/* =========================================================
   5/6 â€” PvE COMBAT (simple v1 battle loop)
   - Enemy is generated from same option pools
   - Uses computed stats preview
========================================================= */
function genPVEEnemy(){
  // uses the global option lists created earlier
  const enemy = {
    name: "Event Enemy",
    race: randomPick(RACE_OPTIONS),
    raceDetail: null,
    raceDetail2: null,
    raceDetail3: null,

    height: null,

    strengthW: randomPick(STRENGTH_WORDS),
    durabilityW: randomPick(DURABILITY_WORDS),
    speedW: randomPick(SPEED_WORDS),
    iqW: randomPick(IQ_WORDS),
    fightW: randomPick(FIGHT_WORDS),

    powers: [],
    powerDetail: null,
    weapons: [],
    trainer: randomPick(TRAINER_OPTIONS),
    powerMastery: randomPick(POWER_MASTERY_OPTIONS),
    weaponMastery: randomPick(WEAPON_MASTERY_OPTIONS),

    alive: true,
    buildComplete: true
  };

  // Give enemy a couple traits
  if(Math.random() < 0.8) enemy.powers.push(randomPick(POWER_OPTIONS));
  if(Math.random() < 0.75) enemy.weapons.push(randomPick(WEAPON_OPTIONS));
  enemy.powers = enemy.powers.filter(p=>p && p!=="No Power");
  enemy.weapons = enemy.weapons.filter(w=>w && w!=="No Weapon");

  // If enemy has SSJ power, give a form sometimes
  if(enemy.powers.includes("Super saiyen")){
    enemy.powerDetail = randomPick(SUPER_SAIYEN_FORMS);
  }

  return enemy;
}

function hpFromStats(total){
  // durability and fight matter most
  return 60 + (total.durability * 10) + (total.fight * 4);
}
function dmgFromStats(attTotal, defTotal){
  const atk = (attTotal.strength * 3) + (attTotal.fight * 4) + (attTotal.speed * 1.5);
  const def = (defTotal.durability * 3) + (defTotal.fight * 2);
  const raw = Math.max(8, atk - def * 0.65);
  const variance = 0.85 + Math.random() * 0.25;
  return Math.round(raw * variance);
}

async function startPVE(){
  if(!isCharAlive()){
    Sound.block();
    toast("This character is dead.");
    return;
  }
  if(!isPVEUnlocked()){
    Sound.warn();
    toast("Finish your build first.");
    return;
  }

  const p = getActiveChar();
  const e = genPVEEnemy();

  // Clear log
  const log = document.getElementById("pveLog");
  if(log) log.innerHTML = "";

  // Set tags
  document.getElementById("pve_p_roleTag") && (document.getElementById("pve_p_roleTag").textContent = p.name || "You");
  document.getElementById("pve_e_roleTag") && (document.getElementById("pve_e_roleTag").textContent = e.name);

  // Portrait placeholders (images come later; no crash)
  applyRaceBase?.(p, "pve_p_");
  applyRaceBase?.(e, "pve_e_");

  const pCalc = computeStatsPreview(p);
  const eCalc = computeStatsPreview(e);

  let pHP = hpFromStats(pCalc.total);
  let eHP = hpFromStats(eCalc.total) + 25; // event buff

  const pMax = pHP, eMax = eHP;

  setBar("pve_p_hp", 1);
  setBar("pve_e_hp", 1);

  logPVE(`Event started vs ${e.race}.`);
  Sound.spin();

  // Turn loop
  for(let turn = 1; turn <= 60; turn++){
    // Who hits first based on speed
    const pFirst = (pCalc.total.speed + Math.random()*3) >= (eCalc.total.speed + Math.random()*3);

    const hit = (att, def, who) => {
      const d = dmgFromStats(att, def);
      if(who === "enemy"){
        eHP -= d;
        logPVE(`You hit for ${d}.`);
        setBar("pve_e_hp", eHP / eMax);
      }else{
        pHP -= d;
        logPVE(`Enemy hit for ${d}.`);
        setBar("pve_p_hp", pHP / pMax);
      }
    };

    if(pFirst){
      hit(pCalc.total, eCalc.total, "enemy");
      if(eHP > 0) hit(eCalc.total, pCalc.total, "player");
    }else{
      hit(eCalc.total, pCalc.total, "player");
      if(pHP > 0) hit(pCalc.total, eCalc.total, "enemy");
    }

    // End checks
    if(pHP <= 0 || eHP <= 0) break;

    // Small delay for UI
    await new Promise(r=>setTimeout(r, 70));
  }

  if(pHP <= 0){
    logPVE("Defeat.");
    Sound.block();
    applyLoss("pve");
    return;
  }

  logPVE("Victory!");
  Sound.win();

  // Rewards
  state.currency = state.currency || { coins:0, xp:0 };
  state.currency.coins = (state.currency.coins || 0) + 12;
  state.currency.xp = (state.currency.xp || 0) + 8;

  saveNow();

  // Loot modal (already exists)
  openLootModal?.({
    title: "PvE Victory",
    sub: `You beat an event enemy (${e.race}).`,
    rewards: [
      { label:"Coins", note:"+12", value:String(state.currency.coins) },
      { label:"XP", note:"+8", value:String(state.currency.xp) }
    ],
    traitEvents: [],
    progress: []
  });

  refreshUI();
}

/* Hook PvE button */
document.getElementById("pveStartBtn")?.addEventListener("click", ()=>{
  Sound.click();
  startPVE();
});

/* =========================================================
   6/6 â€” FIXES FOR â€œWONâ€™T SPINâ€ + UNDEFINED WHEEL
   - ensures phase + wheel options are always valid
   - ensures spin handler is not blocked by buildComplete only
========================================================= */
(function spinFixes(){
  // If wheel engine exists, ensure it always has an options array
  const _update = window.updateWheelForCurrentPhase;
  if(typeof _update === "function"){
    window.updateWheelForCurrentPhase = function(){
      const c = getActiveChar?.();
      if(!c) return _update();

      // If phase is missing/invalid, reset to 1
      if(!Number.isFinite(c.phase) || c.phase < 1 || c.phase > 15){
        c.phase = 1;
      }
      // If build complete, stay on phase 15 display
      if(c.buildComplete) c.phase = 15;

      return _update();
    };
  }

  // Guard spinWheel to stop only on buildComplete
  const _spin = window.spinWheel;
  if(typeof _spin === "function"){
    window.spinWheel = function(){
      const c = getActiveChar?.();
      if(c?.buildComplete){
        Sound.block();
        toast("No re-spins for completed characters.");
        return;
      }
      // if phase/wheel undefined, force reset
      if(!c || !Number.isFinite(c.phase)){
        createNewCharacter?.();
        setPhase?.(1);
        updateWheelForCurrentPhase?.();
      }
      Sound.spin();
      return _spin();
    };
  }
})();

/* Final refresh */
refreshUI();
</script>
<script>
/* =========================
HOTFIX â€” Phase never advancing
Paste at VERY bottom of index.html
========================= */

/* 1/6 â€” Ensure every character has a phase */
function ensurePhase(){
  const c = getActiveChar?.();
  if(!c) return null;

  if(!Number.isFinite(c.phase) || c.phase < 1){
    c.phase = 1;
    saveNow?.();
  }
  return c;
}

/* 2/6 â€” Your real build order (NO transformation wheel) */
const V1_PHASES = [
  "Race",               // 1
  "Race Detail",        // 2 (wheel depends on race)
  "Height",             // 3 (wheel depends on race)
  "Strength",           // 4
  "Durability",         // 5
  "Speed",              // 6
  "IQ",                 // 7
  "Fight",              // 8
  "Power",              // 9
  "Weapon",             // 10
  "Trainer",            // 11
  "Power Mastery",      // 12
  "Weapon Mastery",     // 13
  "Build Complete"      // 14 (no spinning here)
];

/* 3/6 â€” Advance phase safely */
function advancePhase(){
  const c = ensurePhase();
  if(!c) return;

  // Donâ€™t advance if character is locked/completed
  if(c.buildComplete) return;

  // cap at last spin phase (13). phase 14 is Build Complete button only
  if(c.phase < 13) c.phase += 1;

  saveNow?.();
  updateWheelForCurrentPhase?.();
  refreshUI?.();
}

/* 4/6 â€” PATCH: wrap your spin result handler
   We hook into the most common function names. */
function patchSpinResultHandler(){
  // try several likely handler names
  const candidates = [
    "handleSpinResult",
    "onSpinResult",
    "onWheelResult",
    "commitSpinResult",
    "applySpinResult",
    "finishSpin"
  ];

  for(const name of candidates){
    if(typeof window[name] === "function"){
      const original = window[name];
      window[name] = function(result){
        const c = ensurePhase();
        const before = c?.phase ?? 1;

        // run your normal logic first (sets race/stat/etc)
        const out = original.call(this, result);

        // if phase didnâ€™t change inside original, force advance
        const after = c?.phase ?? before;
        if(after === before){
          advancePhase();
        } else {
          // even if it advanced, still refresh wheel/UI
          saveNow?.();
          updateWheelForCurrentPhase?.();
          refreshUI?.();
        }

        return out;
      };
      console.log("âœ… Phase hotfix attached to:", name);
      return true;
    }
  }

  console.warn("âš ï¸ Could not find spin result handler to patch.");
  return false;
}

/* 5/6 â€” ALSO patch spinWheel so phase exists BEFORE spinning */
(function patchSpinWheel(){
  if(typeof window.spinWheel === "function"){
    const origSpin = window.spinWheel;
    window.spinWheel = function(){
      ensurePhase();
      return origSpin.call(this);
    };
  }
})();

/* 6/6 â€” Initialize + show phase name in UI (if you have a phase display element) */
(function initPhaseHotfix(){
  ensurePhase();
  patchSpinResultHandler();

  // If you have a phase badge element, update it.
  // (Your UI shows "Phase: â€”" so this will help if the element exists.)
  const phaseBadge = document.getElementById("phaseBadge");
  const c = getActiveChar?.();
  if(phaseBadge && c){
    phaseBadge.textContent = `Phase: ${c.phase} â€” ${V1_PHASES[c.phase-1] || "?"}`;
  }

  updateWheelForCurrentPhase?.();
  refreshUI?.();
})();
</script>
