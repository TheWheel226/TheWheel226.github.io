<!-- ‚úÖ PART 1 / 12 ‚Äî Wheel Forge v1 (index.html start + <head> + Base CSS + Header/Tabs shell)
PASTE THIS AS THE VERY TOP OF YOUR index.html
(Do not add anything above it)
-->

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Wheel Forge ‚Äî v1</title>

  <style>
    :root{
      --bg:#0b0f17;
      --panel:#121a28;
      --panel2:#0f1623;
      --text:#e8eefc;
      --muted:rgba(232,238,252,.65);
      --good:#2ee59d;
      --bad:#ff4d6d;
      --warn:#ffcc66;
      --line:rgba(255,255,255,.10);
      --accent:#7aa8ff;
      --cursed:#ff2e55;
      --shadow: 0 10px 28px rgba(0,0,0,.35);
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
      color:var(--text);
      background:var(--bg);
      overflow-x:hidden;
    }

    /* Background */
    #bgImage{
      position:fixed; inset:0;
      background-size:cover;
      background-position:center;
      filter:saturate(1.05) contrast(1.05) brightness(.55);
      transform:scale(1.03);
      z-index:-2;
    }
    #bgShade{
      position:fixed; inset:0;
      background:
        radial-gradient(1000px 600px at 30% 10%, rgba(122,168,255,.25), transparent 60%),
        linear-gradient(to bottom, rgba(0,0,0,.25), rgba(0,0,0,.75));
      z-index:-1;
    }

    /* Layout */
    .app{
      max-width:1160px;
      margin:0 auto;
      padding:18px 14px 90px;
    }
    .row{display:flex; gap:12px; flex-wrap:wrap}
    .grid{
      display:grid;
      grid-template-columns: 1.25fr .9fr;
      gap:12px;
      margin-top:12px;
    }
    @media (max-width:980px){ .grid{grid-template-columns:1fr} }

    /* Cards */
    .card{
      border:1px solid var(--line);
      background:rgba(18,26,40,.72);
      backdrop-filter: blur(10px);
      border-radius:16px;
      padding:12px;
      box-shadow: var(--shadow);
    }
    .card h2{
      margin:0 0 8px;
      font-size:15px;
      letter-spacing:.2px;
      color:rgba(232,238,252,.92);
    }

    /* Header */
    header{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      padding:10px 12px;
      border:1px solid var(--line);
      background:rgba(18,26,40,.72);
      backdrop-filter: blur(10px);
      border-radius:14px;
      box-shadow: var(--shadow);
    }
    .title{display:flex; flex-direction:column; line-height:1.1;}
    .title b{font-size:18px; letter-spacing:.2px}
    .title span{font-size:12px; color:var(--muted)}
    .pillRow{display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:flex-end}

    .pill{
      font-size:12px;
      border:1px solid var(--line);
      padding:6px 10px;
      border-radius:999px;
      background:rgba(15,22,35,.85);
      color:var(--muted);
      white-space:nowrap;
    }
    .pill strong{color:var(--text)}

    /* Buttons */
    .btn{
      border:1px solid var(--line);
      background:rgba(15,22,35,.85);
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      user-select:none;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:8px;
      font-weight:900;
      transition:transform .08s ease, filter .08s ease, opacity .15s ease;
    }
    .btn:active{transform:scale(.985)}
    .btn[disabled]{opacity:.45; cursor:not-allowed}
    .btn.primary{
      background:linear-gradient(135deg, rgba(122,168,255,.25), rgba(122,168,255,.06));
      border-color:rgba(122,168,255,.35)
    }
    .btn.good{
      background:linear-gradient(135deg, rgba(46,229,157,.18), rgba(46,229,157,.06));
      border-color:rgba(46,229,157,.35)
    }
    .btn.bad{
      background:linear-gradient(135deg, rgba(255,77,109,.20), rgba(255,77,109,.06));
      border-color:rgba(255,77,109,.35)
    }
    .btn.ghost{background:transparent}

    /* Tabs */
    .tabs{
      display:flex; gap:10px; flex-wrap:wrap;
      margin-top:12px;
      align-items:center;
    }
    .tab{
      padding:9px 12px;
      border-radius:999px;
      border:1px solid var(--line);
      background:rgba(15,22,35,.65);
      cursor:pointer;
      font-weight:1000;
      font-size:12px;
      color:rgba(232,238,252,.72);
    }
    .tab.active{
      color:var(--text);
      border-color:rgba(122,168,255,.45);
      background:rgba(122,168,255,.14);
    }
    .hidden{display:none !important;}

    /* Common UI pieces used across tabs */
    .muted{color:var(--muted)}
    .divider{height:1px; background:var(--line); margin:10px 0}

    .statList{display:grid; gap:8px}
    .statLine{
      display:flex; justify-content:space-between; gap:10px;
      padding:10px 10px;
      border-radius:12px;
      border:1px solid var(--line);
      background:rgba(15,22,35,.55);
    }
    .statKey{color:rgba(232,238,252,.70); font-weight:900}
    .statVal{color:rgba(232,238,252,.95); font-weight:1000; text-align:right}

    .badgeRow{display:flex; gap:8px; flex-wrap:wrap; margin-top:8px}
    .badge{
      display:inline-flex; gap:8px; align-items:center;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background:rgba(15,22,35,.65);
      font-size:12px;
      font-weight:1000;
    }
    .badge.cursed{border-color:rgba(255,46,85,.45); background:rgba(255,46,85,.12)}
    .badge .icon{font-size:14px}

    /* Portrait frames */
    .portraitWrap{display:flex; gap:12px; align-items:flex-start; flex-wrap:wrap}
    .frame{
      position:relative;
      width:260px;
      height:260px;
      border-radius:18px;
      border:1px solid var(--line);
      background:rgba(15,22,35,.65);
      overflow:hidden;
    }
    .frame.bigRig{width:300px;height:300px}
    .frame.cursed{box-shadow:0 0 0 2px rgba(255,46,85,.22), 0 0 36px rgba(255,46,85,.25) inset}
    .layer{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      object-fit:contain;
      pointer-events:none;
    }
    .fx{mix-blend-mode:screen; opacity:.92}
    .idle-sway{animation:sway 3.0s ease-in-out infinite}
    @keyframes sway{0%,100%{transform:translateY(0)}50%{transform:translateY(4px)}}

    /* Wheel */
    #wheelBox{display:flex; flex-direction:column; gap:10px}
    #wheelTitle{font-size:16px; font-weight:1100}
    #wheelHint{font-size:12px; color:var(--muted)}
    canvas{
      width:100%;
      max-width:520px;
      height:auto;
      border-radius:16px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.15);
    }
    .btnRow{display:flex; gap:10px; flex-wrap:wrap}

    /* Roster list */
    .rosterList{display:grid; gap:10px}
    .rosterCard{
      border:1px solid var(--line);
      background:rgba(15,22,35,.55);
      border-radius:14px;
      padding:10px;
      display:flex;
      justify-content:space-between;
      gap:12px;
      align-items:flex-start;
    }
    .rosterLeft{display:flex; flex-direction:column; gap:6px}
    .rosterName{font-weight:1100}
    .rosterMeta{font-size:12px; color:rgba(232,238,252,.70)}
    .rosterRight{display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end}
  </style>
</head>

<body>
  <div id="bgImage"></div>
  <div id="bgShade"></div>

  <div class="app">
    <header>
      <div class="title">
        <b>Wheel Forge</b>
        <span class="muted">Build ‚Ä¢ Fusions ‚Ä¢ PvE ‚Ä¢ PvP ‚Ä¢ Permadeath</span>
      </div>

      <div class="pillRow">
        <div id="activeCharPill" class="pill">Active: <strong>‚Äî</strong></div>
        <div id="moneyPill" class="pill">Coins: <strong>0</strong> ‚Ä¢ XP: <strong>0</strong></div>
        <button id="volBtn" class="btn" title="Sound">üîä</button>
      </div>
    </header>

    <div class="tabs">
      <div class="tab active" data-tab="build">BUILD</div>
      <div class="tab" data-tab="roster">ROSTER</div>
      <div class="tab" data-tab="stats">STATS</div>
      <div class="tab" data-tab="pve">PvE</div>
      <div class="tab" data-tab="pvp">PvP</div>

      <div id="phaseTag" class="pill">Phase: ‚Ä¶</div>
      <div id="stabilityTag" class="pill">Stability: ‚Ä¶</div>
    </div>

    <!-- The actual tab sections + scripts start in Part 2 -->
    <!-- ‚úÖ PART 2 / 12 ‚Äî Core State, Roster, Stability, Tabs, Persistence
PASTE THIS DIRECTLY AFTER PART 1 (do not skip)
-->

<script>
/* =========================================================
   CORE HELPERS
========================================================= */
const $ = (id)=>document.getElementById(id);
const $$ = (q)=>Array.from(document.querySelectorAll(q));

function escapeHtml(s){
  return String(s ?? "").replace(/[&<>"']/g, m=>({
    "&":"&amp;","<":"&lt;",">":"&gt;",
    '"':"&quot;","'":"&#039;"
  }[m]));
}

/* =========================================================
   STORAGE + VERSIONING
========================================================= */
const STORAGE_KEY = "wheel_forge_v1_state";

/* =========================================================
   DEFAULT DATA MODELS
========================================================= */
function newCharacter(){
  return {
    id: crypto.randomUUID(),
    name: "",
    alive: true,

    /* core build */
    race: null,
    extraRaces: [],          // hybrid spins
    powers: [],
    weapons: [],
    armors: [],
    curses: [],
    evolutions: [],

    /* mastery / meta */
    clan: null,
    trainer: null,
    powerMastery: "None",

    /* stats (words shown, numbers later) */
    strengthW: "Average",
    speedW: "Average",
    durabilityW: "Average",
    fightW: "Average",
    iqW: "Average",
    luckW: "5",

    /* progression */
    stability: 100,
    pvpStrikes: 0,
    pveStrikes: 0,

    /* flags */
    finalized: false,
    createdAt: Date.now()
  };
}

function defaultState(){
  return {
    version: 1,

    /* roster system */
    roster: [],
    activeCharId: null,

    /* global progress */
    currency: { coins:0, xp:0 },
    settings: { sound:true },

    /* UI */
    ui: { activeTab:"build" }
  };
}

let state = defaultState();

/* =========================================================
   SAVE / LOAD
========================================================= */
function saveState(){
  localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
}

function loadState(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(!raw) return;
    const parsed = JSON.parse(raw);
    state = { ...defaultState(), ...parsed };
  }catch(e){
    console.warn("Failed to load save, resetting.");
    state = defaultState();
  }
}
loadState();

/* =========================================================
   ROSTER LOGIC (PERMADEATH SAFE)
========================================================= */
function getActiveChar(){
  return state.roster.find(c=>c.id===state.activeCharId) || null;
}

function createNewCharacter(){
  const c = newCharacter();
  state.roster.push(c);
  state.activeCharId = c.id;
  saveState();
  refreshUI();
  return c;
}

function killCharacter(char, reason){
  if(!char || !char.alive) return;
  char.alive = false;
  char.deathReason = reason || "Unknown";

  // clear active character
  if(state.activeCharId === char.id){
    state.activeCharId = null;
  }

  saveState();
  refreshUI();
}

/* =========================================================
   STABILITY SYSTEM (FOUNDATION)
========================================================= */
/*
Stability rules (v1 baseline):
- Starts at 100
- Overpowered traits drain stability
- Certain powers (Immortal, Regeneration) prevent instant death
- Low stability causes curses & evolution locks
*/

function recomputeStability(char){
  if(!char) return 0;
  let s = 100;

  // power burden
  s -= char.powers.length * 8;
  s -= char.evolutions.length * 12;
  s -= char.curses.length * 10;

  // immortality buffers
  if(char.powers.includes("Immortal")) s += 20;
  if(char.powers.includes("Regeneration")) s += 10;

  s = Math.max(0, Math.min(150, s));
  char.stability = s;
  return s;
}

/* =========================================================
   STRIKE SYSTEM (PERMADEATH RULES)
========================================================= */
/*
Rules agreed:
- PvP: 2 strikes = death
- PvE: 1 strike = death
*/

function applyPvPStrike(char){
  if(!char || !char.alive) return;
  char.pvpStrikes++;
  if(char.pvpStrikes >= 2){
    killCharacter(char, "Killed in PvP");
  }
}

function applyPvEStrike(char){
  if(!char || !char.alive) return;
  char.pveStrikes++;
  killCharacter(char, "Killed in PvE");
}

/* =========================================================
   TABS
========================================================= */
function showTab(key){
  ["build","roster","stats","pve","pvp"].forEach(k=>{
    $("tab-"+k)?.classList.toggle("hidden", k!==key);
    document.querySelector(`.tab[data-tab="${k}"]`)
      ?.classList.toggle("active", k===key);
  });
  state.ui.activeTab = key;
  saveState();
}

$$(".tab[data-tab]").forEach(t=>{
  t.addEventListener("click", ()=>showTab(t.dataset.tab));
});

/* =========================================================
   UI TAGS
========================================================= */
function updateHeaderPills(){
  const char = getActiveChar();

  $("activeCharPill").innerHTML = char
    ? `Active: <strong>${escapeHtml(char.name||"Unnamed")}</strong>`
    : `Active: <strong>None</strong>`;

  $("moneyPill").innerHTML =
    `Coins: <strong>${state.currency.coins}</strong> ‚Ä¢ XP: <strong>${state.currency.xp}</strong>`;

  $("phaseTag").textContent = char
    ? (char.finalized ? "Phase: Active" : "Phase: Building")
    : "Phase: ‚Äî";

  $("stabilityTag").textContent = char
    ? `Stability: ${recomputeStability(char)}`
    : "Stability: ‚Äî";
}

/* =========================================================
   GLOBAL UI REFRESH
========================================================= */
function refreshUI(){
  updateHeaderPills();

  // keep tab
  showTab(state.ui.activeTab || "build");
}

refreshUI();
</script>
<!-- ‚úÖ PART 3 / 12 ‚Äî Build UI + Roster UI + Wheel Engine (auto-advance phases + correct pointer math)
PASTE THIS DIRECTLY AFTER PART 2
-->

<!-- =========================
  MAIN TABS / SECTIONS
========================= -->

<!-- BUILD TAB -->
<section id="tab-build" class="grid">
  <div class="card" id="wheelBox">
    <div>
      <div id="wheelTitle" style="font-size:16px;font-weight:1000">Wheel</div>
      <div id="wheelHint" class="muted" style="font-size:12px">Press Spin to begin.</div>
    </div>

    <canvas id="wheel" width="520" height="520"></canvas>

    <div class="btnRow" style="display:flex;gap:10px;flex-wrap:wrap;margin-top:10px">
      <button id="spinBtn" class="btn primary">Spin</button>
      <button id="newCharBtn" class="btn good">New Character</button>
      <button id="skipBtn" class="btn ghost">Skip (dev)</button>
    </div>

    <div id="buildHint" class="muted" style="margin-top:6px">
      New characters don‚Äôt overwrite old ones. Death is permanent.
    </div>

    <div class="card" style="margin-top:12px; padding:12px; background:rgba(15,22,35,.45); border-color:rgba(255,255,255,.08)">
      <h2>Build Log</h2>
      <div id="buildLog" class="muted"></div>
    </div>
  </div>

  <div class="card">
    <h2>Active Character</h2>

    <div class="portraitWrap">
      <div id="charFrame" class="frame idle-sway">
        <img id="layer_base" class="layer" alt="">
        <img id="layer_body" class="layer" alt="">
        <img id="layer_back" class="layer" alt="">
        <img id="layer_legs" class="layer" alt="">
        <img id="layer_arms" class="layer" alt="">
        <img id="layer_head" class="layer" alt="">
        <img id="layer_armor" class="layer" alt="">
        <img id="layer_weapon" class="layer" alt="">
        <img id="layer_fx" class="layer fx" alt="">
      </div>

      <div style="flex:1; min-width:260px">
        <div class="row" style="align-items:center;justify-content:space-between">
          <div>
            <div class="muted" style="font-size:12px">Name</div>
            <div id="charNameText" style="font-weight:1100">‚Äî</div>
          </div>
          <button id="nameBtn" class="btn">Set Name</button>
        </div>

        <h2 style="margin-top:12px">Build Snapshot</h2>
        <div id="buildStats" class="statList"></div>

        <div class="badgeRow" id="buildBadges"></div>
      </div>
    </div>
  </div>
</section>

<!-- ROSTER TAB -->
<section id="tab-roster" class="grid hidden">
  <div class="card">
    <h2>Roster</h2>
    <div class="muted" style="margin-bottom:10px">
      You can switch to any living character. Dead characters stay in history.
    </div>
    <div id="rosterList"></div>
  </div>

  <div class="card">
    <h2>Details</h2>
    <div id="rosterDetail" class="muted">Select a character.</div>
  </div>
</section>

<!-- STATS TAB -->
<section id="tab-stats" class="grid hidden">
  <div class="card">
    <h2>Everything Owned</h2>
    <div class="muted" style="margin-bottom:8px">
      This will show ALL powers/weapons/armor/curses/evolutions (not just spin results).
    </div>
    <div id="statsAllList" class="statList"></div>
  </div>

  <div class="card">
    <h2>Final Stats</h2>
    <div class="muted" style="margin-bottom:8px">Additive final stats will appear here (next parts).</div>
    <div id="finalStatsList" class="statList"></div>
  </div>
</section>

<!-- PVE TAB -->
<section id="tab-pve" class="grid hidden">
  <div class="card">
    <h2>PvE</h2>
    <div class="muted" style="margin-bottom:10px">Coming online after combat systems are wired (later parts).</div>
    <button id="pveStartBtn" class="btn primary">Start PvE</button>

    <div class="card" style="margin-top:12px; padding:12px; background:rgba(15,22,35,.45); border-color:rgba(255,255,255,.08)">
      <h2>Combat Log</h2>
      <div id="pveLog" class="muted"></div>
    </div>
  </div>

  <div class="card">
    <h2>Battle</h2>
    <div class="muted">UI reserved.</div>
    <div class="slotProgressWrap" style="margin-top:10px"><div id="pve_p_hp" class="slotProgressBar" style="width:100%"></div></div>
    <div class="slotProgressWrap" style="margin-top:10px"><div id="pve_e_hp" class="slotProgressBar" style="width:100%"></div></div>
  </div>
</section>

<!-- PVP TAB -->
<section id="tab-pvp" class="grid hidden">
  <div class="card">
    <h2>PvP</h2>
    <div class="muted" style="margin-bottom:10px">Coming online after combat systems are wired (later parts).</div>
    <button id="pvpStartBtn" class="btn primary">Start PvP</button>

    <div class="card" style="margin-top:12px; padding:12px; background:rgba(15,22,35,.45); border-color:rgba(255,255,255,.08)">
      <h2>Combat Log</h2>
      <div id="pvpLog" class="muted"></div>
    </div>
  </div>

  <div class="card">
    <h2>Battle</h2>
    <div class="muted">UI reserved.</div>
    <div class="slotProgressWrap" style="margin-top:10px"><div id="p_hp" class="slotProgressBar" style="width:100%"></div></div>
    <div class="slotProgressWrap" style="margin-top:10px"><div id="e_hp" class="slotProgressBar" style="width:100%"></div></div>
  </div>
</section>

<!-- Toast + simple modals -->
<div id="toast"></div>

<div id="nameModal" class="modal hidden">
  <div class="modalCard">
    <div class="modalTop">
      <div>
        <div class="modalTitle">Set Name</div>
        <div class="modalSub">Name your active character.</div>
      </div>
      <button class="btn ghost" id="nameCloseBtn">‚úñ</button>
    </div>

    <input id="nameInput" placeholder="Enter name‚Ä¶" />

    <div class="modalBtns">
      <button class="btn good" id="nameSaveBtn">Save</button>
    </div>
  </div>
</div>

<script>
/* =========================================================
   TOAST (only define if missing)
========================================================= */
if(!window.toast){
  window._toastTimer = null;
  window.toast = function(msg){
    const t = $("toast");
    if(!t) return;
    t.textContent = msg;
    t.classList.add("show");
    clearTimeout(window._toastTimer);
    window._toastTimer = setTimeout(()=>t.classList.remove("show"), 1400);
  };
}

/* =========================================================
   GAME OPTIONS (PHASE WHEELS)
   (These will grow later ‚Äî keeping them correct + stable now.)
========================================================= */
const RACE_OPTIONS = [
  "Gnome","Goblin","Zombie","Skeleton","Human","Orc","Cyborg","Giant","Demi human","Golem",
  "Dragon","Vampire","Hivemind","Shinigami","Soul eater","Demon","Alien","God","Hybrid"
];

const POWER_OPTIONS = [
  "No Power","Adaptation","Regeneration","Gravity Manipulation","Time Manipulation","Telekinesis",
  "Teleportation","Fire","Ice Manipulation","Lightning","Weapon Creation","Heavenly Restriction",
  "Immortal","Rinnegan"
];

const WEAPON_OPTIONS = [
  "No Weapon","Sword","Scythe","Axe","Hammer","Spear","Brass Knuckles","Blades of Chaos","Samehada",
  "Uzumaki Chains","Infinity Gauntlet","Green Lantern Ring"
];

const ARMOR_OPTIONS = [
  "No Armor","Berserk Armor","Iron Man Suit","Jauger","Symbiote","Ashborn's Armor","Rock Lee Weights","Goku's Gi"
];

const CURSE_OPTIONS = [
  "No Curse","Cursed Energy","Bloodlust","Madness","Corruption","Void Taint"
];

/* =========================================================
   BUILD FLOW (AUTO-ADVANCE)
   No redo: once a phase is spun, it locks for that character.
========================================================= */
const PHASES = ["race","race2","race3","power","weapon","armor","curse","done"];

function getPhase(char){
  if(!char) return "none";
  return char.buildPhase || "race";
}

function setPhase(char, phase){
  char.buildPhase = phase;
}

function phaseDisplay(phase){
  switch(phase){
    case "race": return "Race";
    case "race2": return "Hybrid Race #2";
    case "race3": return "Hybrid Race #3";
    case "power": return "Power";
    case "weapon": return "Weapon";
    case "armor": return "Armor";
    case "curse": return "Curse";
    case "done": return "Build Complete";
    default: return "‚Äî";
  }
}

function currentWheelOptions(char){
  const phase = getPhase(char);
  if(phase === "race" || phase === "race2" || phase === "race3") return RACE_OPTIONS;
  if(phase === "power") return POWER_OPTIONS;
  if(phase === "weapon") return WEAPON_OPTIONS;
  if(phase === "armor") return ARMOR_OPTIONS;
  if(phase === "curse") return CURSE_OPTIONS;
  return ["‚Äî"];
}

function advancePhase(char){
  const phase = getPhase(char);

  if(phase === "race"){
    // if Hybrid, you will spin 2 more races
    if(char.race === "Hybrid"){
      setPhase(char, "race2");
    }else{
      setPhase(char, "power");
    }
    return;
  }

  if(phase === "race2"){ setPhase(char, "race3"); return; }
  if(phase === "race3"){ setPhase(char, "power"); return; }

  if(phase === "power"){ setPhase(char, "weapon"); return; }
  if(phase === "weapon"){ setPhase(char, "armor"); return; }
  if(phase === "armor"){ setPhase(char, "curse"); return; }

  if(phase === "curse"){
    setPhase(char, "done");
    char.finalized = true; // no finalize button needed
    return;
  }
}

/* =========================================================
   BUILD APPLY (NO REDO)
========================================================= */
function applySpinResult(char, value){
  const phase = getPhase(char);

  if(phase === "race"){
    if(char.race) return false;
    char.race = value;
    logBuild(`Race ‚Üí ${value}`);
    return true;
  }

  if(phase === "race2"){
    if(char.extraRaces.length >= 1) return false;
    char.extraRaces.push(value);
    logBuild(`Hybrid Race #2 ‚Üí ${value}`);
    return true;
  }

  if(phase === "race3"){
    if(char.extraRaces.length >= 2) return false;
    char.extraRaces.push(value);
    logBuild(`Hybrid Race #3 ‚Üí ${value}`);
    return true;
  }

  if(phase === "power"){
    if(char.powers.length) return false;
    if(value !== "No Power") char.powers.push(value);
    logBuild(`Power ‚Üí ${value}`);
    return true;
  }

  if(phase === "weapon"){
    if(char.weapons.length) return false;
    if(value !== "No Weapon") char.weapons.push(value);
    logBuild(`Weapon ‚Üí ${value}`);
    return true;
  }

  if(phase === "armor"){
    if(char.armors.length) return false;
    if(value !== "No Armor") char.armors.push(value);
    logBuild(`Armor ‚Üí ${value}`);
    return true;
  }

  if(phase === "curse"){
    if(char.curses.length) return false;
    if(value !== "No Curse") char.curses.push(value);
    logBuild(`Curse ‚Üí ${value}`);
    return true;
  }

  return false;
}

/* =========================================================
   BUILD LOG
========================================================= */
function logBuild(msg){
  const el = $("buildLog");
  if(!el) return;
  const time = new Date().toLocaleTimeString([], {hour:"2-digit", minute:"2-digit"});
  el.innerHTML = `<div><span class="muted">[${time}]</span> ${escapeHtml(msg)}</div>` + el.innerHTML;
}

/* =========================================================
   WHEEL DRAW (CORRECT POINTER @ TOP)
========================================================= */
const wheel = $("wheel");
const ctx = wheel?.getContext("2d");
let wheelAngle = 0;
let spinning = false;
let wheelList = ["‚Äî"];

function setWheelList(list){
  wheelList = list && list.length ? list.slice() : ["‚Äî"];
  drawWheel();
}

function drawWheel(){
  if(!ctx || !wheel) return;

  const w = wheel.width, h = wheel.height;
  const cx = w/2, cy = h/2;
  const r = Math.min(cx,cy) - 10;
  ctx.clearRect(0,0,w,h);

  // ring
  ctx.beginPath();
  ctx.arc(cx,cy,r+4,0,Math.PI*2);
  ctx.strokeStyle="rgba(255,255,255,.14)";
  ctx.lineWidth=10;
  ctx.stroke();

  const n = wheelList.length;
  const slice = (Math.PI*2)/n;

  for(let i=0;i<n;i++){
    const a0 = wheelAngle + i*slice;
    const a1 = wheelAngle + (i+1)*slice;

    ctx.beginPath();
    ctx.moveTo(cx,cy);
    ctx.arc(cx,cy,r,a0,a1);
    ctx.closePath();
    ctx.fillStyle = (i%2===0) ? "rgba(122,168,255,.14)" : "rgba(255,255,255,.06)";
    ctx.fill();

    // label
    const mid = (a0+a1)/2;
    ctx.save();
    ctx.translate(cx,cy);
    ctx.rotate(mid);
    ctx.textAlign="right";
    ctx.fillStyle="rgba(232,238,252,.92)";
    ctx.font="900 14px system-ui";
    ctx.fillText(wheelList[i], r-14, 6);
    ctx.restore();
  }

  // pointer at TOP (12 o'clock)
  ctx.beginPath();
  ctx.moveTo(cx, 10);
  ctx.lineTo(cx-12, 34);
  ctx.lineTo(cx+12, 34);
  ctx.closePath();
  ctx.fillStyle="rgba(255,204,102,.95)";
  ctx.fill();
}

function pickFromWheel(){
  const n = wheelList.length;
  const slice = (Math.PI*2)/n;

  // pointer is at -90deg; we want which slice is under it
  const pointer = -Math.PI/2;

  // normalize angle under pointer
  let a = (pointer - wheelAngle) % (Math.PI*2);
  if(a < 0) a += (Math.PI*2);

  const idx = Math.floor(a / slice);
  return wheelList[idx];
}

async function spinWheel(){
  const char = getActiveChar();
  if(!char){
    toast("Create a character first.");
    return;
  }
  if(!char.alive){
    toast("That character is dead.");
    return;
  }

  const phase = getPhase(char);
  if(phase === "done"){
    toast("This character‚Äôs build is complete.");
    return;
  }

  if(spinning) return;
  spinning = true;

  // always set list to current phase
  setWheelList(currentWheelOptions(char));

  let v = 0.35 + Math.random()*0.35;
  const friction = 0.985 - Math.random()*0.006;
  const minTicks = 60 + Math.floor(Math.random()*40);
  let ticks = 0;

  function step(){
    ticks++;
    wheelAngle += v;
    v *= friction;
    drawWheel();

    if(ticks > minTicks && v < 0.01){
      spinning = false;

      const result = pickFromWheel();

      // no redo enforcement
      const ok = applySpinResult(char, result);
      if(!ok){
        toast("That phase is already locked for this character.");
        return;
      }

      // auto advance
      advancePhase(char);

      // update UI
      const nextPhase = getPhase(char);
      $("wheelTitle").textContent = phaseDisplay(nextPhase);
      $("wheelHint").textContent = `Last: ${result}`;
      $("buildHint").textContent = (nextPhase === "done")
        ? "Build complete. This character is now active for PvE/PvP."
        : `Next phase: ${phaseDisplay(nextPhase)}. Spin again.`;

      // stability recompute
      recomputeStability(char);

      saveState();
      refreshUI();
      return;
    }
    requestAnimationFrame(step);
  }

  requestAnimationFrame(step);
}

/* =========================================================
   NEW CHARACTER (does NOT replace current)
========================================================= */
function startNewCharacter(){
  const c = createNewCharacter();
  setPhase(c, "race");
  $("buildLog").innerHTML = "";
  logBuild("New character created.");
  $("wheelTitle").textContent = "Race";
  $("wheelHint").textContent = "Spin to begin";
  $("buildHint").textContent = "No redo. Each phase locks after you spin.";
  setWheelList(RACE_OPTIONS);
  toast("New character created.");
}

/* =========================================================
   ROSTER RENDER
========================================================= */
function renderRoster(){
  const host = $("rosterList");
  const detail = $("rosterDetail");
  if(!host || !detail) return;

  host.innerHTML = "";
  if(state.roster.length === 0){
    host.innerHTML = `<div class="muted">No characters yet. Create one in BUILD.</div>`;
    return;
  }

  state.roster
    .slice()
    .sort((a,b)=>b.createdAt - a.createdAt)
    .forEach(c=>{
      const row = document.createElement("div");
      row.className = "statLine";
      const isActive = (c.id === state.activeCharId);
      const status = c.alive ? "Alive" : `Dead (${c.deathReason||"‚Äî"})`;

      row.innerHTML = `
        <div>
          <div style="font-weight:1100">${escapeHtml(c.name || "Unnamed")}${isActive ? " ‚úÖ" : ""}</div>
          <div class="muted" style="font-size:12px">${escapeHtml(status)}</div>
        </div>
        <div style="display:flex; gap:8px; align-items:center">
          ${c.alive ? `<button class="btn" data-act="switch" data-id="${c.id}">Switch</button>` : ""}
        </div>
      `;
      host.appendChild(row);
    });

  host.querySelectorAll('button[data-act="switch"]').forEach(b=>{
    b.addEventListener("click", ()=>{
      const id = b.getAttribute("data-id");
      const c = state.roster.find(x=>x.id===id);
      if(!c || !c.alive) return;
      state.activeCharId = c.id;
      saveState();
      refreshUI();
      toast("Switched active character.");
      showTab("build");
    });
  });
}

/* =========================================================
   BUILD SNAPSHOT + STATS (layout finalized later)
========================================================= */
function renderBuildSnapshot(){
  const host = $("buildStats");
  const nameText = $("charNameText");
  const badges = $("buildBadges");
  if(!host || !nameText || !badges) return;

  const c = getActiveChar();
  host.innerHTML = "";
  badges.innerHTML = "";

  if(!c){
    nameText.textContent = "‚Äî";
    host.innerHTML = `<div class="muted">Create a character to begin.</div>`;
    return;
  }

  nameText.textContent = c.name || "Unnamed";

  const lines = [];
  lines.push(["Phase", phaseDisplay(getPhase(c))]);
  lines.push(["Race", c.race || "‚Äî"]);
  if(c.race === "Hybrid"){
    lines.push(["Hybrid Races", c.extraRaces.length ? c.extraRaces.join(", ") : "‚Äî"]);
  }
  lines.push(["Power", c.powers.length ? c.powers.join(", ") : "‚Äî"]);
  lines.push(["Weapon", c.weapons.length ? c.weapons.join(", ") : "‚Äî"]);
  lines.push(["Armor", c.armors.length ? c.armors.join(", ") : "‚Äî"]);
  lines.push(["Curse", c.curses.length ? c.curses.join(", ") : "‚Äî"]);
  lines.push(["Stability", String(recomputeStability(c))]);

  lines.forEach(([k,v])=>{
    const div = document.createElement("div");
    div.className = "statLine";
    div.innerHTML = `<div class="statKey">${escapeHtml(k)}</div><div class="statVal">${escapeHtml(v)}</div>`;
    host.appendChild(div);
  });

  const b1 = document.createElement("div");
  b1.className = "badge";
  b1.innerHTML = `<span class="icon">üß¨</span><span>${c.alive ? "Alive" : "Dead"}</span>`;
  badges.appendChild(b1);

  const b2 = document.createElement("div");
  b2.className = "badge";
  b2.innerHTML = `<span class="icon">üß±</span><span>${c.finalized ? "Build Complete" : "Building"}</span>`;
  badges.appendChild(b2);
}

function renderStatsAll(){
  const host = $("statsAllList");
  if(!host) return;
  host.innerHTML = "";

  const c = getActiveChar();
  if(!c){
    host.innerHTML = `<div class="muted">No active character.</div>`;
    return;
  }

  const rows = [
    ["All Races", [c.race, ...(c.extraRaces||[])].filter(Boolean).join(", ") || "‚Äî"],
    ["All Powers", (c.powers||[]).length ? c.powers.join(", ") : "‚Äî"],
    ["All Weapons", (c.weapons||[]).length ? c.weapons.join(", ") : "‚Äî"],
    ["All Armors", (c.armors||[]).length ? c.armors.join(", ") : "‚Äî"],
    ["All Curses", (c.curses||[]).length ? c.curses.join(", ") : "‚Äî"],
    ["All Evolutions", (c.evolutions||[]).length ? c.evolutions.join(", ") : "‚Äî"],
    ["Stability", String(recomputeStability(c))]
  ];

  rows.forEach(([k,v])=>{
    const div = document.createElement("div");
    div.className = "statLine";
    div.innerHTML = `<div class="statKey">${escapeHtml(k)}</div><div class="statVal">${escapeHtml(v)}</div>`;
    host.appendChild(div);
  });
}

/* =========================================================
   NAME MODAL
========================================================= */
$("nameBtn")?.addEventListener("click", ()=>{
  const c = getActiveChar();
  if(!c) return toast("Create a character first.");
  $("nameInput").value = c.name || "";
  $("nameModal").classList.remove("hidden");
  $("nameInput").focus();
});

$("nameCloseBtn")?.addEventListener("click", ()=>$("nameModal").classList.add("hidden"));
$("nameSaveBtn")?.addEventListener("click", ()=>{
  const c = getActiveChar();
  if(!c) return;
  c.name = ($("nameInput").value || "").trim().slice(0,24);
  $("nameModal").classList.add("hidden");
  saveState();
  refreshUI();
  toast("Name saved.");
});

/* =========================================================
   BUTTONS
========================================================= */
$("spinBtn")?.addEventListener("click", spinWheel);
$("newCharBtn")?.addEventListener("click", startNewCharacter);

$("skipBtn")?.addEventListener("click", ()=>{
  const c = getActiveChar();
  if(!c) return;
  advancePhase(c);
  saveState();
  refreshUI();
  toast("Skipped phase (dev).");
});

/* If your Part 1 still has a Reset button, disable it for v1 */
$("resetBtn")?.addEventListener("click", (e)=>{
  e.preventDefault();
  toast("Reset is disabled in v1. Death is permanent.");
});

/* =========================================================
   EXTEND refreshUI
========================================================= */
const _refreshUI_p3 = window.refreshUI;
window.refreshUI = function(){
  _refreshUI_p3?.();
  renderRoster();
  renderBuildSnapshot();
  renderStatsAll();

  // wheel UI title/list
  const c = getActiveChar();
  if(!c){
    $("wheelTitle").textContent = "Wheel";
    $("wheelHint").textContent = "Create a character";
    setWheelList(["‚Äî"]);
  }else{
    const ph = getPhase(c);
    $("wheelTitle").textContent = phaseDisplay(ph);
    setWheelList(currentWheelOptions(c));
  }
};

/* =========================================================
   INIT
========================================================= */
setWheelList(["‚Äî"]);
drawWheel();

if(state.roster.length === 0){
  // first time: create one so the game feels alive
  startNewCharacter();
}else{
  // if active is missing, pick newest alive
  if(!getActiveChar()){
    const alive = state.roster.filter(c=>c.alive).sort((a,b)=>b.createdAt-a.createdAt)[0];
    if(alive){
      state.activeCharId = alive.id;
      saveState();
    }
  }
  refreshUI();
}
</script>
<!-- ‚úÖ PART 4 / 12 ‚Äî Core State + Persistence + Tabs (includes ROSTER) + Stability v1
PASTE THIS DIRECTLY AFTER PART 3
-->

<script>
/* =========================================================
   PART 4 SAFETY: only define if missing
========================================================= */
(function(){
  // DOM helper
  if(!window.$) window.$ = (id)=>document.getElementById(id);

  // escape helper
  if(!window.escapeHtml){
    window.escapeHtml = function(s){
      return String(s ?? "").replace(/[&<>"']/g, m=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[m]));
    };
  }

  // random id
  function uid(){
    return "c_" + Math.random().toString(16).slice(2) + "_" + Date.now().toString(16);
  }

  /* =========================================================
     STORAGE + STATE (prevents refresh reset)
  ========================================================= */
  const STORAGE_KEY = "wheel_forge_v1_state_12parts";

  function defaultCharacter(){
    return {
      id: uid(),
      createdAt: Date.now(),
      alive: true,
      deathReason: "",
      name: "",

      // build
      buildPhase: "race",
      finalized: false,

      // spin-locked results
      race: null,
      extraRaces: [],       // for Hybrid race #2 and #3
      powers: [],
      weapons: [],
      armors: [],
      curses: [],
      evolutions: [],       // will be used later

      // runtime / meta
      stability: 100,
      strikesPVE: 0,
      strikesPVP: 0,

      // inventory that grows over time (for ‚Äúshow EVERYTHING owned‚Äù)
      owned: {
        races: [],
        powers: [],
        weapons: [],
        armors: [],
        curses: [],
        evolutions: []
      }
    };
  }

  function defaultState(){
    return {
      version: 1,
      roster: [],
      activeCharId: null,

      // global progress (later)
      global: {
        coins: 0,
        xp: 0
      },

      ui: {
        activeTab: "build"
      },

      settings: {
        sound: true
      }
    };
  }

  // Global state object (create if missing)
  if(!window.state){
    window.state = defaultState();
  }

  // Deep-ish merge for load safety
  function mergeState(base, incoming){
    const out = { ...base, ...(incoming||{}) };
    out.ui = { ...base.ui, ...(incoming?.ui||{}) };
    out.settings = { ...base.settings, ...(incoming?.settings||{}) };
    out.global = { ...base.global, ...(incoming?.global||{}) };
    out.roster = Array.isArray(incoming?.roster) ? incoming.roster : base.roster;
    out.activeCharId = incoming?.activeCharId ?? base.activeCharId;
    return out;
  }

  if(!window.saveState){
    window.saveState = function(){
      try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(window.state)); }catch(e){}
    };
  }

  if(!window.loadState){
    window.loadState = function(){
      try{
        const raw = localStorage.getItem(STORAGE_KEY);
        if(!raw) return;
        const parsed = JSON.parse(raw);
        window.state = mergeState(defaultState(), parsed);

        // normalize characters
        window.state.roster = (window.state.roster||[]).map(c=>{
          const base = defaultCharacter();
          // keep id from saved char
          base.id = c.id || base.id;
          return {
            ...base,
            ...c,
            extraRaces: Array.isArray(c.extraRaces) ? c.extraRaces : [],
            powers: Array.isArray(c.powers) ? c.powers : [],
            weapons: Array.isArray(c.weapons) ? c.weapons : [],
            armors: Array.isArray(c.armors) ? c.armors : [],
            curses: Array.isArray(c.curses) ? c.curses : [],
            evolutions: Array.isArray(c.evolutions) ? c.evolutions : [],
            owned: {
              races: Array.isArray(c.owned?.races) ? c.owned.races : [],
              powers: Array.isArray(c.owned?.powers) ? c.owned.powers : [],
              weapons: Array.isArray(c.owned?.weapons) ? c.owned.weapons : [],
              armors: Array.isArray(c.owned?.armors) ? c.owned.armors : [],
              curses: Array.isArray(c.owned?.curses) ? c.owned.curses : [],
              evolutions: Array.isArray(c.owned?.evolutions) ? c.owned.evolutions : []
            }
          };
        });
      }catch(e){}
    };
  }

  // Load immediately (so refresh doesn‚Äôt wipe)
  window.loadState();

  /* =========================================================
     CHARACTER HELPERS
  ========================================================= */
  if(!window.getActiveChar){
    window.getActiveChar = function(){
      const id = window.state.activeCharId;
      if(!id) return null;
      return window.state.roster.find(c=>c.id===id) || null;
    };
  }

  if(!window.createNewCharacter){
    window.createNewCharacter = function(){
      const c = defaultCharacter();
      window.state.roster.push(c);
      window.state.activeCharId = c.id;
      window.saveState();
      return c;
    };
  }

  function pushUnique(arr, val){
    if(!val) return;
    if(!arr.includes(val)) arr.push(val);
  }

  function syncOwnedFromBuild(char){
    // always keep ‚Äúowned‚Äù updated with what you got from spins
    const owned = char.owned || (char.owned = { races:[], powers:[], weapons:[], armors:[], curses:[], evolutions:[] });

    // races
    if(char.race) pushUnique(owned.races, char.race);
    (char.extraRaces||[]).forEach(r=>pushUnique(owned.races, r));

    // other lists
    (char.powers||[]).forEach(x=>pushUnique(owned.powers, x));
    (char.weapons||[]).forEach(x=>pushUnique(owned.weapons, x));
    (char.armors||[]).forEach(x=>pushUnique(owned.armors, x));
    (char.curses||[]).forEach(x=>pushUnique(owned.curses, x));
    (char.evolutions||[]).forEach(x=>pushUnique(owned.evolutions, x));
  }

  /* =========================================================
     STABILITY v1 (simple but expandable)
     - Strong powers/curses reduce stability
     - If stability hits 0 later: ‚Äúunstable events‚Äù (next parts)
  ========================================================= */
  const STABILITY_COST = {
    // powers
    "Immortal": 25,
    "Regeneration": 10,
    "Time Manipulation": 18,
    "Gravity Manipulation": 14,
    "Rinnegan": 20,
    "Heavenly Restriction": 15,

    // curses
    "Cursed Energy": 10,
    "Bloodlust": 12,
    "Madness": 15,
    "Corruption": 18,
    "Void Taint": 22
  };

  if(!window.recomputeStability){
    window.recomputeStability = function(char){
      if(!char) return 0;

      let s = 100;

      // Hybrid strains stability a bit
      if(char.race === "Hybrid") s -= 8;
      if((char.extraRaces||[]).length) s -= (char.extraRaces.length * 6);

      // power/curses cost
      (char.powers||[]).forEach(p=>{ s -= (STABILITY_COST[p] || 0); });
      (char.curses||[]).forEach(c=>{ s -= (STABILITY_COST[c] || 0); });

      // gear is mostly ‚Äústabilizing‚Äù for now (small boost)
      s += Math.min(6, (char.armors||[]).length * 2);

      // clamp
      s = Math.max(0, Math.min(100, Math.round(s)));

      char.stability = s;

      // keep owned updated
      syncOwnedFromBuild(char);

      return s;
    };
  }

  /* =========================================================
     TABS (adds ROSTER tab if missing)
  ========================================================= */
  function ensureRosterTabButton(){
    // If your tabs row from Part 1 doesn‚Äôt have ROSTER, add it.
    const tabs = document.querySelector(".tabs");
    if(!tabs) return;

    const existing = tabs.querySelector('.tab[data-tab="roster"]');
    if(existing) return;

    // insert after BUILD
    const buildBtn = tabs.querySelector('.tab[data-tab="build"]');
    const b = document.createElement("div");
    b.className = "tab";
    b.dataset.tab = "roster";
    b.textContent = "ROSTER";

    if(buildBtn && buildBtn.nextSibling){
      buildBtn.parentNode.insertBefore(b, buildBtn.nextSibling);
    }else{
      tabs.appendChild(b);
    }
  }

  ensureRosterTabButton();

  if(!window.showTab){
    window.showTab = function(key){
      const keys = ["build","roster","stats","pve","pvp"];
      keys.forEach(k=>{
        $("tab-"+k)?.classList.toggle("hidden", k!==key);
        document.querySelector(`.tab[data-tab="${k}"]`)?.classList.toggle("active", k===key);
      });
      window.state.ui = window.state.ui || {};
      window.state.ui.activeTab = key;
      window.saveState();
    };

    document.querySelectorAll(".tab[data-tab]").forEach(btn=>{
      btn.addEventListener("click", ()=>window.showTab(btn.dataset.tab));
    });
  } else {
    // If showTab exists from earlier parts, still wire clicks for the new roster button.
    document.querySelectorAll(".tab[data-tab]").forEach(btn=>{
      if(btn.__wfBound) return;
      btn.__wfBound = true;
      btn.addEventListener("click", ()=>window.showTab(btn.dataset.tab));
    });
  }

  /* =========================================================
     UI polish / safety
  ========================================================= */
  // disable/hide Reset if present
  const reset = $("resetBtn");
  if(reset){
    reset.style.display = "none";
  }

  // phase + named tag
  function updateHeaderPills(){
    const c = window.getActiveChar();
    const phaseTag = $("phaseTag");
    const namedTag = $("namedTag");
    if(!phaseTag || !namedTag) return;

    if(!c){
      phaseTag.textContent = "Phase: ‚Äî";
      namedTag.textContent = "No active character";
      return;
    }
    phaseTag.textContent = c.finalized ? "Phase: Complete" : `Phase: ${c.buildPhase || "race"}`;
    namedTag.textContent = c.name ? c.name : "Unnamed";
  }

  const _refreshUI_p4 = window.refreshUI;
  window.refreshUI = function(){
    _refreshUI_p4?.();
    updateHeaderPills();

    // restore last tab
    const tab = window.state.ui?.activeTab || "build";
    window.showTab?.(tab);

    // recompute stability whenever UI refreshes
    const c = window.getActiveChar();
    if(c) window.recomputeStability(c);
  };

  // Final init
  if(window.state.roster.length === 0){
    window.createNewCharacter();
  }else if(!window.getActiveChar()){
    // pick newest alive
    const alive = window.state.roster.filter(x=>x.alive).sort((a,b)=>b.createdAt-a.createdAt)[0];
    if(alive){
      window.state.activeCharId = alive.id;
      window.saveState();
    }
  }

  window.refreshUI?.();
})();
</script>
<!-- ‚úÖ PART 5 / 12 ‚Äî ROSTER TAB + Phase Engine (auto-advance spins) + Hybrid extra races + New Build creates NEW character
PASTE THIS DIRECTLY AFTER PART 4
-->

<!-- ROSTER TAB (NEW) -->
<section id="tab-roster" class="grid hidden">
  <div class="card">
    <h2>Roster</h2>
    <div class="muted" style="margin-bottom:10px">
      Your characters are permanent. ‚ÄúNew Build‚Äù creates a new character (it does NOT replace your current one).
      A character only disappears when they die.
    </div>

    <div id="rosterList" class="statList"></div>
  </div>

  <div class="card">
    <h2>Selected Character</h2>
    <div id="rosterDetail" class="muted"></div>

    <div class="row" style="margin-top:12px">
      <button id="rosterGoBuildBtn" class="btn primary">Go to BUILD</button>
      <button id="rosterGoStatsBtn" class="btn">Go to STATS</button>
    </div>
  </div>
</section>

<script>
/* =========================================================
   PART 5: ROSTER UI + AUTO PHASE SPINS (NO REDO)
========================================================= */
(function(){
  const $ = window.$ || ((id)=>document.getElementById(id));
  const toast = window.toast || ((m)=>console.log(m));

  /* -----------------------------
     Ensure option pools exist
  ----------------------------- */
  // If these are already defined earlier, we keep yours.
  if(!window.RACE_OPTIONS){
    window.RACE_OPTIONS = [
      "Gnome","Goblin","Zombie","Skeleton","Human","Orc","Cyborg","Giant","Demi human","Golem",
      "Dragon","Vampire","Hivemind","Shinigami","Soul eater","Demon","Alien","God","Hybrid"
    ];
  }
  if(!window.POWER_OPTIONS)  window.POWER_OPTIONS  = ["No Power","Adaptation","Regeneration","Gravity Manipulation","Time Manipulation","Telekinesis","Teleportation","Fire","Ice Manipulation","Lightning","Weapon Creation","Heavenly Restriction","Immortal","Rinnegan"];
  if(!window.WEAPON_OPTIONS) window.WEAPON_OPTIONS = ["No Weapon","Sword","Scythe","Axe","Hammer","Spear","Brass Knuckles","Blades of Chaos","Samehada","Uzumaki Chains","Infinity Gauntlet","Green Lantern Ring"];
  if(!window.ARMOR_OPTIONS)  window.ARMOR_OPTIONS  = ["No Armor","Berserk Armor","Iron Man Suit","Jauger","Symbiote","Ashborn's Armor","Rock Lee Weights","Goku's Gi"];

  // Optional future pools
  if(!window.CURSE_OPTIONS)  window.CURSE_OPTIONS  = ["No Curse","Cursed Energy","Bloodlust","Madness","Corruption","Void Taint"];

  function randFrom(arr){
    return arr[Math.floor(Math.random()*arr.length)];
  }

  function pushUnique(arr, val){
    if(!val) return;
    if(!arr.includes(val)) arr.push(val);
  }

  /* -----------------------------
     ROSTER RENDER
  ----------------------------- */
  function formatCharSummary(c){
    const races = [c.race, ...(c.extraRaces||[])].filter(Boolean);
    const dead = c.alive ? "" : " ‚ò†Ô∏è";
    return `${c.name ? c.name : "Unnamed"}${dead} ‚Äî ${races.length ? races.join(" + ") : "No race yet"}`;
  }

  function renderRoster(){
    const host = $("rosterList");
    const detail = $("rosterDetail");
    if(!host || !detail) return;

    host.innerHTML = "";
    const roster = (window.state?.roster || []);

    if(roster.length === 0){
      host.innerHTML = `<div class="muted">No characters yet.</div>`;
      detail.textContent = "";
      return;
    }

    roster
      .slice()
      .sort((a,b)=> (b.createdAt||0) - (a.createdAt||0))
      .forEach(c=>{
        const row = document.createElement("div");
        row.className = "statLine";
        row.style.cursor = "pointer";
        row.innerHTML = `
          <div class="statKey">${escapeHtml(formatCharSummary(c))}</div>
          <div class="statVal">${c.id===window.state.activeCharId ? "‚úÖ Active" : "Select"}</div>
        `;
        row.addEventListener("click", ()=>{
          window.state.activeCharId = c.id;
          window.saveState?.();
          window.refreshUI?.();
          renderRoster();
        });
        host.appendChild(row);
      });

    const active = window.getActiveChar?.();
    if(!active){
      detail.textContent = "No active character.";
      return;
    }

    const races = [active.race, ...(active.extraRaces||[])].filter(Boolean);
    const powers = (active.owned?.powers || active.powers || []);
    const weapons = (active.owned?.weapons || active.weapons || []);
    const armors = (active.owned?.armors || active.armors || []);
    const curses = (active.owned?.curses || active.curses || []);

    detail.innerHTML = `
      <div class="statLine"><div class="statKey">Status</div><div class="statVal">${active.alive ? "Alive" : "Dead"}</div></div>
      <div class="statLine"><div class="statKey">Races</div><div class="statVal">${escapeHtml(races.length ? races.join(" + ") : "‚Äî")}</div></div>
      <div class="statLine"><div class="statKey">Stability</div><div class="statVal">${active.stability ?? 100}/100</div></div>
      <div class="statLine"><div class="statKey">PvE Strikes</div><div class="statVal">${active.strikesPVE||0} / 1</div></div>
      <div class="statLine"><div class="statKey">PvP Strikes</div><div class="statVal">${active.strikesPVP||0} / 2</div></div>
      <div class="statLine"><div class="statKey">Owned Powers</div><div class="statVal">${escapeHtml(powers.length ? powers.join(", ") : "‚Äî")}</div></div>
      <div class="statLine"><div class="statKey">Owned Weapons</div><div class="statVal">${escapeHtml(weapons.length ? weapons.join(", ") : "‚Äî")}</div></div>
      <div class="statLine"><div class="statKey">Owned Armor</div><div class="statVal">${escapeHtml(armors.length ? armors.join(", ") : "‚Äî")}</div></div>
      <div class="statLine"><div class="statKey">Owned Curses</div><div class="statVal">${escapeHtml(curses.length ? curses.join(", ") : "‚Äî")}</div></div>
    `;
  }

  /* -----------------------------
     Build rules
     - ‚ÄúFinalize‚Äù button is not needed: build locks itself as you spin phases.
     - After buildComplete, spins are blocked.
  ----------------------------- */
  const finalizeBtn = $("finalizeBtn");
  if(finalizeBtn) finalizeBtn.style.display = "none";

  function logBuild(msg){
    const el = $("buildLog");
    if(!el) return;
    const time = new Date().toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
    el.innerHTML = `<div><span class="muted">[${time}]</span> ${escapeHtml(msg)}</div>` + el.innerHTML;
  }

  function setBuildHints(title, hint, bottom){
    const t = $("wheelTitle"); if(t) t.textContent = title;
    const h = $("wheelHint");  if(h) h.textContent = hint;
    const b = $("buildHint");  if(b) b.textContent = bottom;
  }

  function getPhaseWheelOptions(phase){
    switch(phase){
      case "race": return window.RACE_OPTIONS;
      case "hybrid_race_2": return window.RACE_OPTIONS.filter(x=>x!=="Hybrid");
      case "hybrid_race_3": return window.RACE_OPTIONS.filter(x=>x!=="Hybrid");
      case "power": return window.POWER_OPTIONS;
      case "weapon": return window.WEAPON_OPTIONS;
      case "armor": return window.ARMOR_OPTIONS;
      case "curse": return window.CURSE_OPTIONS;
      default: return window.RACE_OPTIONS;
    }
  }

  function nextPhaseAfter(phase, activeChar){
    if(phase === "race"){
      // if Hybrid, you MUST roll 2 more races
      if(activeChar.race === "Hybrid") return "hybrid_race_2";
      return "power";
    }
    if(phase === "hybrid_race_2") return "hybrid_race_3";
    if(phase === "hybrid_race_3") return "power";

    if(phase === "power") return "weapon";
    if(phase === "weapon") return "armor";
    if(phase === "armor") return "curse";          // v1 stability starts here
    if(phase === "curse") return "complete";
    return "complete";
  }

  function lockListPush(list, value, bannedLabel){
    if(!value) return;
    if(String(value) === bannedLabel) return;
    if(!Array.isArray(list)) list = [];
    pushUnique(list, value);
    return list;
  }

  function applySpinResult(char, phase, value){
    if(!char || !char.alive) return;

    if(phase === "race"){
      char.race = value;
      logBuild(`Race ‚Üí ${value}`);
      pushUnique(char.owned.races, value);
      return;
    }

    if(phase === "hybrid_race_2" || phase === "hybrid_race_3"){
      char.extraRaces = Array.isArray(char.extraRaces) ? char.extraRaces : [];
      char.extraRaces.push(value);
      logBuild(`Hybrid Race ‚Üí ${value}`);
      pushUnique(char.owned.races, value);
      return;
    }

    if(phase === "power"){
      char.powers = lockListPush(char.powers||[], value, "No Power") || (char.powers||[]);
      if(value !== "No Power") logBuild(`Power ‚Üí ${value}`);
      pushUnique(char.owned.powers, value === "No Power" ? null : value);
      return;
    }

    if(phase === "weapon"){
      char.weapons = lockListPush(char.weapons||[], value, "No Weapon") || (char.weapons||[]);
      if(value !== "No Weapon") logBuild(`Weapon ‚Üí ${value}`);
      pushUnique(char.owned.weapons, value === "No Weapon" ? null : value);
      return;
    }

    if(phase === "armor"){
      char.armors = lockListPush(char.armors||[], value, "No Armor") || (char.armors||[]);
      if(value !== "No Armor") logBuild(`Armor ‚Üí ${value}`);
      pushUnique(char.owned.armors, value === "No Armor" ? null : value);
      return;
    }

    if(phase === "curse"){
      char.curses = Array.isArray(char.curses) ? char.curses : [];
      if(value && value !== "No Curse"){
        pushUnique(char.curses, value);
        pushUnique(char.owned.curses, value);
        logBuild(`Curse ‚Üí ${value}`);
      } else {
        logBuild(`Curse ‚Üí None`);
      }
      return;
    }
  }

  function markBuildComplete(char){
    char.finalized = true;
    char.buildPhase = "complete";
    logBuild("‚úÖ Build complete. Character locked.");
    toast("Build complete. Character locked.");
  }

  /* -----------------------------
     NEW BUILD button: create NEW char
  ----------------------------- */
  const newBuildBtn = $("newBuildBtn");
  if(newBuildBtn){
    newBuildBtn.addEventListener("click", ()=>{
      const c = window.createNewCharacter?.();
      if(!c) return;
      $("buildLog").innerHTML = "";
      setBuildHints("Race", "Spin to roll Race", "Spin to begin. No redo.");
      window.showTab?.("build");
      window.refreshUI?.();
      renderRoster();
      toast("New character created.");
    }, { once:false });
  }

  /* -----------------------------
     Wheel: override with phase-aware wheel (fixes pointer)
  ----------------------------- */
  const canvas = $("wheel");
  const ctx = canvas?.getContext?.("2d");
  let wheelAngle = 0;
  let wheelSpinning = false;

  function currentCharAndPhase(){
    const c = window.getActiveChar?.();
    if(!c) return { c:null, phase:"race" };
    if(!c.buildPhase) c.buildPhase = "race";
    return { c, phase: c.buildPhase };
  }

  function drawWheel(){
    if(!ctx || !canvas) return;
    const { phase } = currentCharAndPhase();
    const options = getPhaseWheelOptions(phase);
    const n = options.length;

    const w = canvas.width, h = canvas.height;
    const cx = w/2, cy = h/2;
    const r = Math.min(cx,cy) - 8;

    ctx.clearRect(0,0,w,h);

    // ring
    ctx.beginPath();
    ctx.arc(cx,cy,r+4,0,Math.PI*2);
    ctx.strokeStyle="rgba(255,255,255,.15)";
    ctx.lineWidth=10;
    ctx.stroke();

    const slice = (Math.PI*2)/n;

    for(let i=0;i<n;i++){
      const a0 = wheelAngle + i*slice;
      const a1 = wheelAngle + (i+1)*slice;

      ctx.beginPath();
      ctx.moveTo(cx,cy);
      ctx.arc(cx,cy,r,a0,a1);
      ctx.closePath();
      ctx.fillStyle = i%2===0 ? "rgba(122,168,255,.14)" : "rgba(255,255,255,.06)";
      ctx.fill();

      // label
      const mid = (a0+a1)/2;
      ctx.save();
      ctx.translate(cx,cy);
      ctx.rotate(mid);
      ctx.textAlign="right";
      ctx.fillStyle="rgba(232,238,252,.92)";
      ctx.font="900 14px system-ui";
      ctx.fillText(options[i], r-14, 6);
      ctx.restore();
    }

    // pointer at top
    ctx.beginPath();
    ctx.moveTo(cx, 10);
    ctx.lineTo(cx-12, 34);
    ctx.lineTo(cx+12, 34);
    ctx.closePath();
    ctx.fillStyle="rgba(255,204,102,.95)";
    ctx.fill();
  }

  function pickFromWheel(){
    const { phase } = currentCharAndPhase();
    const options = getPhaseWheelOptions(phase);
    const n = options.length;
    const slice = (Math.PI*2)/n;

    // pointer is at TOP => angle -PI/2 in canvas polar coords
    const pointer = -Math.PI/2;

    // which slice is under pointer after rotation?
    let a = (pointer - wheelAngle) % (Math.PI*2);
    if(a < 0) a += Math.PI*2;

    const idx = Math.floor(a / slice);
    return options[idx];
  }

  async function spinWheel(){
    const { c, phase } = currentCharAndPhase();
    if(!c){
      toast("No active character.");
      return;
    }
    if(!c.alive){
      toast("This character is dead.");
      return;
    }
    if(c.finalized || c.buildPhase === "complete"){
      toast("Character is locked. No redo.");
      return;
    }
    if(wheelSpinning) return;

    wheelSpinning = true;

    // set header for phase
    const titleMap = {
      race: "Race",
      hybrid_race_2: "Hybrid Race (2/3)",
      hybrid_race_3: "Hybrid Race (3/3)",
      power: "Power",
      weapon: "Weapon",
      armor: "Armor",
      curse: "Curse"
    };
    setBuildHints(titleMap[phase] || "Wheel", "Spinning‚Ä¶", "No redo. Each spin locks the result.");

    // spin physics
    let v = 0.35 + Math.random()*0.35;
    const friction = 0.985 - Math.random()*0.006;
    const minTicks = 70 + Math.floor(Math.random()*40);
    let ticks = 0;

    function step(){
      ticks++;
      wheelAngle += v;
      v *= friction;
      drawWheel();

      if(ticks > minTicks && v < 0.01){
        wheelSpinning = false;

        const result = pickFromWheel();
        applySpinResult(c, phase, result);

        // advance phase
        const next = nextPhaseAfter(phase, c);
        if(next === "complete"){
          // recompute stability + lock
          window.recomputeStability?.(c);
          markBuildComplete(c);
          setBuildHints("Complete", "Build Locked", "Go to STATS / PvE / PvP. (Roster keeps every character.)");
        } else {
          c.buildPhase = next;
          const nextTitle = titleMap[next] || "Wheel";
          setBuildHints(nextTitle, "Ready", `Next spin rolls: ${nextTitle}`);
        }

        window.recomputeStability?.(c);
        window.saveState?.();
        window.refreshUI?.();
        renderRoster();
        return;
      }
      requestAnimationFrame(step);
    }
    requestAnimationFrame(step);
  }

  // Wire button to our phase-aware spin
  const spinBtn = $("spinBtn");
  if(spinBtn){
    // remove older listeners by replacing onclick (works even if addEventListener was used earlier)
    spinBtn.onclick = spinWheel;
  }

  // Skip + Fast spin placeholders (kept safe)
  const skipBtn = $("skipBtn");
  if(skipBtn){
    skipBtn.onclick = ()=>{
      const { c, phase } = currentCharAndPhase();
      if(!c || c.finalized) return toast("No.");
      c.buildPhase = nextPhaseAfter(phase, c);
      if(c.buildPhase === "complete") markBuildComplete(c);
      window.saveState?.();
      window.refreshUI?.();
      renderRoster();
      toast("Skipped.");
      drawWheel();
    };
  }
  const fastBtn = $("testFastBtn");
  if(fastBtn){
    fastBtn.onclick = ()=>{
      // just do an instant pick without animation (for testing)
      const { c, phase } = currentCharAndPhase();
      if(!c || c.finalized) return toast("No.");
      const options = getPhaseWheelOptions(phase);
      const result = randFrom(options);
      applySpinResult(c, phase, result);

      const next = nextPhaseAfter(phase, c);
      if(next === "complete"){
        window.recomputeStability?.(c);
        markBuildComplete(c);
      } else {
        c.buildPhase = next;
      }

      window.recomputeStability?.(c);
      window.saveState?.();
      window.refreshUI?.();
      renderRoster();
      drawWheel();
    };
  }

  // Roster nav buttons
  $("rosterGoBuildBtn")?.addEventListener("click", ()=>window.showTab?.("build"));
  $("rosterGoStatsBtn")?.addEventListener("click", ()=>window.showTab?.("stats"));

  // Render + wheel init
  renderRoster();
  drawWheel();

  // If current character is missing phase, set to race
  const active = window.getActiveChar?.();
  if(active && !active.buildPhase) active.buildPhase = "race";

  window.saveState?.();
})();
</script>
<!-- ‚úÖ PART 6 / 12 ‚Äî State/Save FIX + Active Character Sync + Stability System + Owned-Traits Stats Layout + Death/Strikes helpers
PASTE THIS DIRECTLY AFTER PART 5
-->

<script>
/* =========================================================
   PART 6: FOUNDATION FIXES (safe patch)
   - Makes roster the real save source (no more "refresh resets")
   - Keeps state.character synced to active roster character
   - Adds Stability + Sacrifice mechanic (optional UI on STATS)
   - Adds ‚ÄúOwned Traits‚Äù display on STATS (shows EVERYTHING you own)
   - Adds PvE/PvP strike + death helpers (PvE 1 strike, PvP 2 strikes)
   - Removes/hides Reset button
========================================================= */
(function(){
  const $ = window.$ || ((id)=>document.getElementById(id));
  const escapeHtml = window.escapeHtml || ((s)=>String(s ?? "").replace(/[&<>"']/g, m=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[m])));
  const toast = window.toast || ((m)=>console.log(m));

  /* -----------------------------
     STORAGE: ensure we always save roster + activeCharId
  ----------------------------- */
  const STORAGE_KEY = window.STORAGE_KEY || "wheel_forge_state_v1";

  // If Part 4 created defaultState(), keep it; otherwise create a safe one.
  if(!window.defaultState){
    window.defaultState = ()=>({
      roster: [],
      activeCharId: null,
      ui: { activeTab: "build" },
      progress: { pvpWins:0, soulsCaptured:0, soulBonus:{ strength:0,speed:0,durability:0,fight:0,iq:0 }, adaptationStacks:0, lastStolenAt:0 },
      currency: { coins:0, xp:0 },
      settings: { sound:true }
    });
  }

  // If state doesn't exist yet, create it.
  if(!window.state) window.state = window.defaultState();

  // Upgrade older saves that used state.character only.
  function upgradeStateShape(){
    const s = window.state;

    if(!Array.isArray(s.roster)) s.roster = [];
    if(!s.ui) s.ui = { activeTab:"build" };
    if(!s.settings) s.settings = { sound:true };
    if(!s.currency) s.currency = { coins:0, xp:0 };
    if(!s.progress) s.progress = { pvpWins:0, soulsCaptured:0, soulBonus:{ strength:0,speed:0,durability:0,fight:0,iq:0 }, adaptationStacks:0, lastStolenAt:0 };

    // If old save had one character, convert it into a roster entry.
    if(s.character && !s.roster.length){
      const converted = normalizeCharacter(s.character);
      s.roster.push(converted);
      s.activeCharId = converted.id;
    }

    // If we have roster but no activeCharId, pick newest alive, else newest.
    if(!s.activeCharId && s.roster.length){
      const alive = s.roster.filter(c=>c.alive);
      const pick = (alive.length ? alive : s.roster).slice().sort((a,b)=>(b.createdAt||0)-(a.createdAt||0))[0];
      s.activeCharId = pick?.id || null;
    }
  }

  // Replace saveState/loadState with roster-safe versions (keeps your other fields).
  window.saveState = function(){
    try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(window.state)); }catch(e){}
  };

  window.loadState = function(){
    try{
      const raw = localStorage.getItem(STORAGE_KEY);
      if(!raw) return;
      const parsed = JSON.parse(raw);
      const base = window.defaultState();
      window.state = { ...base, ...parsed };
      // deep merges
      window.state.ui = { ...base.ui, ...(parsed.ui||{}) };
      window.state.settings = { ...base.settings, ...(parsed.settings||{}) };
      window.state.currency = { ...base.currency, ...(parsed.currency||{}) };
      window.state.progress = { ...base.progress, ...(parsed.progress||{}) };
      window.state.progress.soulBonus = { ...base.progress.soulBonus, ...((parsed.progress||{}).soulBonus||{}) };

      if(!Array.isArray(window.state.roster)) window.state.roster = [];
      upgradeStateShape();
    }catch(e){}
  };

  // Load now (safe even if it already loaded earlier)
  window.loadState();
  upgradeStateShape();
  window.saveState();

  /* -----------------------------
     CHARACTER MODEL
  ----------------------------- */
  function uid(){
    return "c_" + Math.random().toString(16).slice(2) + Date.now().toString(16);
  }

  function normalizeCharacter(c){
    const now = Date.now();
    const out = { ...(c||{}) };
    out.id = out.id || uid();
    out.createdAt = out.createdAt || now;

    out.alive = (out.alive !== false);
    out.finalized = !!out.finalized;
    out.buildPhase = out.buildPhase || (out.finalized ? "complete" : "race");

    out.name = out.name || "";
    out.race = out.race || null;
    out.extraRaces = Array.isArray(out.extraRaces) ? out.extraRaces : [];

    // These are the "equipped/current" lists (from spins / steals / etc.)
    out.powers = Array.isArray(out.powers) ? out.powers : [];
    out.weapons = Array.isArray(out.weapons) ? out.weapons : [];
    out.armors = Array.isArray(out.armors) ? out.armors : [];
    out.curses = Array.isArray(out.curses) ? out.curses : [];

    // Ownership inventory (EVERYTHING gained, not just spins)
    out.owned = out.owned || {};
    out.owned.races  = Array.isArray(out.owned.races)  ? out.owned.races  : [];
    out.owned.powers = Array.isArray(out.owned.powers) ? out.owned.powers : [];
    out.owned.weapons= Array.isArray(out.owned.weapons)? out.owned.weapons: [];
    out.owned.armors = Array.isArray(out.owned.armors) ? out.owned.armors : [];
    out.owned.curses = Array.isArray(out.owned.curses) ? out.owned.curses : [];

    // Stats words (if your Part 4 uses these)
    out.strengthW = out.strengthW || "Average";
    out.speedW = out.speedW || "Average";
    out.durabilityW = out.durabilityW || "Average";
    out.fightW = out.fightW || "Average";
    out.iqW = out.iqW || "Average";
    out.luckW = out.luckW || "5";

    // Strikes/death
    out.strikesPVE = out.strikesPVE || 0; // max 1 => dead
    out.strikesPVP = out.strikesPVP || 0; // max 2 => dead
    out.diedAt = out.diedAt || 0;

    // Stability
    out.stability = Number.isFinite(out.stability) ? out.stability : 100; // 0-100
    out.stabilityNotes = Array.isArray(out.stabilityNotes) ? out.stabilityNotes : [];

    return out;
  }

  window.getActiveChar = function(){
    const s = window.state;
    if(!s || !Array.isArray(s.roster) || !s.roster.length) return null;
    const c = s.roster.find(x=>x.id === s.activeCharId) || s.roster[0];
    return c ? normalizeCharacter(c) : null;
  };

  function commitActiveChar(updated){
    const s = window.state;
    const idx = s.roster.findIndex(x=>x.id === updated.id);
    if(idx >= 0) s.roster[idx] = updated;
    else s.roster.push(updated);
    s.activeCharId = updated.id;
  }

  // New character creator (used by Part 5 "New Build")
  window.createNewCharacter = function(){
    const c = normalizeCharacter({
      finalized:false,
      buildPhase:"race",
      alive:true,
      stability:100
    });
    window.state.roster.push(c);
    window.state.activeCharId = c.id;

    // IMPORTANT: we keep your existing state.progress/currency globally
    window.saveState();
    window.refreshUI?.();
    return c;
  };

  /* -----------------------------
     ACTIVE CHARACTER SYNC (compat layer)
     Many of your existing functions still read state.character.
     We keep state.character pointing at the active roster char.
  ----------------------------- */
  function syncActiveCharacterAlias(){
    const a = window.getActiveChar();
    if(!a) return;
    // Ensure roster is holding the normalized version
    commitActiveChar(a);
    window.state.character = a;
  }

  // Wrap refreshUI to always sync active char first
  if(window.refreshUI){
    const _refresh = window.refreshUI;
    window.refreshUI = function(){
      syncActiveCharacterAlias();
      _refresh();
      renderOwnedTraitsPanel();
      renderStabilityPanel();
      window.saveState();
    };
  } else {
    // fallback
    window.refreshUI = function(){
      syncActiveCharacterAlias();
      renderOwnedTraitsPanel();
      renderStabilityPanel();
      window.saveState();
    };
  }

  syncActiveCharacterAlias();
  window.saveState();

  /* -----------------------------
     REMOVE / HIDE RESET (per your rules)
  ----------------------------- */
  const resetBtn = $("resetBtn");
  if(resetBtn){
    resetBtn.style.display = "none";
    resetBtn.onclick = null;
  }

  /* -----------------------------
     STABILITY (v1)
     - Starts at 100
     - Powerful/unstable traits reduce stability
     - Curses reduce stability
     - Sacrifice removes one owned power/weapon/curse to regain stability
  ----------------------------- */
  const POWER_STABILITY_COST = {
    "Time Manipulation": 18,
    "Rinnegan": 16,
    "Immortal": 14,
    "Regeneration": 10,
    "Heavenly Restriction": 12,
    "Gravity Manipulation": 8,
    "Telekinesis": 6,
    "Teleportation": 6
  };
  const CURSE_COST = {
    "Cursed Energy": 12,
    "Corruption": 16,
    "Void Taint": 20,
    "Madness": 10,
    "Bloodlust": 8
  };
  const WEAPON_COST = {
    "Infinity Gauntlet": 18,
    "Green Lantern Ring": 12
  };

  window.recomputeStability = function(char){
    if(!char) return 100;
    char = normalizeCharacter(char);

    let stability = 100;
    const notes = [];

    // Count ‚Äúcurrent equipped‚Äù as primary strain
    (char.powers||[]).forEach(p=>{
      const cost = POWER_STABILITY_COST[p] || 0;
      if(cost){ stability -= cost; notes.push(`Power strain: ${p} (-${cost})`); }
    });
    (char.weapons||[]).forEach(w=>{
      const cost = WEAPON_COST[w] || 0;
      if(cost){ stability -= cost; notes.push(`Weapon strain: ${w} (-${cost})`); }
    });
    (char.curses||[]).forEach(cu=>{
      const cost = CURSE_COST[cu] || 6; // unknown curse still hurts a bit
      if(cu && cu!=="No Curse"){ stability -= cost; notes.push(`Curse: ${cu} (-${cost})`); }
    });

    // Hybrid adds some strain
    const races = [char.race, ...(char.extraRaces||[])].filter(Boolean);
    if(races.includes("Hybrid")){
      stability -= 10;
      notes.push("Hybrid instability (-10)");
    }
    if((char.extraRaces||[]).length >= 2){
      stability -= 6;
      notes.push("Multi-race strain (-6)");
    }

    stability = Math.max(0, Math.min(100, Math.round(stability)));
    char.stability = stability;
    char.stabilityNotes = notes;

    // Commit back
    commitActiveChar(char);
    window.state.character = char;
    window.saveState();
    return stability;
  };

  function getStabilityTier(st){
    if(st >= 70) return { label:"Stable", badge:"‚úÖ" };
    if(st >= 40) return { label:"Unstable", badge:"‚ö†Ô∏è" };
    return { label:"Critical", badge:"‚ò†Ô∏è" };
  }

  // UI injected into STATS tab
  function ensureStatsExtrasMounted(){
    const statsTab = $("tab-stats");
    if(!statsTab) return;

    if(!$("ownedPanel")){
      const wrap = document.createElement("div");
      wrap.className = "grid";
      wrap.style.marginTop = "12px";
      wrap.innerHTML = `
        <div class="card" id="ownedPanel">
          <h2>Owned Traits</h2>
          <div class="muted" style="margin-bottom:8px">
            This shows everything your character has ever gained (spins + steals + rewards).
          </div>
          <div id="ownedTraitsList" class="statList"></div>
        </div>

        <div class="card" id="stabilityPanel">
          <h2>Stability</h2>
          <div id="stabilitySummary" class="muted"></div>
          <div id="stabilityNotes" class="muted" style="margin-top:10px"></div>

          <div class="row" style="margin-top:12px">
            <button id="sacrificeBtn" class="btn bad">Sacrifice to Stabilize</button>
          </div>
          <div class="muted" style="margin-top:10px">
            Sacrifice removes one owned trait (power/weapon/curse) to raise stability.
          </div>
        </div>
      `;
      // Insert below the existing two cards (Raw Build + Final Stats)
      statsTab.appendChild(wrap);
    }
  }

  function renderOwnedTraitsPanel(){
    ensureStatsExtrasMounted();
    const host = $("ownedTraitsList");
    if(!host) return;

    const c = window.getActiveChar();
    if(!c){ host.innerHTML = `<div class="muted">No character.</div>`; return; }

    const races = (c.owned?.races || []).filter(Boolean);
    const powers = (c.owned?.powers || []).filter(Boolean);
    const weapons = (c.owned?.weapons || []).filter(Boolean);
    const armors = (c.owned?.armors || []).filter(Boolean);
    const curses = (c.owned?.curses || []).filter(Boolean);

    host.innerHTML = "";

    const addRow = (k, arr)=>{
      const div = document.createElement("div");
      div.className = "statLine";
      div.innerHTML = `<div class="statKey">${escapeHtml(k)}</div><div class="statVal">${escapeHtml(arr.length ? arr.join(", ") : "‚Äî")}</div>`;
      host.appendChild(div);
    };

    addRow("Owned Races", races);
    addRow("Owned Powers", powers);
    addRow("Owned Weapons", weapons);
    addRow("Owned Armor", armors);
    addRow("Owned Curses", curses);
  }

  function renderStabilityPanel(){
    ensureStatsExtrasMounted();
    const sum = $("stabilitySummary");
    const notesEl = $("stabilityNotes");
    const btn = $("sacrificeBtn");
    if(!sum || !notesEl || !btn) return;

    const c = window.getActiveChar();
    if(!c){ sum.textContent="No character."; notesEl.textContent=""; btn.disabled=true; return; }

    const st = window.recomputeStability(c);
    const tier = getStabilityTier(st);

    sum.innerHTML = `
      <div class="statLine">
        <div class="statKey">${tier.badge} ${tier.label}</div>
        <div class="statVal">${st}/100</div>
      </div>
      <div class="statLine">
        <div class="statKey">PvE Strikes</div>
        <div class="statVal">${c.strikesPVE||0} / 1</div>
      </div>
      <div class="statLine">
        <div class="statKey">PvP Strikes</div>
        <div class="statVal">${c.strikesPVP||0} / 2</div>
      </div>
    `;

    const notes = (c.stabilityNotes||[]);
    notesEl.innerHTML = notes.length
      ? notes.map(x=>`<div>‚Ä¢ ${escapeHtml(x)}</div>`).join("")
      : `<div>‚Ä¢ No major strain detected.</div>`;

    btn.disabled = (!c.alive);
  }

  async function sacrificeToStabilize(){
    const c0 = window.getActiveChar();
    if(!c0 || !c0.alive) return toast("You can't sacrifice on a dead character.");

    const c = normalizeCharacter(c0);

    // Build sacrifice pool from OWNED lists (not just current equipped)
    const pool = [];
    (c.owned?.powers || []).forEach(p=>p && pool.push({ kind:"power", value:p }));
    (c.owned?.weapons|| []).forEach(w=>w && pool.push({ kind:"weapon", value:w }));
    (c.owned?.curses || []).forEach(x=>x && pool.push({ kind:"curse", value:x }));

    if(!pool.length){
      toast("Nothing to sacrifice yet.");
      return;
    }

    // Use your existing choice modal if available
    const openChoiceModal = window.openChoiceModal;
    if(!openChoiceModal){
      toast("Choice modal missing.");
      return;
    }

    const options = pool.slice(0, 30).map(item=>{
      const label = `${item.kind.toUpperCase()}: ${item.value}`;
      return { label, value: JSON.stringify(item) };
    });

    const pickedRaw = await openChoiceModal({
      title: "Sacrifice",
      sub: "Pick 1 trait to sacrifice to regain stability.",
      options
    });

    if(!pickedRaw) return;

    let picked;
    try{ picked = JSON.parse(pickedRaw); }catch(e){ return; }

    // Remove from OWNED
    function removeFrom(arr, val){
      if(!Array.isArray(arr)) return [];
      return arr.filter(x=>x !== val);
    }

    if(picked.kind === "power"){
      c.owned.powers = removeFrom(c.owned.powers, picked.value);
      c.powers = removeFrom(c.powers, picked.value); // also unequip if currently equipped
    }
    if(picked.kind === "weapon"){
      c.owned.weapons = removeFrom(c.owned.weapons, picked.value);
      c.weapons = removeFrom(c.weapons, picked.value);
    }
    if(picked.kind === "curse"){
      c.owned.curses = removeFrom(c.owned.curses, picked.value);
      c.curses = removeFrom(c.curses, picked.value);
    }

    // Gain stability back (simple rule: +20, capped at 100)
    c.stability = Math.min(100, (c.stability||100) + 20);

    commitActiveChar(c);
    window.state.character = c;
    window.saveState();
    window.refreshUI?.();

    toast(`Sacrificed ${picked.value}. Stability +20.`);
  }

  $("sacrificeBtn")?.addEventListener("click", sacrificeToStabilize);

  /* -----------------------------
     STRIKES / DEATH (helpers)
     PvE: 1 strike = dead
     PvP: 2 strikes = dead
  ----------------------------- */
  function killCharacter(char, reason){
    char.alive = false;
    char.diedAt = Date.now();
    char.finalized = true;
    char.buildPhase = "complete";
    toast(`‚ò†Ô∏è Character died (${reason}).`);

    // pick next alive
    const alive = window.state.roster.filter(x=>x.alive);
    if(alive.length){
      const pick = alive.slice().sort((a,b)=>(b.createdAt||0)-(a.createdAt||0))[0];
      window.state.activeCharId = pick.id;
    } else {
      window.state.activeCharId = null;
    }
    commitActiveChar(char);
    window.saveState();
    window.refreshUI?.();
  }

  window.applyBattleResult = function(mode, won){
    // mode: "pve" | "pvp"
    const c0 = window.getActiveChar();
    if(!c0) return;
    const c = normalizeCharacter(c0);

    if(!c.alive) return;

    if(won){
      // wins can slightly restore stability (tiny)
      c.stability = Math.min(100, (c.stability||100) + 2);
      commitActiveChar(c);
      window.saveState();
      window.refreshUI?.();
      return;
    }

    if(mode === "pve"){
      c.strikesPVE = (c.strikesPVE||0) + 1;
      commitActiveChar(c);
      window.saveState();
      window.refreshUI?.();
      if(c.strikesPVE >= 1) killCharacter(c, "PvE defeat");
      return;
    }

    if(mode === "pvp"){
      c.strikesPVP = (c.strikesPVP||0) + 1;
      commitActiveChar(c);
      window.saveState();
      window.refreshUI?.();
      if(c.strikesPVP >= 2) killCharacter(c, "PvP defeats");
      return;
    }
  };

  /* -----------------------------
     TAB SYSTEM: add ROSTER tab button if missing
  ----------------------------- */
  function ensureRosterTabButton(){
    const tabs = document.querySelector(".tabs");
    if(!tabs) return;
    if(document.querySelector(`.tab[data-tab="roster"]`)) return;

    const t = document.createElement("div");
    t.className = "tab";
    t.dataset.tab = "roster";
    t.textContent = "ROSTER";

    // insert after BUILD
    const buildTab = document.querySelector(`.tab[data-tab="build"]`);
    if(buildTab && buildTab.nextSibling){
      tabs.insertBefore(t, buildTab.nextSibling);
    } else {
      tabs.appendChild(t);
    }

    t.addEventListener("click", ()=>window.showTab?.("roster"));
  }

  ensureRosterTabButton();

  // Patch showTab to include roster, but keep your existing logic
  if(window.showTab){
    const _showTab = window.showTab;
    window.showTab = function(key){
      // allow older showTab to work, then also manage roster visibility
      _showTab(key);

      // if older showTab doesn't know roster, do it here
      const roster = $("tab-roster");
      if(roster){
        roster.classList.toggle("hidden", key !== "roster");
      }

      window.state.ui ||= {};
      window.state.ui.activeTab = key;
      window.saveState();
    };
  }

  /* -----------------------------
     FINAL: make sure we have at least 1 character
  ----------------------------- */
  if(!window.state.roster.length){
    window.createNewCharacter();
  } else {
    syncActiveCharacterAlias();
  }

  // Initial render
  window.refreshUI?.();
})();
</script>
<!-- ‚úÖ PART 7 / 12 ‚Äî Auto-Advance Multi-Phase Wheel + Pointer Fix + No Re-Spin After Final + ROSTER tab UI
PASTE THIS DIRECTLY AFTER PART 6
-->

<!-- ROSTER TAB (new) -->
<section id="tab-roster" class="grid hidden">
  <div class="card">
    <h2>Roster</h2>
    <div class="muted" style="margin-bottom:10px">
      Your characters are permanent. New Build creates a NEW character. Dead characters stay dead.
    </div>
    <div id="rosterList" class="statList"></div>
  </div>

  <div class="card">
    <h2>Active Character</h2>
    <div id="activeCharInfo" class="statList"></div>

    <div class="row" style="margin-top:12px">
      <button id="rosterNewBtn" class="btn primary">New Character</button>
      <button id="rosterGoBuildBtn" class="btn">Go to Build</button>
    </div>

    <div class="muted" style="margin-top:10px">
      Tip: If you want ‚Äúno redo‚Äù, don‚Äôt use Finalize mid-build ‚Äî the wheel auto-advances and auto-locks at the end.
    </div>
  </div>
</section>

<script>
/* =========================================================
   PART 7: MULTI-PHASE WHEEL ENGINE (auto-advance)
   Fixes:
   - Pointer selection matches the top arrow
   - Wheel auto-advances: Race ‚Üí Power ‚Üí Weapon ‚Üí Armor ‚Üí Clan ‚Üí Trainer ‚Üí Mastery ‚Üí Transform ‚Üí Stats ‚Üí Curse ‚Üí DONE
   - Hybrid: after Hybrid race, spins 2 MORE races automatically (stored as extraRaces)
   - After DONE: Spin is disabled (no redo)
   - New Build creates a NEW character (roster)
========================================================= */
(function(){
  const $ = window.$ || ((id)=>document.getElementById(id));
  const escapeHtml = window.escapeHtml || ((s)=>String(s ?? "").replace(/[&<>"']/g, m=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[m])));
  const toast = window.toast || ((m)=>console.log(m));

  // require Part 6 helpers
  if(!window.getActiveChar || !window.createNewCharacter || !window.saveState) {
    console.warn("Part 7 missing Part 6 helpers.");
    return;
  }

  // --- constants fallback (if not defined yet)
  const RACE_OPTIONS   = window.RACE_OPTIONS   || ["Human"];
  const POWER_OPTIONS  = window.POWER_OPTIONS  || ["No Power"];
  const WEAPON_OPTIONS = window.WEAPON_OPTIONS || ["No Weapon"];
  const ARMOR_OPTIONS  = window.ARMOR_OPTIONS  || ["No Armor"];
  const CLAN_OPTIONS   = window.CLAN_OPTIONS   || ["No Clan"];
  const TRAINER_OPTIONS= window.TRAINER_OPTIONS|| ["No Trainer"];
  const POWER_MASTERY_OPTIONS = window.POWER_MASTERY_OPTIONS || ["None"];
  const TRANSFORM_OPTIONS = window.TRANSFORM_OPTIONS || ["None"];

  const STRENGTH_WORDS = window.STRENGTH_WORDS || ["Average"];
  const SPEED_WORDS    = window.SPEED_WORDS    || ["Average"];
  const DUR_WORDS      = window.DUR_WORDS      || ["Average"];
  const FIGHT_WORDS    = window.FIGHT_WORDS    || ["Average"];
  const IQ_WORDS       = window.IQ_WORDS       || ["Average"];

  // Curse system: you can expand later
  const CURSE_OPTIONS = window.CURSE_OPTIONS || [
    "No Curse",
    "Cursed Energy",
    "Bloodlust",
    "Madness",
    "Corruption",
    "Void Taint"
  ];
  window.CURSE_OPTIONS = CURSE_OPTIONS;

  // --- wheel globals from Part 4/earlier
  const wheel = $("wheel");
  const ctx = wheel?.getContext("2d");
  if(!wheel || !ctx) return;

  // IMPORTANT: we override the wheel draw/pick to fix pointer alignment
  const TAU = Math.PI * 2;
  let wheelAngle = 0;
  let wheelSpinning = false;

  function randFrom(arr){
    return arr[Math.floor(Math.random()*arr.length)];
  }
  function clamp(n,a,b){ return Math.max(a, Math.min(b, n)); }

  // Active wheel phase options
  let wheelOptions = [];
  let wheelLabel = "Wheel";

  function setWheelPhaseUI(title, hint){
    $("wheelTitle").textContent = title;
    $("wheelHint").textContent = hint || "Spin";
  }

  // Fix: draw slices so ‚Äúindex 0‚Äù is centered at TOP when wheelAngle = 0
  function drawWheel(){
    const w = wheel.width, h = wheel.height;
    ctx.clearRect(0,0,w,h);

    const cx=w/2, cy=h/2;
    const r=Math.min(cx,cy)-8;
    const n=Math.max(1, wheelOptions.length);
    const slice = TAU / n;

    // ring
    ctx.beginPath();
    ctx.arc(cx,cy,r+4,0,TAU);
    ctx.strokeStyle="rgba(255,255,255,.15)";
    ctx.lineWidth=10;
    ctx.stroke();

    const start = wheelAngle - Math.PI/2; // <-- key fix

    for(let i=0;i<n;i++){
      const a0 = start + i*slice;
      const a1 = start + (i+1)*slice;

      ctx.beginPath();
      ctx.moveTo(cx,cy);
      ctx.arc(cx,cy,r,a0,a1);
      ctx.closePath();
      ctx.fillStyle = i%2===0 ? "rgba(122,168,255,.14)" : "rgba(255,255,255,.06)";
      ctx.fill();

      // label
      const mid = (a0+a1)/2;
      ctx.save();
      ctx.translate(cx,cy);
      ctx.rotate(mid);
      ctx.textAlign="right";
      ctx.fillStyle="rgba(232,238,252,.92)";
      ctx.font="900 14px system-ui";
      const txt = String(wheelOptions[i] ?? "");
      ctx.fillText(txt, r-14, 6);
      ctx.restore();
    }

    // pointer at top
    ctx.beginPath();
    ctx.moveTo(cx, 10);
    ctx.lineTo(cx-12, 34);
    ctx.lineTo(cx+12, 34);
    ctx.closePath();
    ctx.fillStyle="rgba(255,204,102,.95)";
    ctx.fill();
  }

  // With our new draw logic, the selected index at the top pointer is:
  function pickFromWheel(){
    const n = Math.max(1, wheelOptions.length);
    const slice = TAU / n;
    const a = ((TAU - (wheelAngle % TAU)) % TAU); // (-wheelAngle) mod TAU
    const idx = Math.floor(a / slice) % n;
    return wheelOptions[idx];
  }

  async function spinWheelOnce(){
    if(wheelSpinning) return null;
    wheelSpinning = true;

    let v = 0.35 + Math.random()*0.35;
    const friction = 0.985 - Math.random()*0.006;
    const minTicks = 60 + Math.floor(Math.random()*40);
    let ticks=0;

    return await new Promise(resolve=>{
      function step(){
        ticks++;
        wheelAngle += v;
        v *= friction;
        drawWheel();

        if(ticks > minTicks && v < 0.01){
          wheelSpinning=false;
          const result = pickFromWheel();
          resolve(result);
          return;
        }
        requestAnimationFrame(step);
      }
      requestAnimationFrame(step);
    });
  }

  // --- build log
  function logBuild(msg){
    const el = $("buildLog");
    if(!el) return;
    const time = new Date().toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
    el.innerHTML = `<div><span class="muted">[${time}]</span> ${escapeHtml(msg)}</div>` + el.innerHTML;
  }

  // --- gain helpers (equipped + owned)
  function ensureOwned(c){
    c.owned ||= {};
    c.owned.races ||= [];
    c.owned.powers ||= [];
    c.owned.weapons ||= [];
    c.owned.armors ||= [];
    c.owned.curses ||= [];
  }
  function addUnique(arr, v){
    if(!v) return;
    if(!Array.isArray(arr)) return;
    if(!arr.includes(v)) arr.push(v);
  }

  function gainRace(c, race){
    if(!race) return;
    ensureOwned(c);
    addUnique(c.owned.races, race);

    // main race
    if(!c.race) c.race = race;

    // Hybrid logic: if the result is Hybrid, we store it as main race and spin 2 extra races later
    if(race === "Hybrid"){
      // keep as main race
      c.race = "Hybrid";
    }
  }

  function gainPower(c, p){
    if(!p || p==="No Power") return;
    ensureOwned(c);
    c.powers ||= [];
    addUnique(c.powers, p);
    addUnique(c.owned.powers, p);
  }
  function gainWeapon(c, w){
    if(!w || w==="No Weapon") return;
    ensureOwned(c);
    c.weapons ||= [];
    addUnique(c.weapons, w);
    addUnique(c.owned.weapons, w);
  }
  function gainArmor(c, a){
    if(!a || a==="No Armor") return;
    ensureOwned(c);
    c.armors ||= [];
    addUnique(c.armors, a);
    addUnique(c.owned.armors, a);
  }
  function gainCurse(c, cu){
    if(!cu || cu==="No Curse") return;
    ensureOwned(c);
    c.curses ||= [];
    addUnique(c.curses, cu);
    addUnique(c.owned.curses, cu);
  }
  function setClan(c, clan){
    c.clan = clan || "No Clan";
  }
  function setTrainer(c, tr){
    c.trainer = tr || "No Trainer";
  }
  function setMastery(c, m){
    c.powerMastery = m || "None";
  }
  function setTransform(c, t){
    c.transformation = t || "None";
    c.transformDetail = null;

    // If your Part 4 defines detail options, keep it random
    if(t === "Kaioken" && window.KAIOKEN_OPTIONS) c.transformDetail = {kind:"kaioken", value: randFrom(window.KAIOKEN_OPTIONS)};
    if(t === "Eight Gates" && window.GATES_OPTIONS) c.transformDetail = {kind:"gates", value: randFrom(window.GATES_OPTIONS)};
    if(t === "Super Saiyan" && window.SAIYAN_FORM_OPTIONS) c.transformDetail = {kind:"ssj", value: randFrom(window.SAIYAN_FORM_OPTIONS)};
    if(t === "Titan Transformation" && window.TITAN_TYPE_OPTIONS) c.transformDetail = {kind:"titan", value: randFrom(window.TITAN_TYPE_OPTIONS)};
    if(t === "Tailed Beast" && window.TAILED_BEAST_OPTIONS) c.transformDetail = {kind:"tailed", value: randFrom(window.TAILED_BEAST_OPTIONS)};
  }

  function rollStatsWords(c){
    // Choose from non-??? ranges
    c.strengthW = randFrom(STRENGTH_WORDS.slice(0, Math.max(1, STRENGTH_WORDS.length-1)));
    c.speedW = randFrom(SPEED_WORDS.slice(0, Math.max(1, SPEED_WORDS.length-1)));
    c.durabilityW = randFrom(DUR_WORDS.slice(0, Math.max(1, DUR_WORDS.length-1)));
    c.fightW = randFrom(FIGHT_WORDS.slice(0, Math.max(1, FIGHT_WORDS.length-1)));
    c.iqW = randFrom(IQ_WORDS.slice(0, Math.max(1, IQ_WORDS.length-1)));
    c.luckW = String(1+Math.floor(Math.random()*10));
  }

  // --- phases
  // IMPORTANT: finalize button is now OPTIONAL; the game auto-locks when finished.
  // If you click finalize early, we‚Äôll just lock the character where they are (but no respin allowed).
  const PHASES = [
    {
      key:"race",
      title:"Race",
      options:RACE_OPTIONS,
      apply:(c,val)=>{ gainRace(c, val); }
    },
    {
      key:"race_hybrid_1",
      title:"Hybrid Race #1",
      options:RACE_OPTIONS.filter(r=>r!=="Hybrid"),
      onlyIf:(c)=> c.race==="Hybrid" && (c.extraRaces||[]).length < 1,
      apply:(c,val)=>{
        c.extraRaces ||= [];
        c.extraRaces[0] = val;
        ensureOwned(c);
        addUnique(c.owned.races, val);
      }
    },
    {
      key:"race_hybrid_2",
      title:"Hybrid Race #2",
      options:RACE_OPTIONS.filter(r=>r!=="Hybrid"),
      onlyIf:(c)=> c.race==="Hybrid" && (c.extraRaces||[]).length < 2,
      apply:(c,val)=>{
        c.extraRaces ||= [];
        c.extraRaces[1] = val;
        ensureOwned(c);
        addUnique(c.owned.races, val);
      }
    },
    { key:"power", title:"Power", options:POWER_OPTIONS, apply:(c,val)=>gainPower(c,val) },
    { key:"weapon", title:"Weapon", options:WEAPON_OPTIONS, apply:(c,val)=>gainWeapon(c,val) },
    { key:"armor", title:"Armor", options:ARMOR_OPTIONS, apply:(c,val)=>gainArmor(c,val) },
    { key:"clan", title:"Clan", options:CLAN_OPTIONS, apply:(c,val)=>setClan(c,val) },
    { key:"trainer", title:"Trainer", options:TRAINER_OPTIONS, apply:(c,val)=>setTrainer(c,val) },
    { key:"mastery", title:"Power Mastery", options:POWER_MASTERY_OPTIONS, apply:(c,val)=>setMastery(c,val) },
    { key:"transform", title:"Transformation", options:TRANSFORM_OPTIONS, apply:(c,val)=>setTransform(c,val) },
    {
      key:"stats",
      title:"Stats Roll",
      options:["Roll Stats"],
      apply:(c)=>{ rollStatsWords(c); }
    },
    { key:"curse", title:"Curse", options:CURSE_OPTIONS, apply:(c,val)=>gainCurse(c,val) },
    { key:"done", title:"Done", options:["Done"], apply:()=>{} }
  ];

  function getNextPhase(c){
    // If already complete, done
    if(c.finalized || c.buildPhase === "complete") return PHASES.find(p=>p.key==="done");

    // Find current phase index
    const idx = Math.max(0, PHASES.findIndex(p=>p.key === (c.buildPhase || "race")));
    for(let i=idx; i<PHASES.length; i++){
      const phase = PHASES[i];
      if(phase.key === "done") return phase;
      if(phase.onlyIf && !phase.onlyIf(c)) continue;
      return phase;
    }
    return PHASES.find(p=>p.key==="done");
  }

  function advancePhase(c){
    const idx = PHASES.findIndex(p=>p.key === c.buildPhase);
    for(let i=idx+1; i<PHASES.length; i++){
      const phase = PHASES[i];
      if(phase.key === "done") return "done";
      if(phase.onlyIf && !phase.onlyIf(c)) continue;
      return phase.key;
    }
    return "done";
  }

  function lockCharacter(c){
    c.finalized = true;
    c.buildPhase = "complete";
    $("namedTag").textContent = c.name ? `Final: ${c.name}` : "Finalized";
    $("phaseTag").textContent = "Phase: Final";
    $("buildHint").textContent = "Character locked. This build cannot be rerolled.";
    disableSpin(true);
  }

  function disableSpin(disabled){
    const spinBtn = $("spinBtn");
    if(spinBtn){
      spinBtn.disabled = !!disabled;
      spinBtn.style.opacity = disabled ? "0.55" : "1";
      spinBtn.style.pointerEvents = disabled ? "none" : "auto";
    }
    const skipBtn = $("skipBtn");
    if(skipBtn){
      skipBtn.disabled = !!disabled;
      skipBtn.style.opacity = disabled ? "0.55" : "1";
      skipBtn.style.pointerEvents = disabled ? "none" : "auto";
    }
    const testFast = $("testFastBtn");
    if(testFast){
      testFast.disabled = !!disabled;
      testFast.style.opacity = disabled ? "0.55" : "1";
      testFast.style.pointerEvents = disabled ? "none" : "auto";
    }
  }

  // Update wheel to current phase
  function configureWheelForPhase(c){
    const phase = getNextPhase(c);

    if(phase.key === "done"){
      setWheelPhaseUI("Done", "Character locked");
      wheelOptions = ["Done"];
      wheelLabel = "Done";
      drawWheel();
      disableSpin(true);
      return;
    }

    wheelOptions = phase.options && phase.options.length ? phase.options : ["‚Äî"];
    wheelLabel = phase.title;
    setWheelPhaseUI(phase.title, "Spin");

    $("phaseTag").textContent = c.finalized ? "Phase: Final" : `Phase: ${phase.title}`;
    disableSpin(false);
    drawWheel();
  }

  async function doSpinAutoAdvance(){
    const c0 = window.getActiveChar();
    if(!c0){ toast("No character."); return; }

    // Always work on normalized copy, then commit by refreshUI (Part 6 wrapper commits)
    const c = window.state.character || c0;

    if(!c.alive){
      toast("That character is dead.");
      return;
    }
    if(c.finalized || c.buildPhase === "complete"){
      toast("This character is locked. Make a new one.");
      disableSpin(true);
      return;
    }

    const phase = getNextPhase(c);

    if(phase.key === "done"){
      lockCharacter(c);
      window.saveState();
      window.refreshUI?.();
      return;
    }

    configureWheelForPhase(c);

    // spin once
    const result = await spinWheelOnce();

    // apply result
    try{
      phase.apply(c, result);
    }catch(e){
      console.warn("Phase apply failed", e);
    }

    // log
    if(phase.key === "stats"){
      logBuild(`Stats ‚Üí Rolled (${c.strengthW}/${c.speedW}/${c.durabilityW}/${c.fightW}/${c.iqW}, Luck ${c.luckW})`);
    } else if(phase.key.startsWith("race_hybrid")){
      logBuild(`${phase.title} ‚Üí ${result}`);
    } else {
      logBuild(`${phase.title} ‚Üí ${result}`);
    }

    // advance
    c.buildPhase = advancePhase(c);

    // if we just finished curse, lock automatically
    if(c.buildPhase === "done"){
      lockCharacter(c);
      logBuild("Character locked (no rerolls).");
    } else {
      configureWheelForPhase(c);
    }

    window.saveState();
    window.refreshUI?.();
  }

  // --- wire buttons
  $("spinBtn")?.addEventListener("click", doSpinAutoAdvance);

  // Skip Phase (moves forward without gaining; useful for testing)
  $("skipBtn")?.addEventListener("click", ()=>{
    const c = window.getActiveChar();
    if(!c || c.finalized) return;
    c.buildPhase = advancePhase(c);
    logBuild(`Skipped ‚Üí ${c.buildPhase}`);
    window.saveState();
    window.refreshUI?.();
    configureWheelForPhase(c);
  });

  // Fast Spin (runs a few spins quickly, for testing)
  $("testFastBtn")?.addEventListener("click", async ()=>{
    const c = window.getActiveChar();
    if(!c || c.finalized) return;
    let guard = 0;
    while(!c.finalized && guard < 20){
      guard++;
      await doSpinAutoAdvance();
      await new Promise(r=>setTimeout(r, 30));
    }
  });

  // Finalize button now just locks immediately (no more respin after)
  $("finalizeBtn")?.addEventListener("click", ()=>{
    const c = window.getActiveChar();
    if(!c) return;
    if(c.finalized) return;
    lockCharacter(c);
    logBuild("Locked early by Finalize.");
    window.saveState();
    window.refreshUI?.();
  });

  // New Build must create NEW character (not replace current)
  $("newBuildBtn")?.addEventListener("click", ()=>{
    const c = window.createNewCharacter();
    // reset build log for the new character display
    $("buildLog").innerHTML = "";
    toast("New character created.");
    $("namedTag").textContent = "Not finalized";
    c.buildPhase = "race";
    c.finalized = false;
    window.saveState();
    window.refreshUI?.();
    configureWheelForPhase(c);
    window.showTab?.("build");
  });

  // ROSTER tab rendering
  function renderRoster(){
    const host = $("rosterList");
    const host2 = $("activeCharInfo");
    if(!host || !host2) return;

    const s = window.state;
    host.innerHTML = "";
    host2.innerHTML = "";

    const active = window.getActiveChar();

    const list = (s.roster || []).slice().sort((a,b)=>(b.createdAt||0)-(a.createdAt||0));
    if(!list.length){
      host.innerHTML = `<div class="muted">No characters yet.</div>`;
      return;
    }

    list.forEach(ch=>{
      const isActive = active && ch.id === active.id;
      const badge = ch.alive ? "üü¢" : "üî¥";
      const name = ch.name || "(Unnamed)";
      const races = [ch.race, ...(ch.extraRaces||[])].filter(Boolean).join(" + ") || "‚Äî";
      const phase = ch.finalized ? "Final" : (ch.buildPhase || "race");
      const line = document.createElement("div");
      line.className = "statLine";
      line.style.cursor = "pointer";
      line.innerHTML = `
        <div class="statKey">${badge} ${escapeHtml(name)} ${isActive ? "‚≠ê" : ""}</div>
        <div class="statVal">${escapeHtml(races)} <span class="muted">(${escapeHtml(phase)})</span></div>
      `;
      line.addEventListener("click", ()=>{
        window.state.activeCharId = ch.id;
        window.saveState();
        window.refreshUI?.();
        configureWheelForPhase(window.getActiveChar());
        toast("Switched active character.");
      });
      host.appendChild(line);
    });

    // Active detail
    if(active){
      const races = [active.race, ...(active.extraRaces||[])].filter(Boolean).join(" + ") || "‚Äî";
      const lines = [
        ["Name", active.name || "(Unnamed)"],
        ["Alive", active.alive ? "Yes" : "No"],
        ["Race", races],
        ["Phase", active.finalized ? "Final" : (active.buildPhase || "race")],
        ["Powers", (active.powers||[]).length ? active.powers.join(", ") : "‚Äî"],
        ["Weapons", (active.weapons||[]).length ? active.weapons.join(", ") : "‚Äî"],
        ["Armor", (active.armors||[]).length ? active.armors.join(", ") : "‚Äî"],
        ["Curses", (active.curses||[]).length ? active.curses.join(", ") : "‚Äî"],
      ];
      lines.forEach(([k,v])=>{
        const div = document.createElement("div");
        div.className = "statLine";
        div.innerHTML = `<div class="statKey">${escapeHtml(k)}</div><div class="statVal">${escapeHtml(v)}</div>`;
        host2.appendChild(div);
      });
    }
  }

  // Buttons on roster tab
  $("rosterNewBtn")?.addEventListener("click", ()=>{
    const c = window.createNewCharacter();
    $("buildLog").innerHTML = "";
    c.buildPhase = "race";
    c.finalized = false;
    window.saveState();
    window.refreshUI?.();
    configureWheelForPhase(c);
    window.showTab?.("build");
  });
  $("rosterGoBuildBtn")?.addEventListener("click", ()=>window.showTab?.("build"));

  // Hook refreshUI to also render roster (non-breaking)
  if(window.refreshUI){
    const _r = window.refreshUI;
    window.refreshUI = function(){
      _r();
      renderRoster();
    };
  }

  // Initial setup: ensure active character exists and configure wheel
  if(!window.getActiveChar()){
    window.createNewCharacter();
  }
  const c = window.getActiveChar();
  if(c){
    // if character was finalized, disable spinning
    if(c.finalized || c.buildPhase === "complete") disableSpin(true);
    else disableSpin(false);

    // ensure phase tag and wheel match
    configureWheelForPhase(c);
  }

  // If user switches tabs, roster should update
  renderRoster();
})();
</script>
<!-- ‚úÖ PART 8 / 12 ‚Äî Stability System + Sacrifice Mechanic + Stats Tab ‚ÄúOwned‚Äù Lists + Add ROSTER tab button (no HTML edits)
PASTE THIS DIRECTLY AFTER PART 7
-->
<script>
/* =========================================================
   PART 8: STABILITY + SACRIFICE + STATS TAB FINAL LAYOUT
   Adds:
   - Stability score (0‚Äì100) based on powers/curses/mastery/transform
   - ‚ÄúStabilize‚Äù button: sacrifice a power/weapon/curse to regain stability
   - Stats tab now shows: Equipped + Owned (all-time) + Stability panel
   - Dynamically adds a ROSTER tab button to the tabs row (no HTML re-paste)
========================================================= */
(function(){
  const $ = window.$ || ((id)=>document.getElementById(id));
  const escapeHtml = window.escapeHtml || ((s)=>String(s ?? "").replace(/[&<>"']/g, m=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[m])));
  const toast = window.toast || ((m)=>console.log(m));
  const openChoiceModal = window.openChoiceModal;

  if(!window.state || !window.saveState || !window.getActiveChar){
    console.warn("Part 8 missing required state helpers.");
    return;
  }

  // ---------- ensure ROSTER tab button exists ----------
  function ensureRosterTabButton(){
    const tabs = document.querySelector(".tabs");
    if(!tabs) return;

    // if already exists, don‚Äôt add again
    if(tabs.querySelector('.tab[data-tab="roster"]')) return;

    const rosterBtn = document.createElement("div");
    rosterBtn.className = "tab";
    rosterBtn.dataset.tab = "roster";
    rosterBtn.textContent = "ROSTER";

    // insert after PvP button (or at end)
    const pvpBtn = tabs.querySelector('.tab[data-tab="pvp"]');
    if(pvpBtn && pvpBtn.nextSibling){
      tabs.insertBefore(rosterBtn, pvpBtn.nextSibling);
    } else {
      tabs.insertBefore(rosterBtn, tabs.firstChild);
    }

    // wire click using existing showTab
    rosterBtn.addEventListener("click", ()=>window.showTab?.("roster"));
  }

  // ---------- stability rules ----------
  const STRONG_POWERS = new Set([
    "Immortal",
    "Regeneration",
    "Rinnegan",
    "Time Manipulation",
    "Gravity Manipulation",
    "Heavenly Restriction"
  ]);

  const DANGEROUS_CURSES = new Set([
    "Cursed Energy",
    "Madness",
    "Corruption",
    "Void Taint",
    "Bloodlust"
  ]);

  function masteryRank(m){
    const order = ["None","Dormant","Awakening","Controlled","Mastered","Planetary","Cosmic","Universal","Omnipotent"];
    const i = order.indexOf(m || "None");
    return i < 0 ? 0 : i;
  }

  function computeStability(char){
    // 100 = perfectly stable, 0 = totally unstable
    let s = 100;

    // mastery strain
    const r = masteryRank(char.powerMastery);
    if(r >= 6) s -= 10;           // Cosmic+
    if(r >= 7) s -= 15;           // Universal+
    if(r >= 8) s -= 20;           // Omnipotent

    // transformation strain (small, but adds up)
    const t = char.transformation || "None";
    if(t !== "None") s -= 8;
    if(t === "Kaioken") s -= 8;
    if(t === "Eight Gates") s -= 10;

    // curses are heavy strain
    const curses = (char.curses || []);
    curses.forEach(cu=>{
      s -= DANGEROUS_CURSES.has(cu) ? 18 : 10;
    });

    // strong powers strain (but some also stabilize)
    const powers = (char.powers || []);
    powers.forEach(p=>{
      if(STRONG_POWERS.has(p)) s -= 8;
    });

    // stabilizers (these offset the ‚Äútoo strong‚Äù problem)
    const hasImmortal = powers.includes("Immortal");
    const hasRegen = powers.includes("Regeneration");
    if(hasImmortal) s += 14;
    if(hasRegen) s += 10;

    // soul bonuses + adaptation make you ‚Äúused to it‚Äù
    const prog = window.state.progress || {};
    const souls = prog.soulsCaptured || 0;
    const adapt = prog.adaptationStacks || 0;
    s += Math.min(12, souls * 2);
    s += Math.min(12, adapt * 1);

    // clamp
    s = Math.max(0, Math.min(100, Math.round(s)));
    return s;
  }

  function isUnstable(char){
    return computeStability(char) < 45;
  }

  // ---------- sacrifice mechanics ----------
  function ensureOwned(char){
    char.owned ||= {};
    char.owned.races ||= [];
    char.owned.powers ||= [];
    char.owned.weapons ||= [];
    char.owned.armors ||= [];
    char.owned.curses ||= [];
  }

  function buildSacrificePool(char){
    // Only allow sacrificing ‚Äúmeaningful‚Äù things (not No Power/No Curse etc.)
    const pool = [];

    (char.powers || []).forEach(p=>{
      if(p && p !== "No Power") pool.push({ kind:"Power", value:p });
    });
    (char.weapons || []).forEach(w=>{
      if(w && w !== "No Weapon") pool.push({ kind:"Weapon", value:w });
    });
    (char.curses || []).forEach(cu=>{
      if(cu && cu !== "No Curse") pool.push({ kind:"Curse", value:cu });
    });

    return pool;
  }

  function removeOne(list, value){
    if(!Array.isArray(list)) return;
    const i = list.indexOf(value);
    if(i >= 0) list.splice(i, 1);
  }

  function applySacrifice(char, pick){
    char.sacrificed ||= [];
    char.sacrificed.push(`${pick.kind}:${pick.value}`);

    if(pick.kind === "Power")  removeOne(char.powers, pick.value);
    if(pick.kind === "Weapon") removeOne(char.weapons, pick.value);
    if(pick.kind === "Curse")  removeOne(char.curses, pick.value);

    // Optional: remove from owned too (true sacrifice)
    ensureOwned(char);
    if(pick.kind === "Power")  removeOne(char.owned.powers, pick.value);
    if(pick.kind === "Weapon") removeOne(char.owned.weapons, pick.value);
    if(pick.kind === "Curse")  removeOne(char.owned.curses, pick.value);

    // Recovery bonus
    char.stabilityBonus = (char.stabilityBonus || 0) + 22;

    // Small cleanse: if you sacrificed a curse, bonus is bigger
    if(pick.kind === "Curse") char.stabilityBonus += 10;
  }

  // Patch stability to include stabilityBonus
  const _computeStability = computeStability;
  function computeStabilityWithBonus(char){
    let s = _computeStability(char);
    s = Math.max(0, Math.min(100, s + (char.stabilityBonus || 0)));
    return s;
  }

  async function stabilizeFlow(){
    const char = window.getActiveChar();
    if(!char) return;

    const pool = buildSacrificePool(char);
    if(pool.length === 0){
      toast("Nothing to sacrifice.");
      return;
    }
    if(typeof openChoiceModal !== "function"){
      toast("Choice modal missing.");
      return;
    }

    const options = pool.map((x)=>({ label:`Sacrifice ${x.kind}: ${x.value}`, value:`${x.kind}::${x.value}` }));

    const picked = await openChoiceModal({
      title:"Stabilize",
      sub:"Sacrifice one trait to regain stability. This is permanent.",
      options
    });
    if(!picked) return;

    const [kind, value] = picked.split("::");
    const pick = { kind, value };
    applySacrifice(char, pick);

    window.saveState();
    window.refreshUI?.();

    toast(`Stabilized by sacrificing ${value}.`);
  }

  // ---------- Stats tab ‚Äúfinalized layout‚Äù injection ----------
  function ensureStatsPanels(){
    const statsTab = $("tab-stats");
    if(!statsTab) return;

    // avoid duplicates
    if($("ownedPanel")) return;

    // Add a third card to the grid (Owned + Stability)
    const card = document.createElement("div");
    card.className = "card";
    card.id = "ownedPanel";
    card.innerHTML = `
      <h2>Inventory</h2>
      <div class="muted" style="margin-bottom:10px">
        Equipped = what you‚Äôre using right now. Owned = everything you‚Äôve ever obtained (unless sacrificed).
      </div>

      <div class="statList" id="equippedMini"></div>

      <h2 style="margin-top:12px">Owned</h2>
      <div class="statList" id="ownedList"></div>

      <h2 style="margin-top:12px">Stability</h2>
      <div class="statList" id="stabilityBox"></div>
      <div class="row" style="margin-top:10px">
        <button id="stabilizeBtn" class="btn bad">Stabilize (Sacrifice)</button>
      </div>
    `;
    statsTab.appendChild(card);

    // hook stabilize
    $("stabilizeBtn")?.addEventListener("click", stabilizeFlow);
  }

  function renderStatsExtras(){
    ensureStatsPanels();
    const char = window.getActiveChar();
    if(!char) return;

    // Equipped mini
    const eq = $("equippedMini");
    if(eq){
      eq.innerHTML = "";
      const rows = [
        ["Race", [char.race, ...(char.extraRaces||[])].filter(Boolean).join(" + ") || "‚Äî"],
        ["Power(s)", (char.powers||[]).length ? char.powers.join(", ") : "‚Äî"],
        ["Weapon(s)", (char.weapons||[]).length ? char.weapons.join(", ") : "‚Äî"],
        ["Armor(s)", (char.armors||[]).length ? char.armors.join(", ") : "‚Äî"],
        ["Curse(s)", (char.curses||[]).length ? char.curses.join(", ") : "‚Äî"],
      ];
      rows.forEach(([k,v])=>{
        const div = document.createElement("div");
        div.className = "statLine";
        div.innerHTML = `<div class="statKey">${escapeHtml(k)}</div><div class="statVal">${escapeHtml(v)}</div>`;
        eq.appendChild(div);
      });
    }

    // Owned list
    const owned = $("ownedList");
    if(owned){
      ensureOwned(char);

      const rows = [
        ["Owned Races", (char.owned.races||[]).length ? char.owned.races.join(", ") : "‚Äî"],
        ["Owned Powers", (char.owned.powers||[]).length ? char.owned.powers.join(", ") : "‚Äî"],
        ["Owned Weapons", (char.owned.weapons||[]).length ? char.owned.weapons.join(", ") : "‚Äî"],
        ["Owned Armor", (char.owned.armors||[]).length ? char.owned.armors.join(", ") : "‚Äî"],
        ["Owned Curses", (char.owned.curses||[]).length ? char.owned.curses.join(", ") : "‚Äî"],
        ["Sacrificed", (char.sacrificed||[]).length ? char.sacrificed.join(", ") : "‚Äî"],
      ];

      owned.innerHTML = "";
      rows.forEach(([k,v])=>{
        const div = document.createElement("div");
        div.className = "statLine";
        div.innerHTML = `<div class="statKey">${escapeHtml(k)}</div><div class="statVal">${escapeHtml(v)}</div>`;
        owned.appendChild(div);
      });
    }

    // Stability box
    const stBox = $("stabilityBox");
    const stabBtn = $("stabilizeBtn");
    if(stBox){
      const s = computeStabilityWithBonus(char);
      const unstable = s < 45;

      stBox.innerHTML = "";
      const a = document.createElement("div");
      a.className = "statLine";
      a.innerHTML = `<div class="statKey">Stability</div><div class="statVal">${s}/100 ${unstable ? "<span class='muted'>(UNSTABLE)</span>" : "<span class='muted'>(Stable)</span>"}</div>`;
      stBox.appendChild(a);

      const b = document.createElement("div");
      b.className = "statLine";
      b.innerHTML = `<div class="statKey">Effect</div><div class="statVal">${unstable ? "Risk: misfires / backlash (coming soon)" : "No penalty"}</div>`;
      stBox.appendChild(b);

      if(stabBtn){
        stabBtn.style.display = unstable ? "inline-flex" : "none";
      }
    }
  }

  // ---------- Patch refreshUI to render extras + ensure tab button ----------
  if(window.refreshUI){
    const _r = window.refreshUI;
    window.refreshUI = function(){
      _r();
      ensureRosterTabButton();
      renderStatsExtras();
    };
  }

  // ---------- Extend showTab so it knows about roster ----------
  if(window.showTab){
    const _show = window.showTab;
    window.showTab = function(key){
      // original handles build/stats/pve/pvp ‚Äî we add roster
      ["build","stats","pve","pvp","roster"].forEach(k=>{
        const sec = $("tab-"+k);
        if(sec) sec.classList.toggle("hidden", k!==key);
        const btn = document.querySelector(`.tab[data-tab="${k}"]`);
        if(btn) btn.classList.toggle("active", k===key);
      });
      window.state.ui ||= {};
      window.state.ui.activeTab = key;
      window.saveState();
    };
  }

  // ---------- First run ----------
  ensureRosterTabButton();
  renderStatsExtras();
})();
</script>
<!-- ‚úÖ PART 9 / 12 ‚Äî ROSTER TAB (HTML injected) + Death/Strikes (PvP=2, PvE=1) + New Build makes NEW character + Remove Reset button
PASTE THIS DIRECTLY AFTER PART 8
-->
<script>
/* =========================================================
   PART 9: ROSTER + PERMA-DEATH + STRIKES + NEW BUILD FLOW
   Adds:
   - ROSTER tab section (injected into DOM) with character list + select
   - New Build creates a NEW character (does NOT overwrite current)
   - Death rules: PvE loss = 1 strike, PvP loss = 1 strike; at strikes limit => dead
       PvE strike limit: 1
       PvP strike limit: 2
   - Only way a character is removed from play is death
   - Hides Reset button entirely (no hard reset button in UI)
========================================================= */
(function(){
  const $ = window.$ || ((id)=>document.getElementById(id));
  const escapeHtml = window.escapeHtml || ((s)=>String(s ?? "").replace(/[&<>"']/g, m=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[m])));
  const toast = window.toast || ((m)=>console.log(m));

  if(!window.state || !window.saveState){
    console.warn("Part 9 missing required state/save.");
    return;
  }

  // ---------------------------------------------------------
  // 1) STATE: add roster container if missing
  // ---------------------------------------------------------
  function ensureRosterState(){
    window.state.roster ||= { activeId:null, chars:[] };
    if(!Array.isArray(window.state.roster.chars)) window.state.roster.chars = [];
  }

  // Strong-ish unique id
  function makeId(){
    return "c_" + Math.random().toString(36).slice(2,9) + "_" + Date.now().toString(36);
  }

  // Base character template (compatible with earlier parts)
  function newCharacterTemplate(){
    return {
      id: makeId(),
      createdAt: Date.now(),
      dead: false,

      // strikes:
      strikesPvE: 0,
      strikesPvP: 0,

      // build data
      finalized: false,
      name: "",
      race: null,
      extraRaces: [],      // hybrid extra races (Part 10 will use)
      powers: [],
      weapons: [],
      armors: [],
      curses: [],
      clan: "No Clan",
      trainer: "No Trainer",
      powerMastery: "None",
      transformation: "None",
      transformDetail: null,

      strengthW: "Average",
      speedW: "Average",
      durabilityW: "Average",
      fightW: "Average",
      iqW: "Average",
      luckW: "5",

      // ‚Äúowned‚Äù inventory (Part 8 uses it)
      owned: { races:[], powers:[], weapons:[], armors:[], curses:[] },
      sacrificed: [],
      stabilityBonus: 0,
    };
  }

  // Convert old single-character save into roster once
  function migrateSingleToRosterIfNeeded(){
    ensureRosterState();

    // if we already have roster chars, skip
    if(window.state.roster.chars.length) return;

    // if older save uses state.character, migrate it
    if(window.state.character){
      const old = window.state.character;
      const c = newCharacterTemplate();

      // copy fields we know
      Object.assign(c, {
        finalized: !!old.finalized,
        name: old.name || "",
        race: old.race || null,
        powers: Array.isArray(old.powers) ? old.powers.slice() : [],
        weapons: Array.isArray(old.weapons) ? old.weapons.slice() : [],
        armors: Array.isArray(old.armors) ? old.armors.slice() : [],
        curses: Array.isArray(old.curses) ? old.curses.slice() : [],
        clan: old.clan || "No Clan",
        trainer: old.trainer || "No Trainer",
        powerMastery: old.powerMastery || "None",
        transformation: old.transformation || "None",
        transformDetail: old.transformDetail || null,

        strengthW: old.strengthW || "Average",
        speedW: old.speedW || "Average",
        durabilityW: old.durabilityW || "Average",
        fightW: old.fightW || "Average",
        iqW: old.iqW || "Average",
        luckW: old.luckW || "5",
      });

      // owned tracking if existed
      if(old.owned) c.owned = { ...c.owned, ...old.owned };
      if(old.sacrificed) c.sacrificed = old.sacrificed.slice ? old.sacrificed.slice() : [];
      if(old.stabilityBonus) c.stabilityBonus = old.stabilityBonus;

      // Ensure owned includes current equipped
      (c.race ? [c.race] : []).forEach(r=>{ if(!c.owned.races.includes(r)) c.owned.races.push(r); });
      (c.powers||[]).forEach(p=>{ if(p && !c.owned.powers.includes(p)) c.owned.powers.push(p); });
      (c.weapons||[]).forEach(w=>{ if(w && !c.owned.weapons.includes(w)) c.owned.weapons.push(w); });
      (c.armors||[]).forEach(a=>{ if(a && !c.owned.armors.includes(a)) c.owned.armors.push(a); });
      (c.curses||[]).forEach(cu=>{ if(cu && !c.owned.curses.includes(cu)) c.owned.curses.push(cu); });

      window.state.roster.chars.push(c);
      window.state.roster.activeId = c.id;

      // Keep a copy but stop using state.character going forward
      // (we will leave it to avoid breaking older code, but our getters will override)
      toast("Roster created from your saved character.");
      window.saveState();
    } else {
      // no prior char ‚Äî create starter
      const c = newCharacterTemplate();
      window.state.roster.chars.push(c);
      window.state.roster.activeId = c.id;
      window.saveState();
    }
  }

  // ---------------------------------------------------------
  // 2) ACTIVE CHARACTER ACCESSORS (global)
  // ---------------------------------------------------------
  function getCharById(id){
    ensureRosterState();
    return window.state.roster.chars.find(x=>x.id===id) || null;
  }

  function getActiveChar(){
    ensureRosterState();
    let c = getCharById(window.state.roster.activeId);
    if(!c){
      c = window.state.roster.chars.find(x=>!x.dead) || null;
      if(c) window.state.roster.activeId = c.id;
    }
    return c;
  }

  function setActiveChar(id){
    const c = getCharById(id);
    if(!c){ toast("Character not found."); return; }
    if(c.dead){ toast("That character is dead."); return; }
    window.state.roster.activeId = c.id;
    window.saveState();
    window.refreshUI?.();
    toast(`Selected: ${c.name || c.race || "Character"}`);
  }

  // expose (Part 8 expects getActiveChar)
  window.getActiveChar = getActiveChar;
  window.setActiveChar = setActiveChar;

  // Keep state.character synced for older functions that still read it
  function syncLegacyCharacter(){
    const c = getActiveChar();
    if(c) window.state.character = c;
  }

  // ---------------------------------------------------------
  // 3) ROSTER TAB HTML injection
  // ---------------------------------------------------------
  function ensureRosterTabSection(){
    if($("tab-roster")) return;

    const app = document.querySelector(".app");
    if(!app) return;

    // Insert after build/stats/pve/pvp sections if possible
    const after = $("tab-pvp") || $("tab-pve") || $("tab-stats") || $("tab-build");
    const sec = document.createElement("section");
    sec.id = "tab-roster";
    sec.className = "grid hidden";
    sec.innerHTML = `
      <div class="card">
        <h2>Roster</h2>
        <div class="muted" style="margin-bottom:10px">
          New Build makes a new character. Characters only leave your roster if they die.
        </div>

        <div class="row" style="margin-bottom:10px">
          <button id="rosterNewBtn" class="btn good">New Character</button>
        </div>

        <div id="rosterList" class="statList"></div>
      </div>

      <div class="card">
        <h2>Selected</h2>
        <div id="rosterDetail" class="statList"></div>
        <div class="muted" style="margin-top:10px">
          PvE deaths: 1 strike ‚Ä¢ PvP deaths: 2 strikes
        </div>
      </div>
    `;

    // put it after the last existing section
    if(after && after.parentNode){
      after.parentNode.insertBefore(sec, after.nextSibling);
    } else {
      app.appendChild(sec);
    }

    $("rosterNewBtn")?.addEventListener("click", ()=>{
      createNewCharacterAndSetActive();
    });
  }

  function renderRoster(){
    ensureRosterState();
    ensureRosterTabSection();

    const list = $("rosterList");
    const detail = $("rosterDetail");
    if(!list || !detail) return;

    const chars = window.state.roster.chars.slice().sort((a,b)=>b.createdAt-a.createdAt);
    const activeId = window.state.roster.activeId;

    list.innerHTML = "";
    chars.forEach(c=>{
      const div = document.createElement("div");
      div.className = "statLine";
      const title = c.name || c.race || "Unbuilt";
      const status = c.dead
        ? "DEAD"
        : (c.id===activeId ? "ACTIVE" : "Alive");

      div.innerHTML = `
        <div class="statKey">
          ${escapeHtml(title)} <span class="muted">(${escapeHtml(status)})</span>
        </div>
        <div class="statVal">
          ${c.dead ? "‚ò†Ô∏è" : "üëâ"}
        </div>
      `;
      div.style.cursor = c.dead ? "not-allowed" : "pointer";
      if(!c.dead){
        div.addEventListener("click", ()=>setActiveChar(c.id));
      }
      list.appendChild(div);
    });

    const a = getActiveChar();
    detail.innerHTML = "";
    if(!a){
      const div = document.createElement("div");
      div.className = "statLine";
      div.innerHTML = `<div class="statKey">No active character</div><div class="statVal">‚Äî</div>`;
      detail.appendChild(div);
      return;
    }

    const rows = [
      ["Name", a.name || "‚Äî"],
      ["Race", [a.race, ...(a.extraRaces||[])].filter(Boolean).join(" + ") || "‚Äî"],
      ["Finalized", a.finalized ? "Yes" : "No"],
      ["PvE Strikes", `${a.strikesPvE||0}/1`],
      ["PvP Strikes", `${a.strikesPvP||0}/2`],
      ["Status", a.dead ? "DEAD" : "Alive"],
    ];

    rows.forEach(([k,v])=>{
      const div = document.createElement("div");
      div.className = "statLine";
      div.innerHTML = `<div class="statKey">${escapeHtml(k)}</div><div class="statVal">${escapeHtml(v)}</div>`;
      detail.appendChild(div);
    });
  }

  // ---------------------------------------------------------
  // 4) NEW BUILD becomes NEW CHARACTER (no overwrite)
  // ---------------------------------------------------------
  function createNewCharacterAndSetActive(){
    ensureRosterState();
    const c = newCharacterTemplate();

    // If there is a "newBuild" generator from earlier parts, use it but target this new char
    // We'll mimic what your earlier Part 4 did (randomize non-race stuff) if constants exist.
    const randFrom = window.randomFrom || ((arr)=>arr[Math.floor(Math.random()*arr.length)]);

    // optional option arrays
    const CLAN_OPTIONS = window.CLAN_OPTIONS || ["No Clan"];
    const TRAINER_OPTIONS = window.TRAINER_OPTIONS || ["No Trainer"];
    const POWER_MASTERY_OPTIONS = window.POWER_MASTERY_OPTIONS || ["None"];
    const TRANSFORM_OPTIONS = window.TRANSFORM_OPTIONS || ["None"];
    const KAIOKEN_OPTIONS = window.KAIOKEN_OPTIONS || ["X2"];
    const GATES_OPTIONS = window.GATES_OPTIONS || ["First Gate"];
    const SAIYAN_FORM_OPTIONS = window.SAIYAN_FORM_OPTIONS || ["SSJ1"];
    const TITAN_TYPE_OPTIONS = window.TITAN_TYPE_OPTIONS || ["Pure Titan"];
    const TAILED_BEAST_OPTIONS = window.TAILED_BEAST_OPTIONS || ["1 Tail"];

    const STRENGTH_WORDS = window.STRENGTH_WORDS || ["Average"];
    const SPEED_WORDS = window.SPEED_WORDS || ["Average"];
    const DUR_WORDS = window.DUR_WORDS || ["Average"];
    const FIGHT_WORDS = window.FIGHT_WORDS || ["Average"];
    const IQ_WORDS = window.IQ_WORDS || ["Average"];

    const POWER_OPTIONS = window.POWER_OPTIONS || ["No Power"];
    const WEAPON_OPTIONS = window.WEAPON_OPTIONS || ["No Weapon"];
    const ARMOR_OPTIONS = window.ARMOR_OPTIONS || ["No Armor"];

    // Randomize non-race build pieces; race is still wheel-driven
    c.clan = randFrom(CLAN_OPTIONS);
    c.trainer = randFrom(TRAINER_OPTIONS);
    c.powerMastery = randFrom(POWER_MASTERY_OPTIONS);
    c.transformation = randFrom(TRANSFORM_OPTIONS);

    c.strengthW = randFrom(STRENGTH_WORDS.slice(0, Math.max(1, STRENGTH_WORDS.length-1)));
    c.speedW = randFrom(SPEED_WORDS.slice(0, Math.max(1, SPEED_WORDS.length-1)));
    c.durabilityW = randFrom(DUR_WORDS.slice(0, Math.max(1, DUR_WORDS.length-1)));
    c.fightW = randFrom(FIGHT_WORDS.slice(0, Math.max(1, FIGHT_WORDS.length-1)));
    c.iqW = randFrom(IQ_WORDS.slice(0, Math.max(1, IQ_WORDS.length-1)));
    c.luckW = String(1 + Math.floor(Math.random()*10));

    // roll some gear (filters remove No X)
    if(Math.random()<0.85) c.powers.push(randFrom(POWER_OPTIONS));
    if(Math.random()<0.85) c.weapons.push(randFrom(WEAPON_OPTIONS));
    if(Math.random()<0.75) c.armors.push(randFrom(ARMOR_OPTIONS));

    c.powers = c.powers.filter(x=>x && x!=="No Power");
    c.weapons = c.weapons.filter(x=>x && x!=="No Weapon");
    c.armors = c.armors.filter(x=>x && x!=="No Armor");

    // transform details
    c.transformDetail = null;
    if(c.transformation==="Kaioken") c.transformDetail={kind:"kaioken", value:randFrom(KAIOKEN_OPTIONS)};
    if(c.transformation==="Eight Gates") c.transformDetail={kind:"gates", value:randFrom(GATES_OPTIONS)};
    if(c.transformation==="Super Saiyan") c.transformDetail={kind:"ssj", value:randFrom(SAIYAN_FORM_OPTIONS)};
    if(c.transformation==="Titan Transformation") c.transformDetail={kind:"titan", value:randFrom(TITAN_TYPE_OPTIONS)};
    if(c.transformation==="Tailed Beast") c.transformDetail={kind:"tailed", value:randFrom(TAILED_BEAST_OPTIONS)};

    // owned gets equipped items (race will be added when spun)
    c.owned.powers = Array.from(new Set(c.powers));
    c.owned.weapons = Array.from(new Set(c.weapons));
    c.owned.armors = Array.from(new Set(c.armors));

    window.state.roster.chars.push(c);
    window.state.roster.activeId = c.id;

    // switch user back to BUILD tab
    window.showTab?.("build");

    window.saveState();
    window.refreshUI?.();

    toast("New character created. Spin to choose their race.");
  }

  // Intercept existing New Build button to create NEW character instead
  function overrideNewBuildButton(){
    const btn = $("newBuildBtn");
    if(!btn) return;

    // remove existing listeners by cloning
    const clone = btn.cloneNode(true);
    btn.parentNode.replaceChild(clone, btn);

    clone.addEventListener("click", ()=>{
      createNewCharacterAndSetActive();
      renderRoster();
    });
  }

  // ---------------------------------------------------------
  // 5) Remove/Hide Reset button
  // ---------------------------------------------------------
  function hideResetButton(){
    const r = $("resetBtn");
    if(r){
      r.style.display = "none";
      r.disabled = true;
    }
  }

  // ---------------------------------------------------------
  // 6) Finalize + Spin lock (can‚Äôt change race after finalized)
  // ---------------------------------------------------------
  function lockSpinAfterFinalize(){
    // wrap spinWheel if present
    if(typeof window.spinWheel === "function" && !window.__spinWrapped){
      const _spin = window.spinWheel;
      window.spinWheel = async function(){
        const c = getActiveChar();
        if(c && c.finalized){
          toast("This character is finalized. No re-spins.");
          return;
        }
        return _spin();
      };
      window.__spinWrapped = true;
    }

    // wrap finalizeBuild to ensure it finalizes active char
    if(typeof window.finalizeBuild === "function" && !window.__finalWrapped){
      const _fin = window.finalizeBuild;
      window.finalizeBuild = function(){
        syncLegacyCharacter();
        return _fin();
      };
      window.__finalWrapped = true;
    }
  }

  // ---------------------------------------------------------
  // 7) Death/Strikes hooks for PvE/PvP losses
  // ---------------------------------------------------------
  function markDeadIfNeeded(char){
    const deadPvE = (char.strikesPvE||0) >= 1;
    const deadPvP = (char.strikesPvP||0) >= 2;
    if(deadPvE || deadPvP){
      char.dead = true;
      char.finalized = true; // lock it forever

      // if this was active, move active to next alive
      if(window.state.roster.activeId === char.id){
        const nextAlive = window.state.roster.chars.find(x=>!x.dead && x.id!==char.id) || null;
        window.state.roster.activeId = nextAlive ? nextAlive.id : char.id;
      }
      toast("Your character has died. ‚ò†Ô∏è");
    }
  }

  function hookBattleLosses(){
    // Wrap startPVE / startPVP: on defeat, add strikes
    if(typeof window.startPVE === "function" && !window.__pveWrapped){
      const _pve = window.startPVE;
      window.startPVE = async function(){
        syncLegacyCharacter();
        const beforeId = getActiveChar()?.id;
        const res = await _pve(); // original logs defeat/victory internally

        // detect defeat: check last log line (lightweight)
        const log = $("pveLog")?.textContent || "";
        const defeated = /Defeat\./i.test(log);

        if(defeated){
          const c = getCharById(beforeId);
          if(c && !c.dead){
            c.strikesPvE = (c.strikesPvE||0) + 1; // PvE = 1 strike death
            markDeadIfNeeded(c);
            window.saveState();
            window.refreshUI?.();
            renderRoster();
          }
        }
        return res;
      };
      window.__pveWrapped = true;
    }

    if(typeof window.startPVP === "function" && !window.__pvpWrapped){
      const _pvp = window.startPVP;
      window.startPVP = async function(){
        syncLegacyCharacter();
        const beforeId = getActiveChar()?.id;
        const res = await _pvp();

        const log = $("pvpLog")?.textContent || "";
        const defeated = /Defeat\./i.test(log);

        if(defeated){
          const c = getCharById(beforeId);
          if(c && !c.dead){
            c.strikesPvP = (c.strikesPvP||0) + 1; // PvP = 2 strikes total
            markDeadIfNeeded(c);
            window.saveState();
            window.refreshUI?.();
            renderRoster();
          }
        }
        return res;
      };
      window.__pvpWrapped = true;
    }
  }

  // ---------------------------------------------------------
  // 8) Track ‚Äúowned‚Äù whenever player gains stuff
  // ---------------------------------------------------------
  function ensureOwned(char){
    char.owned ||= { races:[], powers:[], weapons:[], armors:[], curses:[] };
    char.owned.races ||= [];
    char.owned.powers ||= [];
    char.owned.weapons ||= [];
    char.owned.armors ||= [];
    char.owned.curses ||= [];
  }

  function trackOwnedFromChar(char){
    ensureOwned(char);
    if(char.race && !char.owned.races.includes(char.race)) char.owned.races.push(char.race);
    (char.extraRaces||[]).forEach(r=>{ if(r && !char.owned.races.includes(r)) char.owned.races.push(r); });
    (char.powers||[]).forEach(p=>{ if(p && !char.owned.powers.includes(p)) char.owned.powers.push(p); });
    (char.weapons||[]).forEach(w=>{ if(w && !char.owned.weapons.includes(w)) char.owned.weapons.push(w); });
    (char.armors||[]).forEach(a=>{ if(a && !char.owned.armors.includes(a)) char.owned.armors.push(a); });
    (char.curses||[]).forEach(cu=>{ if(cu && !char.owned.curses.includes(cu)) char.owned.curses.push(cu); });
  }

  // Hook race pick in spinWheel‚Äôs completion by patching refreshUI + sync
  if(window.refreshUI && !window.__rosterRefreshWrapped){
    const _r = window.refreshUI;
    window.refreshUI = function(){
      syncLegacyCharacter();
      const c = getActiveChar();
      if(c) trackOwnedFromChar(c);

      _r();
      renderRoster();
    };
    window.__rosterRefreshWrapped = true;
  }

  // ---------------------------------------------------------
  // INIT
  // ---------------------------------------------------------
  ensureRosterState();
  migrateSingleToRosterIfNeeded();
  ensureRosterTabSection();
  hideResetButton();
  overrideNewBuildButton();
  lockSpinAfterFinalize();
  hookBattleLosses();

  // Ensure legacy pointers
  syncLegacyCharacter();

  // If no active tab set, default build
  window.state.ui ||= {};
  if(!window.state.ui.activeTab) window.state.ui.activeTab = "build";
  window.saveState();

  // Render roster now
  renderRoster();
})();
</script>
<!-- ‚úÖ PART 10 / 12 ‚Äî PHASE WHEEL (auto-advance) + HYBRID (spin 2 extra races) + POINTER FIX + ROSTER TAB BUTTON
PASTE THIS DIRECTLY AFTER PART 9
-->
<script>
/* =========================================================
   PART 10: PHASE WHEEL SYSTEM + HYBRID + POINTER FIX + ROSTER TAB
   Fixes/Adds:
   ‚úÖ Wheel auto-advances through phases (Race -> Power -> Weapon -> Armor -> Clan -> Trainer -> Mastery -> Transform)
   ‚úÖ Hybrid race: immediately forces 2 EXTRA race spins (stored as extraRaces)
   ‚úÖ Pointer selection math fixed (top arrow actually selects top slice)
   ‚úÖ Adds "ROSTER" tab button + patches showTab() to support it
   ‚úÖ Skip Phase + Fast Spin buttons now work
========================================================= */
(function(){
  const $ = window.$ || ((id)=>document.getElementById(id));
  const toast = window.toast || ((m)=>console.log(m));
  const escapeHtml = window.escapeHtml || ((s)=>String(s ?? "").replace(/[&<>"']/g, m=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[m])));

  if(!window.state || !window.saveState){
    console.warn("Part 10 missing required state/save.");
    return;
  }
  if(!window.getActiveChar){
    console.warn("Part 10 requires Part 9 (roster).");
    return;
  }

  // ---------------------------------------------------------
  // 1) Ensure ROSTER tab button exists + showTab supports it
  // ---------------------------------------------------------
  function ensureRosterTabButton(){
    const tabs = document.querySelector(".tabs");
    if(!tabs) return;

    if(!tabs.querySelector('.tab[data-tab="roster"]')){
      const btn = document.createElement("div");
      btn.className = "tab";
      btn.dataset.tab = "roster";
      btn.textContent = "ROSTER";
      tabs.insertBefore(btn, tabs.querySelector("#phaseTag") || null);
      btn.addEventListener("click", ()=>window.showTab?.("roster"));
    }
  }

  function patchShowTabForRoster(){
    if(typeof window.showTab !== "function" || window.__showTabRosterPatched) return;

    const _showTab = window.showTab;
    window.showTab = function(key){
      // call original for known tabs
      _showTab(key);

      // manually handle roster section + tab state (original hardcoded list)
      const rosterSec = $("tab-roster");
      if(rosterSec){
        // hide if not roster
        rosterSec.classList.toggle("hidden", key !== "roster");
      }
      // set active tab styling for roster button
      document.querySelectorAll('.tab[data-tab]').forEach(t=>{
        t.classList.toggle("active", t.dataset.tab === key);
      });

      window.state.ui ||= {};
      window.state.ui.activeTab = key;
      window.saveState?.();
    };

    window.__showTabRosterPatched = true;
  }

  ensureRosterTabButton();
  patchShowTabForRoster();

  // ---------------------------------------------------------
  // 2) Phase definitions (what the wheel is currently spinning)
  // ---------------------------------------------------------
  const PHASES = [
    { key:"race",   title:"Race",   options: ()=>window.RACE_OPTIONS || [] },
    { key:"power",  title:"Power",  options: ()=>window.POWER_OPTIONS || [] },
    { key:"weapon", title:"Weapon", options: ()=>window.WEAPON_OPTIONS || [] },
    { key:"armor",  title:"Armor",  options: ()=>window.ARMOR_OPTIONS || [] },
    { key:"clan",   title:"Clan",   options: ()=>window.CLAN_OPTIONS || [] },
    { key:"trainer",title:"Trainer",options: ()=>window.TRAINER_OPTIONS || [] },
    { key:"mastery",title:"Mastery",options: ()=>window.POWER_MASTERY_OPTIONS || [] },
    { key:"transform",title:"Transform",options: ()=>window.TRANSFORM_OPTIONS || [] },
  ];

  function ensurePhaseState(){
    window.state.ui ||= {};
    if(!window.state.ui.phaseKey) window.state.ui.phaseKey = "race";
    if(!Number.isFinite(window.state.ui.hybridRemaining)) window.state.ui.hybridRemaining = 0;
  }

  function getPhaseIndex(){
    ensurePhaseState();
    const idx = PHASES.findIndex(p=>p.key === window.state.ui.phaseKey);
    return idx >= 0 ? idx : 0;
  }

  function setPhase(key){
    ensurePhaseState();
    window.state.ui.phaseKey = key;
    window.saveState();

    const p = PHASES.find(x=>x.key===key) || PHASES[0];
    $("wheelTitle") && ($("wheelTitle").textContent = p.title);
    $("wheelHint") && ($("wheelHint").textContent = "Spin to roll");
    $("buildHint") && ($("buildHint").textContent = `Spin for ${p.title}. Auto-advances.`);
    $("phaseTag") && ($("phaseTag").textContent = `Phase: ${p.title}`);
  }

  function advancePhase(){
    const idx = getPhaseIndex();
    const next = PHASES[Math.min(PHASES.length-1, idx+1)];
    setPhase(next.key);
  }

  function resetPhasesForNewCharacter(){
    setPhase("race");
    window.state.ui.hybridRemaining = 0;
    window.saveState();
  }

  // If Part 9 created a new character, make sure phases reset
  if(typeof window.createNewCharacterAndSetActive === "function" && !window.__newCharPhaseWrapped){
    const _c = window.createNewCharacterAndSetActive;
    window.createNewCharacterAndSetActive = function(){
      const res = _c();
      resetPhasesForNewCharacter();
      return res;
    };
    window.__newCharPhaseWrapped = true;
  } else {
    // fallback: if active char has no race, force race phase
    const a = window.getActiveChar();
    if(a && !a.race) setPhase("race");
  }

  // ---------------------------------------------------------
  // 3) Pointer fix + wheel picker (top arrow = selected slice)
  // ---------------------------------------------------------
  const wheel = $("wheel");
  const ctx = wheel?.getContext("2d");
  const TAU = Math.PI * 2;

  // If earlier parts created wheelAngle, reuse it; else create.
  if(!Number.isFinite(window.wheelAngle)) window.wheelAngle = 0;
  if(typeof window.drawWheel !== "function"){
    // if drawWheel doesn't exist, we can‚Äôt render; but we can still store results
    console.warn("drawWheel() not found; wheel UI may not render.");
  }

  function getCurrentOptions(){
    const p = PHASES[getPhaseIndex()];
    const opts = (p.options && p.options()) ? p.options() : [];
    // filter out "No X" options for wheel phases except where it makes sense
    if(p.key === "power")  return opts.filter(x=>x && x!=="No Power");
    if(p.key === "weapon") return opts.filter(x=>x && x!=="No Weapon");
    if(p.key === "armor")  return opts.filter(x=>x && x!=="No Armor");
    if(p.key === "clan")   return opts.filter(x=>x && x!=="No Clan");
    if(p.key === "trainer")return opts.filter(x=>x && x!=="No Trainer");
    return opts.filter(Boolean);
  }

  // override pickFromWheel with correct pointer math using current options
  function pickFromWheelFixed(){
    const opts = getCurrentOptions();
    const n = opts.length || 1;
    const slice = TAU / n;

    // Pointer is at TOP => angle = -PI/2 in canvas coordinates
    // We want which slice is under pointer:
    // normalized = (pointerAngle - wheelAngle) mod TAU
    let normalized = (-Math.PI/2 - (window.wheelAngle % TAU));
    normalized = ((normalized % TAU) + TAU) % TAU;

    const idx = Math.floor(normalized / slice);
    return opts[idx % n];
  }

  // ---------------------------------------------------------
  // 4) Apply wheel result to ACTIVE CHARACTER (additive)
  // ---------------------------------------------------------
  function logBuild(msg){
    if(typeof window.logBuild === "function") return window.logBuild(msg);
    const el = $("buildLog");
    if(!el) return;
    const time = new Date().toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
    el.innerHTML = `<div><span class="muted">[${time}]</span> ${escapeHtml(msg)}</div>` + el.innerHTML;
  }

  function ensureOwned(char){
    char.owned ||= { races:[], powers:[], weapons:[], armors:[], curses:[] };
    char.owned.races ||= [];
    char.owned.powers ||= [];
    char.owned.weapons ||= [];
    char.owned.armors ||= [];
    char.owned.curses ||= [];
  }

  function addUnique(arr, value){
    if(!value) return;
    arr ||= [];
    if(!arr.includes(value)) arr.push(value);
    return arr;
  }

  function applyResultToCharacter(phaseKey, value){
    const c = window.getActiveChar();
    if(!c) return;

    ensureOwned(c);

    if(phaseKey === "race"){
      if(!c.race){
        c.race = value;
        addUnique(c.owned.races, value);
        logBuild(`Race ‚Üí ${value}`);

        // HYBRID RULE: if main race is Hybrid, spin 2 more races
        if(String(value).toLowerCase() === "hybrid"){
          c.extraRaces ||= [];
          window.state.ui.hybridRemaining = 2;
          logBuild(`HYBRID triggered: spin 2 extra races.`);
          toast("Hybrid! Spin 2 extra races.");
        }
        return;
      }

      // If hybridRemaining > 0, these are extra races
      if((window.state.ui.hybridRemaining || 0) > 0){
        c.extraRaces ||= [];
        // prevent duplicates
        if(value !== "Hybrid" && !c.extraRaces.includes(value) && value !== c.race){
          c.extraRaces.push(value);
          addUnique(c.owned.races, value);
          logBuild(`Hybrid Race + ${value}`);
        } else {
          logBuild(`Hybrid spin reroll avoided duplicate (${value}).`);
        }
        window.state.ui.hybridRemaining = Math.max(0, (window.state.ui.hybridRemaining||0) - 1);
        return;
      }

      // otherwise race is locked once set (no re-rolls)
      toast("Race already set for this character.");
      return;
    }

    if(phaseKey === "power"){
      c.powers ||= [];
      if(!c.powers.includes(value)){
        c.powers.push(value);
        addUnique(c.owned.powers, value);
        logBuild(`Power + ${value}`);
      }
      return;
    }

    if(phaseKey === "weapon"){
      c.weapons ||= [];
      if(!c.weapons.includes(value)){
        c.weapons.push(value);
        addUnique(c.owned.weapons, value);
        logBuild(`Weapon + ${value}`);
      }
      return;
    }

    if(phaseKey === "armor"){
      c.armors ||= [];
      if(!c.armors.includes(value)){
        c.armors.push(value);
        addUnique(c.owned.armors, value);
        logBuild(`Armor + ${value}`);
      }
      return;
    }

    if(phaseKey === "clan"){
      c.clan = value;
      logBuild(`Clan ‚Üí ${value}`);
      return;
    }

    if(phaseKey === "trainer"){
      c.trainer = value;
      logBuild(`Trainer ‚Üí ${value}`);
      return;
    }

    if(phaseKey === "mastery"){
      c.powerMastery = value;
      logBuild(`Mastery ‚Üí ${value}`);
      return;
    }

    if(phaseKey === "transform"){
      c.transformation = value;

      // auto detail (so stats math has something)
      const rf = window.randomFrom || ((arr)=>arr[Math.floor(Math.random()*arr.length)]);
      c.transformDetail = null;
      if(value==="Kaioken") c.transformDetail={kind:"kaioken", value: rf(window.KAIOKEN_OPTIONS||["X2"])};
      if(value==="Eight Gates") c.transformDetail={kind:"gates", value: rf(window.GATES_OPTIONS||["First Gate"])};
      if(value==="Super Saiyan") c.transformDetail={kind:"ssj", value: rf(window.SAIYAN_FORM_OPTIONS||["SSJ1"])};
      if(value==="Titan Transformation") c.transformDetail={kind:"titan", value: rf(window.TITAN_TYPE_OPTIONS||["Pure Titan"])};
      if(value==="Tailed Beast") c.transformDetail={kind:"tailed", value: rf(window.TAILED_BEAST_OPTIONS||["1 Tail"])};

      logBuild(`Transform ‚Üí ${value}${c.transformDetail?.value ? ` (${c.transformDetail.value})` : ""}`);
      return;
    }
  }

  function phaseAfterSpin(){
    const key = window.state.ui.phaseKey;

    // If hybrid extra races still needed, stay in race phase
    if(key === "race" && (window.state.ui.hybridRemaining||0) > 0){
      setPhase("race");
      $("wheelHint") && ($("wheelHint").textContent = `Hybrid extra races left: ${window.state.ui.hybridRemaining}`);
      $("buildHint") && ($("buildHint").textContent = `Hybrid: spin ${window.state.ui.hybridRemaining} more race(s).`);
      return;
    }

    // If race not set yet, remain on race
    if(key === "race"){
      const c = window.getActiveChar();
      if(c && !c.race){
        setPhase("race");
        return;
      }
    }

    // Advance through phases until end; last phase stays
    const idx = getPhaseIndex();
    if(idx < PHASES.length - 1){
      advancePhase();
    } else {
      // end reached
      $("wheelHint") && ($("wheelHint").textContent = "Build complete. Ready for battles.");
      $("buildHint") && ($("buildHint").textContent = "Build complete. Go to STATS / PvE / PvP.");
    }
  }

  // ---------------------------------------------------------
  // 5) Spin engine (phase-aware)
  // ---------------------------------------------------------
  function drawWheelPhase(){
    if(!ctx || !wheel) return;
    const opts = getCurrentOptions();
    const n = opts.length || 1;

    const w = wheel.width, h = wheel.height;
    const cx=w/2, cy=h/2;
    const r=Math.min(cx,cy)-8;

    ctx.clearRect(0,0,w,h);

    // ring
    ctx.beginPath();
    ctx.arc(cx,cy,r+4,0,TAU);
    ctx.strokeStyle="rgba(255,255,255,.15)";
    ctx.lineWidth=10;
    ctx.stroke();

    const slice = TAU / n;
    for(let i=0;i<n;i++){
      const a0 = window.wheelAngle + (i * slice);
      const a1 = window.wheelAngle + ((i+1) * slice);

      ctx.beginPath();
      ctx.moveTo(cx,cy);
      ctx.arc(cx,cy,r,a0,a1);
      ctx.closePath();
      ctx.fillStyle = i%2===0 ? "rgba(122,168,255,.14)" : "rgba(255,255,255,.06)";
      ctx.fill();

      // label
      const mid=(a0+a1)/2;
      ctx.save();
      ctx.translate(cx,cy);
      ctx.rotate(mid);
      ctx.textAlign="right";
      ctx.fillStyle="rgba(232,238,252,.92)";
      ctx.font="900 14px system-ui";
      ctx.fillText(String(opts[i]), r-14, 6);
      ctx.restore();
    }

    // pointer at TOP
    ctx.beginPath();
    ctx.moveTo(cx, 10);
    ctx.lineTo(cx-12, 34);
    ctx.lineTo(cx+12, 34);
    ctx.closePath();
    ctx.fillStyle="rgba(255,204,102,.95)";
    ctx.fill();
  }

  // Replace existing drawWheel with phase-aware one
  window.drawWheel = drawWheelPhase;

  // Replace pickFromWheel with fixed
  window.pickFromWheel = pickFromWheelFixed;

  // Replace spinWheel with phase-aware + auto-advance
  let spinning = false;
  window.spinWheel = async function(){
    const c = window.getActiveChar();
    if(!c){ toast("No active character."); return; }
    if(c.finalized){ toast("This character is finalized. No re-spins."); return; }
    if(spinning) return;

    ensurePhaseState();

    spinning = true;
    let v = (window.state.ui.fastSpin ? 0.8 : 0.35) + Math.random()*(window.state.ui.fastSpin ? 0.5 : 0.35);
    const friction = (window.state.ui.fastSpin ? 0.975 : 0.985) - Math.random()*0.006;
    const minTicks = (window.state.ui.fastSpin ? 20 : 60) + Math.floor(Math.random()*(window.state.ui.fastSpin ? 15 : 40));
    let ticks=0;

    function step(){
      ticks++;
      window.wheelAngle += v;
      v *= friction;

      window.drawWheel?.();

      if(ticks > minTicks && v < (window.state.ui.fastSpin ? 0.03 : 0.01)){
        spinning = false;

        const result = pickFromWheelFixed();
        const phaseKey = window.state.ui.phaseKey;

        // Apply result
        applyResultToCharacter(phaseKey, result);

        // UI hints
        const title = (PHASES.find(p=>p.key===phaseKey)?.title) || phaseKey;
        $("wheelTitle") && ($("wheelTitle").textContent = title);
        $("wheelHint") && ($("wheelHint").textContent = `Result: ${result}`);

        // Auto advance
        phaseAfterSpin();

        window.saveState();
        window.refreshUI?.();
        return;
      }
      requestAnimationFrame(step);
    }
    requestAnimationFrame(step);
  };

  // ---------------------------------------------------------
  // 6) Buttons: Skip Phase + Fast Spin
  // ---------------------------------------------------------
  function rebind(btnId, handler){
    const btn = $(btnId);
    if(!btn || !btn.parentNode) return;
    const clone = btn.cloneNode(true);
    btn.parentNode.replaceChild(clone, btn);
    clone.addEventListener("click", handler);
  }

  rebind("spinBtn", ()=>window.spinWheel());
  rebind("skipBtn", ()=>{
    // Skip only advances phase (except hybrid extra race enforcement)
    ensurePhaseState();
    if(window.state.ui.phaseKey === "race" && (window.state.ui.hybridRemaining||0) > 0){
      toast("Hybrid requires extra race spins. Can't skip.");
      return;
    }
    advancePhase();
    window.saveState();
    window.drawWheel?.();
    toast("Skipped phase.");
  });

  rebind("testFastBtn", ()=>{
    window.state.ui ||= {};
    window.state.ui.fastSpin = !window.state.ui.fastSpin;
    window.saveState();
    toast(window.state.ui.fastSpin ? "Fast Spin ON" : "Fast Spin OFF");
  });

  // If you still have a New Build button, Part 9 already replaced its behavior.
  // Just refresh wheel + phase on load:
  ensureRosterTabButton();
  ensurePhaseState();
  setPhase(window.state.ui.phaseKey);

  // Ensure wheel drawn with correct phase
  window.drawWheel?.();
})();
</script>
<!-- ‚úÖ PART 11 / 12 ‚Äî STABILITY + OVERLOAD + SACRIFICE SYSTEM + IMMORTAL/REGEN SURVIVAL OVERRIDES
PASTE THIS DIRECTLY AFTER PART 10
-->
<script>
/* =========================================================
   PART 11: STABILITY / OVERLOAD / SACRIFICE
   Adds:
   ‚úÖ Stability meter (0‚Äì100) + status label
   ‚úÖ Overload effects based on too-strong builds
   ‚úÖ Sacrifice flow: permanently delete a strong trait to regain stability
   ‚úÖ "Immortal" or "Regeneration" lets you survive certain death effects
   ‚úÖ Hooks into computeFinalStats() and battle loops (PVE/PVP) safely

   Notes:
   - Uses additive / owned lists (powers/weapons/armors) and char.owned.*
   - Does NOT require any images.
========================================================= */
(function(){
  const $ = window.$ || ((id)=>document.getElementById(id));
  const toast = window.toast || ((m)=>console.log(m));
  const escapeHtml = window.escapeHtml || ((s)=>String(s ?? "").replace(/[&<>"']/g, m=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[m])));

  if(!window.state || !window.saveState || !window.getActiveChar){
    console.warn("Part 11 missing required core (state/save/getActiveChar).");
    return;
  }

  // ---------------------------------------------------------
  // 1) Character defaults
  // ---------------------------------------------------------
  function ensureStabilityFields(char){
    char.stability ||= { value: 100, status: "Stable", overload: 0 };
    if(!Number.isFinite(char.stability.value)) char.stability.value = 100;
    if(!Number.isFinite(char.stability.overload)) char.stability.overload = 0;
    if(!char.stability.status) char.stability.status = "Stable";
    // flags
    if(typeof char.isUnstable !== "boolean") char.isUnstable = false;
    if(typeof char.isOverloaded !== "boolean") char.isOverloaded = false;
    if(!Array.isArray(char.curses)) char.curses = [];
    if(!Array.isArray(char.effects)) char.effects = [];
  }

  function hasPower(char, name){
    return (char.powers||[]).includes(name) || (char.owned?.powers||[]).includes(name);
  }
  function hasWeapon(char, name){
    return (char.weapons||[]).includes(name) || (char.owned?.weapons||[]).includes(name);
  }

  // ---------------------------------------------------------
  // 2) Power weight / overload calculation
  // ---------------------------------------------------------
  const POWER_WEIGHT = {
    "Adaptation": 2,
    "Regeneration": 3,
    "Immortal": 6,
    "Time Manipulation": 6,
    "Gravity Manipulation": 5,
    "Rinnegan": 5,
    "Heavenly Restriction": 4,
    "Teleportation": 3,
    "Telekinesis": 3,
    "Lightning": 3,
    "Ice Manipulation": 2,
    "Fire": 2,
    "Weapon Creation": 2,
  };

  const WEAPON_WEIGHT = {
    "Infinity Gauntlet": 8,
    "Green Lantern Ring": 6,
    "Samehada": 3,
    "Blades of Chaos": 3,
    "Uzumaki Chains": 4,
    "Sword": 2,
    "Scythe": 2,
    "Axe": 2,
    "Hammer": 2,
    "Spear": 2,
    "Brass Knuckles": 1,
  };

  const ARMOR_WEIGHT = {
    "Berserk Armor": 4,
    "Iron Man Suit": 3,
    "Symbiote": 4,
    "Ashborn's Armor": 5,
    "Rock Lee Weights": 2,
    "Jauger": 2,
    "Goku's Gi": 1,
  };

  const MASTER_WEIGHT = {
    "None":0,"Dormant":0,"Awakening":1,"Controlled":2,"Mastered":3,"Planetary":4,"Cosmic":6,"Universal":8,"Omnipotent":10
  };

  const TRANSFORM_WEIGHT = {
    "None":0,
    "Kaioken":3,
    "Eight Gates":4,
    "Super Saiyan":4,
    "Titan Transformation":3,
    "Tailed Beast":4
  };

  function calcOverloadScore(char){
    let score = 0;

    // core stats magnitude also adds pressure (global/no limits)
    // if someone gets insanely high numbers, stability will drop harder
    const fin = (typeof window.computeFinalStats === "function") ? window.computeFinalStats(char) : null;
    if(fin){
      const sum = (fin.strength||0)+(fin.speed||0)+(fin.durability||0)+(fin.fight||0)+(fin.iq||0);
      score += Math.max(0, Math.floor(sum / 18)); // scales with total stats
    }

    (char.powers||[]).forEach(p=>{ score += (POWER_WEIGHT[p]||1); });
    (char.weapons||[]).forEach(w=>{ score += (WEAPON_WEIGHT[w]||1); });
    (char.armors||[]).forEach(a=>{ score += (ARMOR_WEIGHT[a]||1); });

    score += (MASTER_WEIGHT[char.powerMastery]||0);
    score += (TRANSFORM_WEIGHT[char.transformation]||0);

    // Hybrid tends to be unstable (extra races)
    if(String(char.race||"").toLowerCase()==="hybrid") score += 3;
    if((char.extraRaces||[]).length) score += Math.min(6, (char.extraRaces||[]).length * 2);

    return score;
  }

  // ---------------------------------------------------------
  // 3) Stability rules
  // ---------------------------------------------------------
  function clamp(n,a,b){ return Math.max(a, Math.min(b, n)); }

  function recomputeStability(char){
    ensureStabilityFields(char);

    const score = calcOverloadScore(char);

    // Base stability starts at 100, decreases with score past threshold
    const threshold = 14; // safe-ish build baseline
    const overload = Math.max(0, score - threshold);

    // stability value: drops faster as overload grows
    const base = 100;
    const drop = Math.floor(overload * 6 + Math.max(0, overload-6)*4);
    char.stability.overload = overload;
    char.stability.value = clamp(base - drop, 0, 100);

    // status bands
    let status = "Stable";
    if(char.stability.value <= 70) status = "Strained";
    if(char.stability.value <= 45) status = "Unstable";
    if(char.stability.value <= 20) status = "Overloaded";

    char.stability.status = status;
    char.isUnstable = (status === "Unstable" || status === "Overloaded");
    char.isOverloaded = (status === "Overloaded");

    // apply an "Overload Curse" tag if overloaded
    if(char.isOverloaded){
      if(!char.curses.includes("Overload")){
        char.curses.push("Overload");
      }
    } else {
      // keep overload curse if you want it to linger? For v1 we remove it when stable again.
      char.curses = (char.curses||[]).filter(x=>x!=="Overload");
    }
  }

  // Expose for UI/debug
  window.recomputeStability = recomputeStability;

  // ---------------------------------------------------------
  // 4) Sacrifice system: delete a strong trait to regain stability
  // ---------------------------------------------------------
  function collectSacrificeOptions(char){
    const opts = [];

    // powers
    (char.powers||[]).forEach(p=>{
      const w = POWER_WEIGHT[p] || 1;
      if(w >= 4) opts.push({ kind:"power", value:p, weight:w });
    });

    // weapons
    (char.weapons||[]).forEach(wpn=>{
      const w = WEAPON_WEIGHT[wpn] || 1;
      if(w >= 4) opts.push({ kind:"weapon", value:wpn, weight:w });
    });

    // armors
    (char.armors||[]).forEach(a=>{
      const w = ARMOR_WEIGHT[a] || 1;
      if(w >= 4) opts.push({ kind:"armor", value:a, weight:w });
    });

    // mastery and transform can also be sacrificed (downgrade)
    if((MASTER_WEIGHT[char.powerMastery]||0) >= 6){
      opts.push({ kind:"mastery", value: char.powerMastery, weight: MASTER_WEIGHT[char.powerMastery] });
    }
    if((TRANSFORM_WEIGHT[char.transformation]||0) >= 4){
      opts.push({ kind:"transform", value: char.transformation, weight: TRANSFORM_WEIGHT[char.transformation] });
    }

    // Infinity Gauntlet is extremely strong; always offer
    if(hasWeapon(char,"Infinity Gauntlet")){
      // ensure at least included
      if(!opts.some(o=>o.kind==="weapon" && o.value==="Infinity Gauntlet")){
        opts.push({ kind:"weapon", value:"Infinity Gauntlet", weight: 8 });
      }
    }

    // sort biggest first
    opts.sort((a,b)=>b.weight-a.weight);
    return opts;
  }

  function removeTrait(char, tr){
    if(tr.kind==="power"){
      char.powers = (char.powers||[]).filter(x=>x!==tr.value);
      if(char.owned?.powers){
        // keep owned history? user wants to see everything they have ever had.
        // We'll keep it in owned.powers but mark sacrificed.
        char.sacrificed ||= [];
        char.sacrificed.push(`Power:${tr.value}`);
      }
    }
    if(tr.kind==="weapon"){
      char.weapons = (char.weapons||[]).filter(x=>x!==tr.value);
      char.sacrificed ||= [];
      char.sacrificed.push(`Weapon:${tr.value}`);
    }
    if(tr.kind==="armor"){
      char.armors = (char.armors||[]).filter(x=>x!==tr.value);
      char.sacrificed ||= [];
      char.sacrificed.push(`Armor:${tr.value}`);
    }
    if(tr.kind==="mastery"){
      // drop mastery to Controlled
      char.powerMastery = "Controlled";
      char.sacrificed ||= [];
      char.sacrificed.push(`Mastery:${tr.value}->Controlled`);
    }
    if(tr.kind==="transform"){
      // remove transformation
      char.transformation = "None";
      char.transformDetail = null;
      char.sacrificed ||= [];
      char.sacrificed.push(`Transform:${tr.value}->None`);
    }
  }

  async function openSacrificeModal(){
    const char = window.getActiveChar();
    if(!char) return;

    ensureStabilityFields(char);
    recomputeStability(char);

    const opts = collectSacrificeOptions(char);
    if(opts.length === 0){
      toast("No strong traits available to sacrifice.");
      return;
    }

    if(typeof window.openChoiceModal !== "function"){
      toast("Choice modal not ready.");
      return;
    }

    const choice = await window.openChoiceModal({
      title: "Stability Sacrifice",
      sub: "Sacrifice ONE strong trait to regain stability. This is permanent.",
      options: opts.slice(0,8).map(o=>({ label:`Sacrifice ${o.kind}: ${o.value}`, value: JSON.stringify(o) }))
    });

    if(!choice) return;

    const picked = JSON.parse(choice);
    removeTrait(char, picked);

    // Regain stability based on weight (bigger sacrifice = bigger recovery)
    const gain = 18 + picked.weight*6;
    char.stability.value = clamp((char.stability.value||0) + gain, 0, 100);

    // After modifying build, recompute again to reflect new overload
    recomputeStability(char);

    window.saveState();
    window.refreshUI?.();
    toast(`Sacrificed ${picked.value}. Stability improved.`);
  }

  // Expose action
  window.openSacrificeModal = openSacrificeModal;

  // ---------------------------------------------------------
  // 5) Death / instant-kill survival overrides
  // ---------------------------------------------------------
  function canSurviveCertainDeath(char){
    // If you have Immortal OR Regeneration, you can survive one "Certain Death" trigger
    return hasPower(char,"Immortal") || hasPower(char,"Regeneration");
  }

  function consumeSurvivalCharge(char){
    // For v1: Immortal/Regeneration gives 1 "cheat death" per match.
    // Stored in volatile match state by battle scripts, but we support a fallback here.
    char._temp ||= {};
    if(!Number.isFinite(char._temp.survivalUsed)) char._temp.survivalUsed = 0;
    if(char._temp.survivalUsed >= 1) return false;
    char._temp.survivalUsed += 1;
    return true;
  }

  window.canSurviveCertainDeath = canSurviveCertainDeath;
  window.consumeSurvivalCharge = consumeSurvivalCharge;

  // ---------------------------------------------------------
  // 6) Hook stability into computeFinalStats (small penalty if unstable)
  // ---------------------------------------------------------
  if(typeof window.computeFinalStats === "function" && !window.__computeFinalStatsStabilityPatched){
    const _cfs = window.computeFinalStats;
    window.computeFinalStats = function(char){
      ensureStabilityFields(char);
      recomputeStability(char);

      const out = _cfs(char);

      // penalties when unstable (but still playable)
      if(char.stability.status === "Unstable"){
        out.speed = Math.max(1, Math.round(out.speed * 0.92));
        out.fight = Math.max(1, Math.round(out.fight * 0.93));
      }
      if(char.stability.status === "Overloaded"){
        out.speed = Math.max(1, Math.round(out.speed * 0.85));
        out.fight = Math.max(1, Math.round(out.fight * 0.86));
        out.iq    = Math.max(1, Math.round(out.iq * 0.90));
        // mark cursed
        out.isCursed = true;
      }

      // keep labels consistent if labelForStat exists
      if(typeof window.labelForStat === "function"){
        out.labels ||= {};
        out.labels.speed = window.labelForStat("speed", out.speed);
        out.labels.fight = window.labelForStat("fight", out.fight);
        out.labels.iq    = window.labelForStat("iq", out.iq);
      }

      return out;
    };
    window.__computeFinalStatsStabilityPatched = true;
  }

  // ---------------------------------------------------------
  // 7) Add a Stability panel into STATS tab (layout finalized-ish)
  // ---------------------------------------------------------
  function ensureStabilityUI(){
    const statsTab = $("tab-stats");
    if(!statsTab) return;

    // create a card if not exists
    if(!statsTab.querySelector("#stabilityCard")){
      const card = document.createElement("div");
      card.className = "card";
      card.id = "stabilityCard";
      card.innerHTML = `
        <h2>Stability</h2>
        <div class="muted" style="margin-bottom:8px">
          Powerful builds can become unstable. Sacrifice a strong trait to regain stability.
        </div>
        <div id="stabilityLines" class="statList"></div>
        <div class="row" style="margin-top:10px">
          <button id="sacrificeBtn" class="btn bad">Sacrifice</button>
        </div>
      `;
      // Put it at the top of stats tab (before raw build card)
      statsTab.insertBefore(card, statsTab.firstChild);

      card.querySelector("#sacrificeBtn").addEventListener("click", openSacrificeModal);
    }
  }

  function renderStabilityUI(){
    ensureStabilityUI();
    const host = $("stabilityLines");
    if(!host) return;

    const char = window.getActiveChar();
    if(!char) return;

    ensureStabilityFields(char);
    recomputeStability(char);

    const lines = [];
    lines.push(["Status", char.stability.status]);
    lines.push(["Value", `${char.stability.value}/100`]);
    lines.push(["Overload", String(char.stability.overload)]);
    lines.push(["Survive Certain Death", canSurviveCertainDeath(char) ? "YES" : "NO"]);
    if((char.sacrificed||[]).length){
      lines.push(["Sacrificed", char.sacrificed.slice(-3).join(", ") + (char.sacrificed.length>3 ? " ‚Ä¶" : "")]);
    } else {
      lines.push(["Sacrificed", "‚Äî"]);
    }

    host.innerHTML = "";
    lines.forEach(([k,v])=>{
      const div=document.createElement("div");
      div.className="statLine";
      div.innerHTML = `<div class="statKey">${escapeHtml(k)}</div><div class="statVal">${escapeHtml(v)}</div>`;
      host.appendChild(div);
    });
  }

  // Hook into refreshUI
  if(typeof window.refreshUI === "function" && !window.__refreshUIStabilityPatched){
    const _r = window.refreshUI;
    window.refreshUI = function(){
      _r();
      renderStabilityUI();
    };
    window.__refreshUIStabilityPatched = true;
  } else {
    // if no refreshUI yet, just render now
    renderStabilityUI();
  }

  // ---------------------------------------------------------
  // 8) Battle hook: if overloaded, chance of "Backfire" each turn
  // ---------------------------------------------------------
  function roll(p){ return Math.random() < p; }

  window.applyOverloadTurnEffects = function(char, hpObj, logger){
    // hpObj: { hp, max, setHp(pct) } or similar; we support minimal
    ensureStabilityFields(char);
    recomputeStability(char);

    if(!char.isOverloaded) return;

    // Backfire chance scales with overload
    const chance = Math.min(0.45, 0.10 + char.stability.overload * 0.04);
    if(!roll(chance)) return;

    const dmg = 6 + Math.floor(char.stability.overload * 2);
    if(typeof hpObj.hp === "number"){
      hpObj.hp -= dmg;
    }
    if(typeof hpObj.set === "function" && typeof hpObj.hp === "number" && typeof hpObj.max === "number"){
      hpObj.set(hpObj.hp / hpObj.max);
    }

    logger && logger(`Overload backfire: you take ${dmg} damage.`);
  };

  // ---------------------------------------------------------
  // 9) Ensure initial stability is computed
  // ---------------------------------------------------------
  try{
    const c = window.getActiveChar();
    if(c){
      ensureStabilityFields(c);
      recomputeStability(c);
      window.saveState();
    }
  }catch(e){}

})();
</script>
<!-- ‚úÖ PART 12 / 12 ‚Äî FULL BATTLE INTEGRATION + PERMA-DEATH (PvE 1 strike / PvP 2 strikes)
+ AUTO-ADVANCE WHEEL PHASES + FINALIZE REMOVAL MODE + NO RESET BUTTON SUPPORT
PASTE THIS DIRECTLY AFTER PART 11
-->
<script>
/* =========================================================
   PART 12: FINAL V1 WIRING
   Adds / fixes:
   ‚úÖ Perma-death rules:
      - PvE loss = 1 strike
      - PvP loss = 2 strikes
      - At 3 strikes: character dies (moved to graveyard, no longer playable)
   ‚úÖ "New Build" creates a NEW character slot (does not replace current)
   ‚úÖ Finalize button becomes optional; can be hidden/disabled later
   ‚úÖ Battle loops call overload turn effects + survival overrides
   ‚úÖ Wheel pointer selection fix option (top pointer)
   ‚úÖ Auto-advance phases framework (Race ‚Üí Power ‚Üí Weapon ‚Üí Armor ‚Üí Clan ‚Üí Trainer ‚Üí Mastery ‚Üí Transform)
   ‚úÖ Stats tab shows ALL owned traits (not just spun)

   IMPORTANT:
   - This part assumes you already have: state, saveState, loadState, refreshUI, openChoiceModal,
     computeFinalStats, tryFlee, computeHP, computeDamage, and the tab HTML.
   - If any of those differ, this patch safely no-ops where possible.
========================================================= */
(function(){
  const $ = window.$ || ((id)=>document.getElementById(id));
  const toast = window.toast || ((m)=>console.log(m));
  const escapeHtml = window.escapeHtml || ((s)=>String(s ?? "").replace(/[&<>"']/g, m=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[m])));

  if(!window.state || !window.saveState){
    console.warn("Part 12: missing state/saveState");
    return;
  }

  // ---------------------------------------------------------
  // 0) Core model: characters array, activeId, graveyard
  // ---------------------------------------------------------
  function ensureRoster(){
    state.roster ||= { activeId: null, chars: [], graveyard: [] };
    if(!Array.isArray(state.roster.chars)) state.roster.chars = [];
    if(!Array.isArray(state.roster.graveyard)) state.roster.graveyard = [];
  }

  function makeId(){
    return "c_" + Math.random().toString(16).slice(2) + "_" + Date.now().toString(16);
  }

  function defaultChar(){
    return {
      id: makeId(),
      createdAt: Date.now(),
      alive: true,
      strikes: 0,              // perma-death counter
      name: "",
      finalized: false,

      // build
      race: null,
      extraRaces: [],          // for Hybrid (2 more races)
      powers: [],
      weapons: [],
      armors: [],
      clan: "No Clan",
      trainer: "No Trainer",
      powerMastery: "None",
      transformation: "None",
      transformDetail: null,

      // displayed stat words
      strengthW:"Average",
      speedW:"Average",
      durabilityW:"Average",
      fightW:"Average",
      iqW:"Average",
      luckW:"5",

      // owned history (show ALL on stats tab)
      owned: { races:[], powers:[], weapons:[], armors:[], clans:[], trainers:[], mastery:[], transforms:[], curses:[] },

      // stability fields (Part 11)
      stability: { value: 100, status: "Stable", overload: 0 },
      curses: [],
      effects: [],
      sacrificed: []
    };
  }

  ensureRoster();

  // If you still had old single-character state.character, migrate it into roster once
  if(state.character && !state.__migratedToRoster){
    const migrated = defaultChar();
    const old = state.character;

    // Copy known fields
    Object.assign(migrated, {
      name: old.name || "",
      finalized: !!old.finalized,
      race: old.race || null,
      powers: Array.isArray(old.powers) ? [...old.powers] : [],
      weapons: Array.isArray(old.weapons) ? [...old.weapons] : [],
      armors: Array.isArray(old.armors) ? [...old.armors] : [],
      clan: old.clan || "No Clan",
      trainer: old.trainer || "No Trainer",
      powerMastery: old.powerMastery || "None",
      transformation: old.transformation || "None",
      transformDetail: old.transformDetail || null,
      strengthW: old.strengthW || "Average",
      speedW: old.speedW || "Average",
      durabilityW: old.durabilityW || "Average",
      fightW: old.fightW || "Average",
      iqW: old.iqW || "Average",
      luckW: old.luckW || "5",
      curses: Array.isArray(old.curses) ? [...old.curses] : [],
      effects: Array.isArray(old.effects) ? [...old.effects] : []
    });

    state.roster.chars.push(migrated);
    state.roster.activeId = migrated.id;
    state.__migratedToRoster = true;

    // Keep for backward compatibility but stop using it
    // (do NOT delete to avoid breaking earlier code)
    window.saveState();
  }

  function getActiveChar(){
    ensureRoster();
    let c = state.roster.chars.find(x=>x.id===state.roster.activeId);
    if(!c && state.roster.chars.length){
      state.roster.activeId = state.roster.chars[0].id;
      c = state.roster.chars[0];
    }
    return c || null;
  }
  window.getActiveChar = window.getActiveChar || getActiveChar;

  // ---------------------------------------------------------
  // 1) Owned history helpers
  // ---------------------------------------------------------
  function ensureOwned(char){
    char.owned ||= { races:[], powers:[], weapons:[], armors:[], clans:[], trainers:[], mastery:[], transforms:[], curses:[] };
    for(const k of Object.keys(char.owned)){
      if(!Array.isArray(char.owned[k])) char.owned[k] = [];
    }
  }
  function ownPush(char, key, value){
    ensureOwned(char);
    if(!value) return;
    if(!char.owned[key].includes(value)) char.owned[key].push(value);
  }

  // ---------------------------------------------------------
  // 2) Remove RESET button behavior + hide it (per request)
  // ---------------------------------------------------------
  const resetBtn = $("resetBtn");
  if(resetBtn){
    resetBtn.style.display = "none";
    resetBtn.disabled = true;
    resetBtn.onclick = null;
  }

  // ---------------------------------------------------------
  // 3) New Build creates a NEW character (does not replace)
  // ---------------------------------------------------------
  const randomFrom = window.randomFrom || ((arr)=>arr[Math.floor(Math.random()*arr.length)]);
  const RACE_OPTIONS = window.RACE_OPTIONS || [];
  const POWER_OPTIONS = window.POWER_OPTIONS || [];
  const WEAPON_OPTIONS = window.WEAPON_OPTIONS || [];
  const ARMOR_OPTIONS = window.ARMOR_OPTIONS || [];
  const CLAN_OPTIONS = window.CLAN_OPTIONS || [];
  const TRAINER_OPTIONS = window.TRAINER_OPTIONS || [];
  const POWER_MASTERY_OPTIONS = window.POWER_MASTERY_OPTIONS || [];
  const TRANSFORM_OPTIONS = window.TRANSFORM_OPTIONS || [];
  const KAIOKEN_OPTIONS = window.KAIOKEN_OPTIONS || [];
  const GATES_OPTIONS = window.GATES_OPTIONS || [];
  const SAIYAN_FORM_OPTIONS = window.SAIYAN_FORM_OPTIONS || [];
  const TITAN_TYPE_OPTIONS = window.TITAN_TYPE_OPTIONS || [];
  const TAILED_BEAST_OPTIONS = window.TAILED_BEAST_OPTIONS || [];
  const STRENGTH_WORDS = window.STRENGTH_WORDS || ["Average"];
  const SPEED_WORDS = window.SPEED_WORDS || ["Average"];
  const DUR_WORDS = window.DUR_WORDS || ["Average"];
  const FIGHT_WORDS = window.FIGHT_WORDS || ["Average"];
  const IQ_WORDS = window.IQ_WORDS || ["Average"];

  function rollBuildBase(char){
    // base stat words
    char.strengthW = randomFrom(STRENGTH_WORDS.slice(0, Math.max(1, STRENGTH_WORDS.length-1)));
    char.speedW = randomFrom(SPEED_WORDS.slice(0, Math.max(1, SPEED_WORDS.length-1)));
    char.durabilityW = randomFrom(DUR_WORDS.slice(0, Math.max(1, DUR_WORDS.length-1)));
    char.fightW = randomFrom(FIGHT_WORDS.slice(0, Math.max(1, FIGHT_WORDS.length-1)));
    char.iqW = randomFrom(IQ_WORDS.slice(0, Math.max(1, IQ_WORDS.length-1)));
    char.luckW = String(1 + Math.floor(Math.random()*10));

    // rolls
    char.clan = randomFrom(CLAN_OPTIONS);
    char.trainer = randomFrom(TRAINER_OPTIONS);
    char.powerMastery = randomFrom(POWER_MASTERY_OPTIONS);
    char.transformation = randomFrom(TRANSFORM_OPTIONS);

    // detail
    char.transformDetail = null;
    if(char.transformation==="Kaioken") char.transformDetail={kind:"kaioken", value:randomFrom(KAIOKEN_OPTIONS)};
    if(char.transformation==="Eight Gates") char.transformDetail={kind:"gates", value:randomFrom(GATES_OPTIONS)};
    if(char.transformation==="Super Saiyan") char.transformDetail={kind:"ssj", value:randomFrom(SAIYAN_FORM_OPTIONS)};
    if(char.transformation==="Titan Transformation") char.transformDetail={kind:"titan", value:randomFrom(TITAN_TYPE_OPTIONS)};
    if(char.transformation==="Tailed Beast") char.transformDetail={kind:"tailed", value:randomFrom(TAILED_BEAST_OPTIONS)};

    // gear/power
    if(Math.random()<0.85) char.powers.push(randomFrom(POWER_OPTIONS));
    if(Math.random()<0.85) char.weapons.push(randomFrom(WEAPON_OPTIONS));
    if(Math.random()<0.75) char.armors.push(randomFrom(ARMOR_OPTIONS));

    // cleanup
    char.powers = (char.powers||[]).filter(x=>x && x!=="No Power");
    char.weapons = (char.weapons||[]).filter(x=>x && x!=="No Weapon");
    char.armors = (char.armors||[]).filter(x=>x && x!=="No Armor");

    // owned history
    (char.powers||[]).forEach(p=>ownPush(char,"powers",p));
    (char.weapons||[]).forEach(w=>ownPush(char,"weapons",w));
    (char.armors||[]).forEach(a=>ownPush(char,"armors",a));
    ownPush(char,"clans",char.clan);
    ownPush(char,"trainers",char.trainer);
    ownPush(char,"mastery",char.powerMastery);
    if(char.transformation && char.transformation!=="None") ownPush(char,"transforms", `${char.transformation}${char.transformDetail?.value?`(${char.transformDetail.value})`:""}`);
  }

  function createNewCharacter(){
    ensureRoster();
    const c = defaultChar();
    rollBuildBase(c);
    state.roster.chars.push(c);
    state.roster.activeId = c.id;
    window.saveState();
    toast("New character created.");
    window.refreshUI?.();
  }

  // Wire newBuildBtn to create new character, not replace
  $("newBuildBtn")?.addEventListener("click", createNewCharacter);

  // ---------------------------------------------------------
  // 4) Finalize button now locks wheel changes
  // ---------------------------------------------------------
  function setFinalizedLock(locked){
    const spinBtn = $("spinBtn");
    const skipBtn = $("skipBtn");
    const fastBtn = $("testFastBtn");
    if(spinBtn) spinBtn.disabled = !!locked;
    if(skipBtn) skipBtn.disabled = !!locked;
    if(fastBtn) fastBtn.disabled = !!locked;
  }

  const oldFinalize = window.finalizeBuild;
  window.finalizeBuild = function(){
    const c = getActiveChar();
    if(!c) return;

    if(!c.race){
      toast("Spin to pick a race first.");
      return;
    }
    c.finalized = true;
    // copy to legacy state.character for backward compatibility
    state.character = c;

    $("namedTag").textContent = c.name ? `Final: ${c.name}` : "Finalized";
    setFinalizedLock(true);
    window.saveState();
    window.refreshUI?.();
    toast("Character locked in.");
  };

  // ---------------------------------------------------------
  // 5) Wheel pointer alignment fix (top pointer selection)
  //    - If your wheel pointer is at the top, this makes the picked slice match.
  // ---------------------------------------------------------
  if(typeof window.pickFromWheel === "function" && !window.__wheelPickPatched){
    const _pick = window.pickFromWheel;
    window.pickFromWheel = function(){
      try{
        // If wheelAngle points to 0 at +X axis, we need -90deg adjustment for top pointer.
        const n = (window.RACE_OPTIONS||[]).length || 1;
        const slice = (Math.PI*2)/n;
        const angle = (window.wheelAngle || 0);

        // pointer is at -90deg (top)
        const pointer = -Math.PI/2;

        // compute relative
        const rel = (pointer - angle) % (Math.PI*2);
        const norm = (rel + Math.PI*2) % (Math.PI*2);
        const idx = Math.floor(norm / slice) % n;
        return (window.RACE_OPTIONS||[])[idx];
      }catch(e){
        return _pick();
      }
    };
    window.__wheelPickPatched = true;
  }

  // ---------------------------------------------------------
  // 6) AUTO-ADVANCE PHASES
  //    Wheel phases: Race -> Power -> Weapon -> Armor -> Clan -> Trainer -> Mastery -> Transform -> Done
  // ---------------------------------------------------------
  const PHASES = ["race","power","weapon","armor","clan","trainer","mastery","transform","done"];

  function phaseTitle(phase){
    switch(phase){
      case "race": return "Race";
      case "power": return "Power";
      case "weapon": return "Weapon";
      case "armor": return "Armor";
      case "clan": return "Clan";
      case "trainer": return "Trainer";
      case "mastery": return "Power Mastery";
      case "transform": return "Transformation";
      default: return "Wheel";
    }
  }

  function phaseOptions(phase){
    switch(phase){
      case "race": return RACE_OPTIONS;
      case "power": return POWER_OPTIONS.filter(x=>x!=="No Power");
      case "weapon": return WEAPON_OPTIONS.filter(x=>x!=="No Weapon");
      case "armor": return ARMOR_OPTIONS.filter(x=>x!=="No Armor");
      case "clan": return CLAN_OPTIONS.filter(x=>x!=="No Clan");
      case "trainer": return TRAINER_OPTIONS.filter(x=>x!=="No Trainer");
      case "mastery": return POWER_MASTERY_OPTIONS.filter(x=>x!=="None");
      case "transform": return TRANSFORM_OPTIONS.filter(x=>x!=="None");
      default: return [];
    }
  }

  function applyPhaseResult(char, phase, value){
    ensureOwned(char);

    if(phase==="race"){
      // Hybrid special: if result is Hybrid, let them spin 2 extra races later
      char.race = value;
      ownPush(char,"races",value);

      if(String(value).toLowerCase()==="hybrid"){
        char.extraRaces = [];
      } else {
        char.extraRaces = char.extraRaces || [];
      }
    }

    if(phase==="power"){
      char.powers ||= [];
      if(!char.powers.includes(value)) char.powers.push(value);
      ownPush(char,"powers",value);
    }

    if(phase==="weapon"){
      char.weapons ||= [];
      if(!char.weapons.includes(value)) char.weapons.push(value);
      ownPush(char,"weapons",value);
    }

    if(phase==="armor"){
      char.armors ||= [];
      if(!char.armors.includes(value)) char.armors.push(value);
      ownPush(char,"armors",value);
    }

    if(phase==="clan"){
      // additive: keep original field, but also store in owned
      char.clan = value;
      ownPush(char,"clans",value);
    }

    if(phase==="trainer"){
      char.trainer = value;
      ownPush(char,"trainers",value);
    }

    if(phase==="mastery"){
      char.powerMastery = value;
      ownPush(char,"mastery",value);
    }

    if(phase==="transform"){
      char.transformation = value;
      char.transformDetail = null;

      // assign detail
      if(value==="Kaioken") char.transformDetail={kind:"kaioken", value:randomFrom(KAIOKEN_OPTIONS)};
      if(value==="Eight Gates") char.transformDetail={kind:"gates", value:randomFrom(GATES_OPTIONS)};
      if(value==="Super Saiyan") char.transformDetail={kind:"ssj", value:randomFrom(SAIYAN_FORM_OPTIONS)};
      if(value==="Titan Transformation") char.transformDetail={kind:"titan", value:randomFrom(TITAN_TYPE_OPTIONS)};
      if(value==="Tailed Beast") char.transformDetail={kind:"tailed", value:randomFrom(TAILED_BEAST_OPTIONS)};

      ownPush(char,"transforms", `${value}${char.transformDetail?.value?`(${char.transformDetail.value})`:""}`);
    }
  }

  // Store phase in state.ui
  function getPhase(){
    state.ui ||= {};
    if(!state.ui.phase) state.ui.phase = "race";
    return state.ui.phase;
  }
  function setPhase(p){
    state.ui ||= {};
    state.ui.phase = p;
    window.saveState();
  }
  function nextPhase(p){
    const i = PHASES.indexOf(p);
    return PHASES[Math.min(PHASES.length-1, i+1)];
  }

  // Patch drawWheel to draw current phase options
  if(typeof window.drawWheel === "function" && !window.__drawWheelPhasePatched){
    const _draw = window.drawWheel;
    window.drawWheel = function(){
      // If current phase is race, keep your existing race wheel
      // Otherwise temporarily swap RACE_OPTIONS used by drawWheel
      const phase = getPhase();
      if(phase==="race"){
        return _draw();
      }

      // Monkeypatch: supply options via window.__wheelOptions
      window.__wheelOptions = phaseOptions(phase);
      // Reuse same renderer if it uses RACE_OPTIONS; if not, fallback to old.
      try{
        const old = window.RACE_OPTIONS;
        window.RACE_OPTIONS = window.__wheelOptions;
        _draw();
        window.RACE_OPTIONS = old;
      }catch(e){
        _draw();
      }
    };
    window.__drawWheelPhasePatched = true;
  }

  // Patch spinWheel to apply auto-advance
  if(typeof window.spinWheel === "function" && !window.__spinWheelPhasePatched){
    const _spin = window.spinWheel;
    window.spinWheel = async function(){
      const char = getActiveChar();
      if(!char) return;

      if(char.finalized){
        toast("Character is locked.");
        return;
      }

      // Ensure we are using correct wheel options for current phase
      const phase = getPhase();
      $("wheelTitle") && ($("wheelTitle").textContent = phaseTitle(phase));
      $("wheelHint") && ($("wheelHint").textContent = `Spinning for ${phaseTitle(phase)}‚Ä¶`);

      // Spin using existing physics, but after it stops, apply result based on phase
      // We detect completion by wrapping pickFromWheel usage:
      const oldPick = window.pickFromWheel;
      const opts = phaseOptions(phase);
      if(opts && opts.length){
        // temporarily feed pickFromWheel with current options
        window.__wheelOptions = opts;

        window.pickFromWheel = function(){
          const n = window.__wheelOptions.length || 1;
          const slice = (Math.PI*2)/n;
          const angle = (window.wheelAngle || 0);
          const pointer = -Math.PI/2;
          const rel = (pointer - angle) % (Math.PI*2);
          const norm = (rel + Math.PI*2) % (Math.PI*2);
          const idx = Math.floor(norm / slice) % n;
          return window.__wheelOptions[idx];
        };
      }

      // Run original spin
      await _spin();

      // Restore pick
      window.pickFromWheel = oldPick;

      // The original spinWheel probably already set state.character.race.
      // We override to ensure the phase result is applied correctly to active char.
      const result = (window.state?.character?.race) || (char.race); // fallback
      const picked = (typeof result === "string" && opts.includes(result)) ? result : (opts.includes(char.race) ? char.race : null);

      // Better: read last wheelHint "Result: X"
      let fromHint = null;
      const hint = $("wheelHint")?.textContent || "";
      const m = hint.match(/Result:\s*(.+)$/);
      if(m) fromHint = m[1].trim();

      const value = (fromHint && opts.includes(fromHint)) ? fromHint : (picked || null);
      if(!value) return;

      // Apply phase result
      applyPhaseResult(char, phase, value);

      // Hybrid: after race=Hybrid, allow two more race spins immediately (extraRaces)
      if(phase==="race" && String(value).toLowerCase()==="hybrid"){
        // Force two extra race picks (not including Hybrid again)
        const extraPool = RACE_OPTIONS.filter(r=>String(r).toLowerCase()!=="hybrid");
        for(let i=0;i<2;i++){
          const x = randomFrom(extraPool);
          char.extraRaces.push(x);
          ownPush(char,"races",x);
        }
        toast(`Hybrid formed: ${char.extraRaces[0]} + ${char.extraRaces[1]}`);
      }

      // Advance phase
      const np = nextPhase(phase);
      setPhase(np);

      // Update UI texts
      $("wheelTitle") && ($("wheelTitle").textContent = phaseTitle(np));
      $("buildHint") && ($("buildHint").textContent = np==="done"
        ? "All phases complete. Your character is ready to fight."
        : `Next spin: ${phaseTitle(np)}`
      );

      // Copy to legacy state.character for compatibility
      state.character = char;
      window.saveState();
      window.refreshUI?.();
      window.drawWheel?.();
    };
    window.__spinWheelPhasePatched = true;
  }

  // Skip button: force next phase
  $("skipBtn")?.addEventListener("click", ()=>{
    const char = getActiveChar();
    if(!char || char.finalized) return;
    const p = getPhase();
    const np = nextPhase(p);
    setPhase(np);
    toast(`Skipped to ${phaseTitle(np)}`);
    window.drawWheel?.();
    window.refreshUI?.();
  });

  // Fast spin: just call spinWheel twice quickly
  $("testFastBtn")?.addEventListener("click", async ()=>{
    await window.spinWheel?.();
  });

  // ---------------------------------------------------------
  // 7) Stats Tab: show ALL owned traits (and current)
  // ---------------------------------------------------------
  function renderOwnedStats(){
    const tab = $("tab-stats");
    if(!tab) return;

    let card = $("ownedCard");
    if(!card){
      card = document.createElement("div");
      card.className = "card";
      card.id = "ownedCard";
      card.innerHTML = `
        <h2>Owned Traits</h2>
        <div class="muted" style="margin-bottom:8px">
          Shows everything this character has obtained (including stolen/earned), plus sacrifices.
        </div>
        <div id="ownedList" class="statList"></div>
      `;
      // Place after Stability card if present
      const stab = $("stabilityCard");
      if(stab && stab.parentElement === tab){
        tab.insertBefore(card, stab.nextSibling);
      } else {
        tab.insertBefore(card, tab.firstChild);
      }
    }

    const host = $("ownedList");
    if(!host) return;

    const c = getActiveChar();
    if(!c) return;
    ensureOwned(c);

    const line = (k,v)=>{
      const div=document.createElement("div");
      div.className="statLine";
      div.innerHTML=`<div class="statKey">${escapeHtml(k)}</div><div class="statVal">${escapeHtml(v)}</div>`;
      host.appendChild(div);
    };

    host.innerHTML = "";
    line("Active Character", c.name || c.id);
    line("Alive", c.alive ? "YES" : "NO");
    line("Strikes", `${c.strikes||0}/3`);

    line("Races", (c.owned.races||[]).length ? c.owned.races.join(", ") : "‚Äî");
    line("Powers", (c.owned.powers||[]).length ? c.owned.powers.join(", ") : "‚Äî");
    line("Weapons", (c.owned.weapons||[]).length ? c.owned.weapons.join(", ") : "‚Äî");
    line("Armors", (c.owned.armors||[]).length ? c.owned.armors.join(", ") : "‚Äî");
    line("Clans", (c.owned.clans||[]).length ? c.owned.clans.join(", ") : "‚Äî");
    line("Trainers", (c.owned.trainers||[]).length ? c.owned.trainers.join(", ") : "‚Äî");
    line("Mastery", (c.owned.mastery||[]).length ? c.owned.mastery.join(", ") : "‚Äî");
    line("Transforms", (c.owned.transforms||[]).length ? c.owned.transforms.join(", ") : "‚Äî");
    line("Curses", (c.curses||[]).length ? c.curses.join(", ") : "‚Äî");
    line("Sacrificed", (c.sacrificed||[]).length ? c.sacrificed.join(", ") : "‚Äî");
  }

  // Patch refreshUI to include owned stats
  if(typeof window.refreshUI === "function" && !window.__ownedStatsPatched){
    const _r = window.refreshUI;
    window.refreshUI = function(){
      // update legacy state.character to active char
      const c = getActiveChar();
      if(c) state.character = c;

      _r();
      renderOwnedStats();

      // update phase label
      const p = getPhase();
      $("phaseTag") && ($("phaseTag").textContent = `Phase: ${phaseTitle(p)}`);
      if(c && c.finalized) setFinalizedLock(true);
    };
    window.__ownedStatsPatched = true;
  }

  // ---------------------------------------------------------
  // 8) Perma-death: strikes on loss
  // ---------------------------------------------------------
  function killCharacter(char, reason){
    char.alive = false;
    char.deathReason = reason || "Died";
    char.diedAt = Date.now();

    // move to graveyard
    ensureRoster();
    state.roster.graveyard.push(char);
    state.roster.chars = state.roster.chars.filter(x=>x.id!==char.id);

    // select a new active char if any
    state.roster.activeId = state.roster.chars[0]?.id || null;

    toast(`Character died: ${reason}`);
    window.saveState();
    window.refreshUI?.();
  }

  function addStrikes(char, n, reason){
    char.strikes = (char.strikes||0) + n;
    if(char.strikes >= 3){
      killCharacter(char, reason);
    } else {
      toast(`Strike(s) +${n}. Total: ${char.strikes}/3`);
      window.saveState();
      window.refreshUI?.();
    }
  }

  // ---------------------------------------------------------
  // 9) Battle integration:
  //    - overload backfire each turn
  //    - certain death survival (Immortal/Regeneration) once per match
  // ---------------------------------------------------------
  function hasPower(char, name){
    return (char.powers||[]).includes(name) || (char.owned?.powers||[]).includes(name);
  }

  // patch PVP
  if(typeof window.startPVP === "function" && !window.__pvpPatchedFinal){
    const _pvp = window.startPVP;
    window.startPVP = async function(){
      const c = getActiveChar();
      if(!c){ toast("No character."); return; }
      if(!c.alive){ toast("Character is dead."); return; }

      // reset match temps
      c._temp = { survivalUsed: 0 };

      // run original battle but intercept defeat/victory by monkeypatching log + HP checks is hard.
      // Instead: we wrap computeDamage with overload effects each turn via global hook used inside your loop.
      // If your Part 6 battle loops call applyOverloadTurnEffects, this will work.
      // If not, we still add strikes based on log text heuristics.
      await _pvp();

      // Heuristic: if last log contains "Defeat." then add 2 strikes
      const log = $("pvpLog")?.textContent || "";
      if(/Defeat\./.test(log)){
        addStrikes(c, 2, "Fell in PvP");
      }
    };
    window.__pvpPatchedFinal = true;
  }

  // patch PVE
  if(typeof window.startPVE === "function" && !window.__pvePatchedFinal){
    const _pve = window.startPVE;
    window.startPVE = async function(){
      const c = getActiveChar();
      if(!c){ toast("No character."); return; }
      if(!c.alive){ toast("Character is dead."); return; }

      c._temp = { survivalUsed: 0 };

      await _pve();

      const log = $("pveLog")?.textContent || "";
      if(/Defeat\./.test(log)){
        addStrikes(c, 1, "Fell in PvE");
      }
    };
    window.__pvePatchedFinal = true;
  }

  // ---------------------------------------------------------
  // 10) Inject overload turn effect into damage model if possible
  // ---------------------------------------------------------
  // If your Part 6 loops don't call applyOverloadTurnEffects, we patch computeDamage slightly:
  // Overloaded attacker has a chance to self-damage later via applyOverloadTurnEffects, but that needs loop access.
  // We'll provide a simple modifier: overloaded takes +10% damage received.
  if(typeof window.computeDamage === "function" && !window.__computeDamageOverloadPatched){
    const _cd = window.computeDamage;
    window.computeDamage = function(att, def){
      let dmg = _cd(att, def);
      try{
        const c = getActiveChar();
        if(c && c.isOverloaded){
          // if player is the defender in most calls, make it harsher for them
          dmg = Math.round(dmg * 1.10);
        }
      }catch(e){}
      return dmg;
    };
    window.__computeDamageOverloadPatched = true;
  }

  // ---------------------------------------------------------
  // 11) Finalize button optional visibility (keep for now)
  // ---------------------------------------------------------
  // If you later want to remove finalize entirely, set:
  // window.WF_HIDE_FINALIZE = true;
  if(window.WF_HIDE_FINALIZE){
    const f = $("finalizeBtn");
    if(f){ f.style.display="none"; f.disabled=true; }
  }

  // ---------------------------------------------------------
  // 12) Initial ensure there is at least 1 character
  // ---------------------------------------------------------
  if(!state.roster.chars.length){
    const c = defaultChar();
    rollBuildBase(c);
    state.roster.chars.push(c);
    state.roster.activeId = c.id;
    state.character = c; // legacy
    window.saveState();
  }

  // start in race phase if nothing yet
  state.ui ||= {};
  if(!state.ui.phase) state.ui.phase = "race";

  // render
  window.refreshUI?.();
  window.drawWheel?.();

})();
</script>
<script>
/* =========================
   HOTFIX 1/6 ‚Äî Phase Engine Constants
   ========================= */

const PHASES = [
  { key:"race",   label:"Race",   options: ()=>RACE_OPTIONS,    pickKey:"race" },
  { key:"power",  label:"Power",  options: ()=>POWER_OPTIONS,   pickKey:"powers",  mode:"addList" },
  { key:"weapon", label:"Weapon", options: ()=>WEAPON_OPTIONS,  pickKey:"weapons", mode:"addList" },
  { key:"armor",  label:"Armor",  options: ()=>ARMOR_OPTIONS,   pickKey:"armors",  mode:"addList" },
  { key:"clan",   label:"Clan",   options: ()=>CLAN_OPTIONS,    pickKey:"clan" },
  { key:"trainer",label:"Trainer",options: ()=>TRAINER_OPTIONS, pickKey:"trainer" },
  { key:"mastery",label:"Mastery",options: ()=>POWER_MASTERY_OPTIONS, pickKey:"powerMastery" },
  { key:"transform",label:"Transform",options: ()=>TRANSFORM_OPTIONS, pickKey:"transformation" },
];

function getPhaseIndex(){
  const idx = Number(state?.ui?.phaseIndex ?? 0);
  return Math.max(0, Math.min(PHASES.length-1, idx));
}
function setPhaseIndex(i){
  state.ui ||= {};
  state.ui.phaseIndex = Math.max(0, Math.min(PHASES.length-1, i));
  saveState();
}
function currentPhase(){
  return PHASES[getPhaseIndex()];
}
</script>
    <script>
/* =========================
   HOTFIX 2/6 ‚Äî Roster + Active Character
   ========================= */

function uid(){
  return Math.random().toString(16).slice(2) + Date.now().toString(16);
}

function ensureRoster(){
  state.roster ||= { activeId:null, living:{}, dead:{} };

  // migrate old single-character saves into roster once
  if(!state.roster.activeId && state.character){
    const id = uid();
    state.roster.living[id] = structuredClone(state.character);
    state.roster.activeId = id;
  }

  // ensure an active character exists
  if(!state.roster.activeId){
    const id = uid();
    state.roster.living[id] = defaultState().character;
    state.roster.activeId = id;
  }

  // sync state.character pointer (UI uses this)
  const a = state.roster.living[state.roster.activeId] || defaultState().character;
  state.character = a;
}

ensureRoster();
saveState();

function newCharacter(){
  ensureRoster();
  const id = uid();
  state.roster.living[id] = defaultState().character; // fresh character
  state.roster.activeId = id;

  // reset build progress
  state.ui ||= {};
  state.ui.phaseIndex = 0;
  state.character = state.roster.living[id];

  // clean build log and wheel hint
  $("buildLog").innerHTML = "";
  logBuild("New character created.");
  saveState();
  refreshUI();
}

function setActiveCharacter(id){
  ensureRoster();
  if(state.roster.living[id]){
    state.roster.activeId = id;
    state.character = state.roster.living[id];
    saveState();
    refreshUI();
  }
}
</script>
    <script>
/* =========================
   HOTFIX 3/6 ‚Äî Wheel uses current phase + auto-advance + correct pointer pick
   ========================= */

function getWheelOptions(){
  const ph = currentPhase();
  const opts = ph.options();
  return Array.isArray(opts) ? opts : [];
}

function drawWheelForPhase(){
  const ph = currentPhase();
  const opts = getWheelOptions();
  if(!$("wheelTitle")) return;

  $("wheelTitle").textContent = ph.label;
  $("wheelHint").textContent = `Spin for ${ph.label}`;
  $("buildHint").textContent = `Spin for ${ph.label}.`;

  // re-draw with NEW labels
  drawWheelWithOptions(opts);
}

function drawWheelWithOptions(options){
  if(!ctx || !wheel) return;
  const w = wheel.width, h = wheel.height;
  ctx.clearRect(0,0,w,h);

  const cx=w/2, cy=h/2;
  const r=Math.min(cx,cy)-8;
  const n=Math.max(1, options.length);

  ctx.beginPath();
  ctx.arc(cx,cy,r+4,0,Math.PI*2);
  ctx.strokeStyle="rgba(255,255,255,.15)";
  ctx.lineWidth=10;
  ctx.stroke();

  for(let i=0;i<n;i++){
    const a0 = wheelAngle + (i * (Math.PI*2/n));
    const a1 = wheelAngle + ((i+1) * (Math.PI*2/n));

    ctx.beginPath();
    ctx.moveTo(cx,cy);
    ctx.arc(cx,cy,r,a0,a1);
    ctx.closePath();
    ctx.fillStyle = i%2===0 ? "rgba(122,168,255,.14)" : "rgba(255,255,255,.06)";
    ctx.fill();

    const mid=(a0+a1)/2;
    ctx.save();
    ctx.translate(cx,cy);
    ctx.rotate(mid);
    ctx.textAlign="right";
    ctx.fillStyle="rgba(232,238,252,.92)";
    ctx.font="900 14px system-ui";
    ctx.fillText(String(options[i] ?? "‚Äî"), r-14, 6);
    ctx.restore();
  }

  // pointer triangle at TOP
  ctx.beginPath();
  ctx.moveTo(cx, 10);
  ctx.lineTo(cx-12, 34);
  ctx.lineTo(cx+12, 34);
  ctx.closePath();
  ctx.fillStyle="rgba(255,204,102,.95)";
  ctx.fill();
}

/* Correct pick: pointer is at TOP, so pointerAngle = -PI/2 in canvas coordinates */
function pickFromWheelOptions(options){
  const n = Math.max(1, options.length);
  const slice = (Math.PI*2)/n;

  // pointer angle relative to wheelAngle
  const pointer = (-Math.PI/2);
  // we want which slice is under the pointer
  let a = (pointer - wheelAngle) % (Math.PI*2);
  if(a < 0) a += Math.PI*2;
  const idx = Math.floor(a / slice);
  return options[idx] ?? options[0];
}

function applySpinResultToCharacter(result){
  const ph = currentPhase();
  const c = state.character;
  if(!c) return;

  if(ph.pickKey === "race"){
    c.race = result;
    logBuild(`Race ‚Üí ${result}`);
  } else if(ph.mode === "addList"){
    c[ph.pickKey] ||= [];
    if(result && !String(result).startsWith("No ")){
      if(!c[ph.pickKey].includes(result)) c[ph.pickKey].push(result);
      logBuild(`${ph.label} + ${result}`);
    } else {
      logBuild(`${ph.label} ‚Üí ${result}`);
    }
  } else {
    c[ph.pickKey] = result;
    logBuild(`${ph.label} ‚Üí ${result}`);
  }

  // if transform, create detail
  if(ph.key === "transform"){
    c.transformDetail = null;
    if(c.transformation==="Kaioken") c.transformDetail={kind:"kaioken", value:randomFrom(KAIOKEN_OPTIONS)};
    if(c.transformation==="Eight Gates") c.transformDetail={kind:"gates", value:randomFrom(GATES_OPTIONS)};
    if(c.transformation==="Super Saiyan") c.transformDetail={kind:"ssj", value:randomFrom(SAIYAN_FORM_OPTIONS)};
    if(c.transformation==="Titan Transformation") c.transformDetail={kind:"titan", value:randomFrom(TITAN_TYPE_OPTIONS)};
    if(c.transformation==="Tailed Beast") c.transformDetail={kind:"tailed", value:randomFrom(TAILED_BEAST_OPTIONS)};
  }

  saveState();
}

async function spinWheel(){
  if(wheelSpinning) return;
  ensureRoster();
  wheelSpinning = true;

  const options = getWheelOptions();
  if(!options.length){
    wheelSpinning = false;
    toast("Wheel has no options (bug).");
    return;
  }

  let v = 0.35 + Math.random()*0.35;
  const friction = 0.985 - Math.random()*0.006;
  const minTicks = 60 + Math.floor(Math.random()*40);
  let ticks=0;

  function step(){
    ticks++;
    wheelAngle += v;
    v *= friction;
    drawWheelWithOptions(options);

    if(ticks > minTicks && v < 0.01){
      wheelSpinning=false;

      const result = pickFromWheelOptions(options);
      applySpinResultToCharacter(result);

      // AUTO-ADVANCE
      if(getPhaseIndex() < PHASES.length-1){
        setPhaseIndex(getPhaseIndex()+1);
        drawWheelForPhase();
      }else{
        $("wheelHint").textContent = "Build complete. Ready for battles.";
        $("buildHint").textContent = "Build complete. Go to STATS / PvE / PvP.";
      }

      refreshUI();
      return;
    }
    requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
}

/* Hook buttons (overwrite older handlers safely) */
$("spinBtn")?.addEventListener("click", spinWheel);
$("testFastBtn")?.addEventListener("click", ()=>{
  wheelAngle += 2.2;
  drawWheelForPhase();
});
$("skipBtn")?.addEventListener("click", ()=>{
  if(getPhaseIndex() < PHASES.length-1) setPhaseIndex(getPhaseIndex()+1);
  drawWheelForPhase();
  refreshUI();
});
$("newBuildBtn")?.addEventListener("click", newCharacter);

/* Ensure wheel renders correct phase on load */
drawWheelForPhase();
</script>
    <script>
/* =========================
   HOTFIX 4/6 ‚Äî Ensure PvE/PvP tabs exist (minimal inject)
   ========================= */

function ensureBattleTabs(){
  if(!$("tab-pve")){
    const pve = document.createElement("section");
    pve.id = "tab-pve";
    pve.className = "grid hidden";
    pve.innerHTML = `
      <div class="card">
        <h2>PvE Event</h2>
        <div class="muted" style="margin-bottom:10px">Fight an event enemy for coins/XP.</div>
        <button id="pveStartBtn" class="btn primary">Start PvE</button>
        <div class="card" style="margin-top:12px; padding:12px; background:rgba(15,22,35,.45); border-color:rgba(255,255,255,.08)">
          <h2>Combat Log</h2><div id="pveLog" class="muted"></div>
        </div>
      </div>
      <div class="card"><h2>Battle</h2><div class="muted">PvE UI will render here.</div></div>
    `;
    document.querySelector(".app")?.appendChild(pve);
  }

  if(!$("tab-pvp")){
    const pvp = document.createElement("section");
    pvp.id = "tab-pvp";
    pvp.className = "grid hidden";
    pvp.innerHTML = `
      <div class="card">
        <h2>PvP Match</h2>
        <div class="muted" style="margin-bottom:10px">Fight a generated opponent.</div>
        <button id="pvpStartBtn" class="btn primary">Start PvP</button>
        <div class="card" style="margin-top:12px; padding:12px; background:rgba(15,22,35,.45); border-color:rgba(255,255,255,.08)">
          <h2>Combat Log</h2><div id="pvpLog" class="muted"></div>
        </div>
      </div>
      <div class="card"><h2>Battle</h2><div class="muted">PvP UI will render here.</div></div>
    `;
    document.querySelector(".app")?.appendChild(pvp);
  }
}
ensureBattleTabs();
</script>
    <script>
/* =========================
   HOTFIX 5/6 ‚Äî Portrait fallback renderer (SVG)
   ========================= */

function setPortraitFallback(){
  const c = state.character || {};
  const race = c.race || "Unknown";
  const p = (c.powers||[]).slice(0,2).join(" ‚Ä¢ ") || "No Power";
  const w = (c.weapons||[]).slice(0,2).join(" ‚Ä¢ ") || "No Weapon";
  const a = (c.armors||[]).slice(0,2).join(" ‚Ä¢ ") || "No Armor";

  const svg = `
  <svg xmlns="http://www.w3.org/2000/svg" width="600" height="600">
    <defs>
      <linearGradient id="g" x1="0" x2="1">
        <stop offset="0" stop-color="rgba(122,168,255,.35)"/>
        <stop offset="1" stop-color="rgba(46,229,157,.18)"/>
      </linearGradient>
    </defs>
    <rect width="600" height="600" rx="40" fill="rgba(15,22,35,.85)"/>
    <circle cx="300" cy="260" r="170" fill="url(#g)" opacity="0.35"/>
    <circle cx="300" cy="250" r="120" fill="rgba(255,255,255,.06)"/>
    <text x="300" y="110" text-anchor="middle" font-size="42" font-family="system-ui" fill="rgba(232,238,252,.95)" font-weight="800">${race}</text>
    <text x="300" y="420" text-anchor="middle" font-size="22" font-family="system-ui" fill="rgba(232,238,252,.80)" font-weight="700">${p}</text>
    <text x="300" y="455" text-anchor="middle" font-size="22" font-family="system-ui" fill="rgba(232,238,252,.80)" font-weight="700">${w}</text>
    <text x="300" y="490" text-anchor="middle" font-size="22" font-family="system-ui" fill="rgba(232,238,252,.80)" font-weight="700">${a}</text>
  </svg>`;

  const data = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svg);
  const base = $("layer_base");
  if(base) base.src = data;

  // clear other layers so it looks clean
  ["layer_body","layer_back","layer_legs","layer_arms","layer_head","layer_armor","layer_weapon","layer_fx"]
    .forEach(id=>{ const el=$(id); if(el) el.src=""; });
}

/* call portrait fallback inside refreshUI (wrap existing) */
const _refreshUI_hotfixPortrait = refreshUI;
refreshUI = function(){
  _refreshUI_hotfixPortrait();
  setPortraitFallback();
};
refreshUI();
</script>
    <script>
/* =========================
   HOTFIX 6/6 ‚Äî Sound + Name Safety
   ========================= */

function audioBeep(freq=440, ms=60, type="sine", vol=0.05){
  if(!state.settings?.sound) return;
  try{
    const AC = window.AudioContext || window.webkitAudioContext;
    const ac = new AC();
    const o = ac.createOscillator();
    const g = ac.createGain();
    o.type = type;
    o.frequency.value = freq;
    g.gain.value = vol;
    o.connect(g); g.connect(ac.destination);
    o.start();
    setTimeout(()=>{ o.stop(); ac.close(); }, ms);
  }catch(e){}
}
function sfxClick(){ audioBeep(520, 35, "square", 0.03); }
function sfxSpin(){ audioBeep(220, 80, "sawtooth", 0.02); }
function sfxWin(){ audioBeep(660, 70, "triangle", 0.04); setTimeout(()=>audioBeep(880, 70, "triangle", 0.04), 90); }

$("volBtn")?.addEventListener("click", ()=>{
  state.settings ||= {};
  state.settings.sound = !state.settings.sound;
  saveState();
  $("volBtn").textContent = state.settings.sound ? "üîä" : "üîá";
  toast(state.settings.sound ? "Sound ON" : "Sound OFF");
  sfxClick();
});

/* Name safety: strict allowed characters, length, and normalized-blocklist hook */
const MANUAL_BLOCKLIST = [
  // Add your own blocked words here if you want.
  // (Keep it private / don‚Äôt paste slurs into chat.)
];

function normalizeName(s){
  return String(s||"")
    .toLowerCase()
    .replace(/\s+/g," ")
    .trim()
    .replace(/[0-9]/g, "")      // no numbers
    .replace(/[^a-z ]/g, "");   // letters + spaces only
}

function isNameAllowed(name){
  const raw = String(name||"").trim();

  // length
  if(raw.length < 2 || raw.length > 16) return { ok:false, reason:"2‚Äì16 characters." };

  // only letters/spaces (blocks most bad stuff + bypass attempts)
  if(!/^[A-Za-z ]+$/.test(raw)) return { ok:false, reason:"Letters/spaces only." };

  // no double-spaces, no leading/trailing handled by trim; also block super repetitive spam
  if(/(.)\1\1\1/.test(raw.toLowerCase())) return { ok:false, reason:"Too repetitive." };

  const norm = normalizeName(raw);

  // manual blocklist hook
  for(const w of MANUAL_BLOCKLIST){
    const bw = normalizeName(w);
    if(bw && norm.includes(bw)) return { ok:false, reason:"Not allowed." };
  }

  return { ok:true };
}

/* Add a Set Name prompt if you have a button (safe even if not) */
function setNameFlow(){
  const name = prompt("Enter character name (2‚Äì16 letters):", state.character?.name || "");
  if(name === null) return;
  const chk = isNameAllowed(name);
  if(!chk.ok){
    toast(`Name blocked: ${chk.reason}`);
    return;
  }
  state.character.name = name.trim();
  $("namedTag").textContent = `Active: ${state.character.name}`;
  saveState();
  refreshUI();
  toast("Name set.");
  sfxClick();
}

/* If you already have a button, wire it. If not, it won‚Äôt do anything. */
document.querySelectorAll("[data-action='set-name'], #setNameBtn").forEach(b=>{
  b.addEventListener("click", setNameFlow);
});

/* Add sound cues to spin + victory if you later hook PvE/PvP wins */
const _spinWheel_sfx = spinWheel;
spinWheel = async function(){
  sfxSpin();
  return _spinWheel_sfx();
};

/* make sure vol icon is correct on load */
$("volBtn").textContent = state.settings?.sound ? "üîä" : "üîá";
</script>
</body>
</html>
